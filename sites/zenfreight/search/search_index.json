{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kairos-zen Specification","text":"<p>kairos-zen will be an agent-based simulation model developed as part of the ZENFreight project. Built using the Kairos modelling architecture developed by the Transport Systems &amp; Logistics Laboratory, it will model freight operations during the transition to zero-emission vehicles.</p> <p>The system will simulate a freight operator managing a mixed fleet of vehicles with different propulsion technologies.</p>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#model-architecture","title":"Model Architecture","text":"<ul> <li>Overview - Executive summary and system architecture</li> <li>System Components - Vehicle, demand, and infrastructure modeling</li> <li>Planning &amp; Optimization - Vehicle assignment and route optimization</li> <li>Operations &amp; Monitoring - Real-time execution and KPIs</li> <li>Advanced Analysis - Resilience testing and strategy comparison</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Use Cases and Applications - Fleet planning, operational planning, policy analysis, and research applications</li> </ul>"},{"location":"#data-requirements","title":"Data Requirements","text":"<ul> <li>Data Requirements - Public domain data sources and partner data requirements</li> </ul>"},{"location":"#implementation","title":"Implementation","text":"<ul> <li>Implementation Guide - Technical architecture and deployment</li> <li>Technical Reference - Appendices and detailed specifications</li> <li>Vehicle Entities - Vehicle modeling implementation</li> <li>Fleet Controller - Operations management code</li> <li>Vehicle Assignment - Assignment algorithms</li> <li>Resilience Analysis - Disruption modeling</li> <li>Future Concepts - Planned enhancements</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Mixed Fleet Management - Will support Battery Electric, Hydrogen Fuel Cell, and Diesel vehicles</li> <li>Route Optimization - Will provide pre-execution planning with real-time adjustments</li> <li>UK Regulatory Compliance - Will enforce driver hours, weight limits, and operational constraints</li> <li>Resilience Analysis - Will model infrastructure disruption and recovery scenarios</li> <li>Cost Analysis - Will calculate Total Cost of Ownership across vehicle technologies</li> <li>Kairos Framework - Will be built on proven agent-based simulation architecture</li> </ul>"},{"location":"analysis/","title":"Advanced Analysis","text":"<p>Resilience testing, strategic comparisons, and scenario analysis capabilities that will be provided for decision support.</p>"},{"location":"analysis/#resilience-analysis-and-strategy-comparison","title":"Resilience Analysis and Strategy Comparison","text":""},{"location":"analysis/#supply-network-resilience-testing-future-capability","title":"Supply Network Resilience Testing (Future Capability)","text":"<p>The simulation architecture will be designed to support resilience testing through controlled disruption scenarios. This capability would ideally be implemented as a general feature in the Kairos framework, enabling:</p> <p>Infrastructure Disruptions:</p> <ul> <li>Charging station failures (equipment breakdown, power outages)</li> <li>Hydrogen station unavailability (supply shortage, maintenance)</li> <li>Road network disruptions (accidents, construction, weather)</li> <li>Depot access restrictions (strikes, emergencies)</li> </ul> <p>Fleet Disruptions:</p> <ul> <li>Vehicle breakdowns (mechanical, battery, software)</li> <li>Driver unavailability (illness, regulations)</li> <li>Cascade effects from vehicle dependencies</li> </ul> <p>Demand Fluctuations:</p> <ul> <li>Sudden demand spikes (seasonal, events)</li> <li>Geographic demand shifts</li> <li>Priority emergency deliveries</li> <li>Customer site accessibility issues</li> </ul> <p>Proposed Resilience Metrics:</p> <ul> <li>Service level degradation under stress</li> <li>Recovery time to normal operations</li> <li>Cost of disruption (failed deliveries, penalties)</li> <li>Alternative route availability</li> </ul> <p>Implementation Considerations:</p> <p>A general resilience testing framework in Kairos will provide:</p> <ul> <li>Standardized disruption event injection</li> <li>Automated metric collection before/during/after disruptions</li> <li>Comparison tools for baseline vs stressed performance</li> <li>Recovery pattern analysis</li> </ul> <p>This would benefit all Kairos-based simulations, not just freight operations.</p>"},{"location":"analysis/#fleet-strategy-comparison-framework","title":"Fleet Strategy Comparison Framework","text":"<p>The simulation will be structured to enable systematic comparison of different fleet strategies:</p> <p>Strategy Dimensions:</p> <ol> <li> <p>Fleet Composition</p> <ul> <li>100% Diesel baseline</li> <li>Progressive electrification (20%, 40%, 60%, 80% BEV)</li> <li>Mixed technology (BEV + HFCEV + Diesel)</li> </ul> </li> <li> <p>Operational Strategies</p> <ul> <li>Depot-only charging vs opportunistic charging</li> <li>Dedicated vehicle-customer assignments vs flexible pool</li> <li>Hub-and-spoke vs direct delivery</li> <li>Day vs night operations</li> </ul> </li> <li> <p>Infrastructure Investment</p> <ul> <li>Minimal (depot only)</li> <li>Moderate (key route coverage)</li> <li>Comprehensive (full network coverage)</li> </ul> </li> </ol> <p>Comparison Metrics:</p> <ul> <li>Total Cost of Ownership (TCO) over 5/10 years</li> <li>Operational efficiency (deliveries per vehicle-day)</li> <li>Environmental impact (CO2, NOx, PM)</li> <li>Service reliability (on-time delivery rate)</li> <li>Resilience score (performance under disruption)</li> </ul>"},{"location":"analysis/#cost-monitoring-and-analysis","title":"Cost Monitoring and Analysis","text":"<p>The simulation will track comprehensive costs to enable TCO analysis and strategy comparison:</p> <p>Capital Costs:</p> <ul> <li>Vehicle purchase/lease costs by type</li> <li>Infrastructure installation costs</li> <li>Depot upgrade requirements</li> <li>Grid connection upgrades</li> </ul> <p>Operational Costs:</p> <ul> <li>Energy costs (electricity, hydrogen, diesel)</li> <li>Maintenance costs by vehicle type</li> <li>Driver wages and overtime</li> <li>Insurance and licensing</li> </ul> <p>Penalty Costs:</p> <ul> <li>Late delivery penalties</li> <li>Failed delivery costs</li> <li>Customer compensation</li> <li>Regulatory fines</li> </ul> <p>Cost Analysis Outputs:</p> <ul> <li>Cost per delivery by vehicle type</li> <li>Cost per tonne-km</li> <li>Route profitability analysis</li> <li>Break-even analysis for BEV/HFCEV adoption</li> </ul>"},{"location":"analysis/#future-analysis-capabilities","title":"Future Analysis Capabilities","text":"<p>Planned Enhancements:</p> <ol> <li> <p>Automated Scenario Testing</p> <ul> <li>Systematic exploration of parameter spaces</li> <li>Monte Carlo simulation for uncertainty analysis</li> <li>Sensitivity analysis for key variables</li> </ul> </li> <li> <p>Machine Learning Integration</p> <ul> <li>Demand prediction models</li> <li>Optimal routing under uncertainty</li> <li>Failure prediction and preventive maintenance</li> </ul> </li> <li> <p>Real-Time Optimization</p> <ul> <li>Dynamic re-routing during disruptions</li> <li>Adaptive charging strategies</li> <li>Load balancing across fleet</li> </ul> </li> <li> <p>Advanced Reporting</p> <ul> <li>Interactive dashboards</li> <li>Automated insight generation</li> <li>Policy recommendation engine</li> </ul> </li> </ol> <p>Integration with Kairos Framework:</p> <p>These capabilities will be developed as general Kairos features:</p> <ul> <li>Scenario Manager: Standardized scenario definition and execution</li> <li>Resilience Module: Disruption injection and recovery analysis</li> <li>Comparison Engine: Multi-simulation comparison tools</li> <li>Cost Tracker: Universal cost monitoring across all agent types</li> </ul> <p>This will create reusable components benefiting the entire Kairos ecosystem.</p>"},{"location":"components/","title":"System Components","text":"<p>The core modeling components that will represent multiple operators, their vehicles, shared customer demands, and supporting infrastructure.</p>"},{"location":"components/#vehicle-fleet-modeling","title":"Vehicle Fleet Modeling","text":""},{"location":"components/#vehicle-specification-system","title":"Vehicle Specification System","text":"<p>The simulation will use a two-tier vehicle model:</p> <ul> <li>Vehicle Specifications: Static manufacturer data defining vehicle capabilities</li> <li>Vehicle Instances: Dynamic agents representing individual vehicles in operation</li> </ul>"},{"location":"components/#propulsion-technologies","title":"Propulsion Technologies","text":"<p>Battery Electric Vehicles (BEV):</p> <ul> <li>Battery modeling with capacity and SoC.</li> <li>Non-linear charging curves based on state-of-charge</li> <li>Temperature effects on range and performance</li> <li>Approximate energy recuperation through regenerative braking</li> </ul> <p>Hydrogen Fuel Cell Vehicles (HFCEV):</p> <ul> <li>Hydrogen consumption modeling</li> <li>Refueling time constraints</li> <li>Fuel cell efficiency curves</li> </ul> <p>Diesel Vehicles:</p> <ul> <li>Traditional baseline for comparison</li> </ul>"},{"location":"components/#fleet-management","title":"Fleet Management","text":"<p>Each operator will maintain their own VehicleAgentGroup with sparse properties:</p> <ul> <li>Operator-Specific Fleets: Independent fleet management per operator</li> <li>Common Properties: Location, speed, payload for all vehicles within operator fleet</li> <li>Technology Properties: BEV/HFCEV/Diesel-specific properties set appropriately</li> <li>Multi-Delivery Capabilities: Vehicles can serve multiple customers per route</li> <li>Competitive Dynamics: Operators compete for customers and infrastructure resources</li> </ul>"},{"location":"components/#demand-management","title":"Demand Management","text":""},{"location":"components/#demand-characteristics","title":"Demand Characteristics","text":"<p>Each freight demand will represent a delivery requirement with:</p> <ul> <li>Origin and destination locations</li> <li>Time windows for pickup and delivery</li> <li>Cargo specifications (weight, volume, type)</li> <li>Service level requirements</li> <li>Special handling needs</li> </ul>"},{"location":"components/#demand-allocation-and-lifecycle","title":"Demand Allocation and Lifecycle","text":"<p>Customer-to-Operator Allocation:</p> <p>Customers will be pre-allocated to specific operators as defined in the simulation configuration.</p> <p>Fleet-Level Vehicle Assignment: <pre><code>OPERATOR_DEMAND \u2192 VEHICLE_ASSIGNMENT \u2192 PLANNED \u2192 IN_TRANSIT \u2192 DELIVERED\n                        \u2193                    \u2193\n                   UNASSIGNED          FAILED (constraints violated)\n</code></pre></p> <p>Vehicle Assignment Mechanisms:</p> <ul> <li>Capacity Matching: Assign vehicles based on cargo capacity and specifications</li> <li>Route Optimization: Select vehicles to minimize total distance and time</li> <li>Technology Suitability: Match vehicle propulsion type to route requirements</li> <li>Availability Constraints: Consider vehicle maintenance schedules and driver hours</li> </ul>"},{"location":"components/#service-level-tracking","title":"Service Level Tracking","text":"<p>The system will monitor performance across operators:</p> <ul> <li>Per-Operator Metrics: On-time delivery performance and fleet utilization by operator</li> <li>Fleet Efficiency: Vehicle assignment success rates and route optimization effectiveness</li> <li>Service Quality: Time window compliance and delivery success rates</li> <li>Operational Analysis: Comparative fleet performance and resource utilization between operators</li> </ul>"},{"location":"components/#infrastructure-modeling","title":"Infrastructure Modeling","text":""},{"location":"components/#charging-infrastructure-bev","title":"Charging Infrastructure (BEV)","text":"<p>Operator-Owned Depot Charging:</p> <ul> <li>Lower power (100-150kW)</li> <li>Overnight charging for operator's fleet</li> <li>Guaranteed availability for fleet vehicles</li> <li>Lower cost per kWh</li> </ul> <p>Shared Public Rapid Charging:</p> <ul> <li>High power (350kW+)</li> <li>En-route charging during multi-delivery routes</li> <li>Queue management across multiple operators</li> <li>Higher cost per kWh</li> <li>Competition for charging slots between operators</li> </ul>"},{"location":"components/#hydrogen-infrastructure-hfcev","title":"Hydrogen Infrastructure (HFCEV)","text":"<p>Shared Refueling Stations:</p> <ul> <li>700 bar dispensing for all operators</li> <li>10-15 minute refuel time</li> <li>Limited geographic coverage creating competition</li> <li>Capacity constraints affecting multiple operators</li> <li>Queue management across competing fleets</li> </ul>"},{"location":"components/#depot-operations","title":"Depot Operations","text":"<p>Operator-Specific Facilities:</p> <ul> <li>Dedicated parking bay allocation per operator</li> <li>Independent maintenance scheduling</li> <li>Operator-specific load handling procedures</li> <li>Separate driver facilities per operator</li> </ul> <p>Shared Facilities (Optional):</p> <ul> <li>Multi-operator consolidation centers</li> <li>Shared maintenance facilities</li> <li>Common driver rest areas</li> </ul>"},{"location":"data_requirements/","title":"Data Requirements","text":"<p>kairos-zen will require various types of data for accurate simulation modeling. This section categorizes data by availability and sourcing requirements.</p>"},{"location":"data_requirements/#public-domain-data-sources","title":"Public Domain Data Sources","text":"<p>These data types will be authoritatively obtained from publicly available sources:</p>"},{"location":"data_requirements/#road-network-data","title":"Road Network Data","text":"<ul> <li>OpenStreetMap: Comprehensive road network topology and attributes</li> <li>National mapping agencies: Official road classifications and restrictions</li> <li>Traffic authorities: Speed limits, weight restrictions, environmental zones</li> <li>Geographic services: Distance matrices and routing APIs</li> </ul>"},{"location":"data_requirements/#vehicle-specifications","title":"Vehicle Specifications","text":"<ul> <li>Manufacturer data: Technical specifications for commercial vehicles</li> <li>Type approval databases: Official vehicle performance and emissions data</li> <li>Industry reports: Battery technology specifications and charging curves</li> <li>Research publications: Energy consumption models and efficiency data</li> </ul>"},{"location":"data_requirements/#economic-data","title":"Economic Data","text":"<ul> <li>Energy authorities: Electricity tariffs and pricing structures</li> <li>Fuel suppliers: Hydrogen and diesel pricing data</li> <li>Government statistics: Labor costs and wage information</li> <li>Industry surveys: Vehicle purchase prices and total cost of ownership</li> </ul>"},{"location":"data_requirements/#partner-data-requirements","title":"Partner Data Requirements","text":"<p>These data types will typically require collaboration with industry partners or customers:</p>"},{"location":"data_requirements/#regulatory-framework","title":"Regulatory Framework","text":"<ul> <li>Government agencies: Driver hours regulations (EU 561/2006, UK Working Time)</li> <li>Transport authorities: Vehicle weight limits, emission standards</li> <li>Environmental agencies: Low emission zone boundaries and restrictions</li> <li>Standards organizations: Charging standards (CCS, MCS), safety regulations</li> </ul>"},{"location":"data_requirements/#infrastructure-locations","title":"Infrastructure Locations","text":"<ul> <li>Charging network operators: Public charging station locations and specifications</li> <li>Government databases: Planned infrastructure investments and locations</li> <li>Industry associations: Hydrogen refueling station networks</li> <li>Open data portals: Energy grid connection points and capacity</li> </ul>"},{"location":"data_requirements/#operator-specific-data","title":"Operator-Specific Data","text":"<ul> <li>Fleet composition: Current vehicle types, ages, and specifications per operator</li> <li>Operational parameters: Business rules, service areas, operational constraints</li> <li>Performance metrics: Historical delivery success rates, efficiency measures</li> <li>Cost structures: Operator-specific pricing, maintenance costs, financing arrangements</li> <li>Strategic objectives: Business goals, growth plans, sustainability targets</li> </ul>"},{"location":"data_requirements/#customer-demand-data","title":"Customer Demand Data","text":"<ul> <li>Delivery patterns: Historical shipment volumes, frequencies, and seasonality</li> <li>Geographic distribution: Origin-destination matrices for freight movements</li> <li>Time constraints: Customer time windows, service level requirements</li> <li>Cargo specifications: Weight, volume, and special handling requirements</li> <li>Customer preferences: Service quality expectations, reliability requirements</li> </ul>"},{"location":"data_requirements/#commercial-relationships","title":"Commercial Relationships","text":"<ul> <li>Customer contracts: Service agreements, pricing structures, penalty clauses</li> <li>Infrastructure partnerships: Charging network access agreements, depot sharing</li> <li>Supply chain integration: Logistics network connections, consolidation opportunities</li> </ul>"},{"location":"data_requirements/#operational-intelligence","title":"Operational Intelligence","text":"<ul> <li>Real-time conditions: Traffic patterns, infrastructure availability, weather impacts</li> <li>Performance benchmarks: Industry standards, competitive performance metrics</li> <li>Innovation roadmaps: Technology adoption plans, infrastructure development timelines</li> </ul>"},{"location":"data_requirements/#data-quality-requirements","title":"Data Quality Requirements","text":""},{"location":"data_requirements/#temporal-resolution","title":"Temporal Resolution","text":"<ul> <li>Real-time data: Vehicle positions, infrastructure status, traffic conditions</li> <li>Hourly data: Demand patterns, energy pricing, driver availability</li> <li>Daily data: Operational schedules, maintenance activities, performance metrics</li> <li>Monthly/Annual data: Strategic planning, budget cycles, technology updates</li> </ul>"},{"location":"data_requirements/#spatial-resolution","title":"Spatial Resolution","text":"<ul> <li>Point locations: Specific addresses for customers, depots, infrastructure</li> <li>Route segments: Detailed road network with attributes and restrictions</li> <li>Service areas: Geographic boundaries for operator coverage and competition</li> <li>Regional data: Market characteristics, regulatory variations, economic conditions</li> </ul>"},{"location":"data_requirements/#data-validation","title":"Data Validation","text":"<ul> <li>Consistency checks: Cross-validation between different data sources</li> <li>Completeness assessment: Identification of missing or incomplete data elements</li> <li>Accuracy verification: Validation against ground truth and industry benchmarks</li> <li>Currency maintenance: Regular updates to reflect changing conditions and regulations</li> </ul>"},{"location":"data_requirements/#data-integration-strategies","title":"Data Integration Strategies","text":""},{"location":"data_requirements/#public-private-partnerships","title":"Public-Private Partnerships","text":"<ul> <li>Data sharing agreements: Structured collaboration with industry partners</li> <li>Anonymization protocols: Privacy-preserving data sharing techniques</li> <li>Standardized formats: Common data schemas and exchange protocols</li> <li>Quality assurance: Joint validation and verification processes</li> </ul>"},{"location":"data_requirements/#synthetic-data-generation","title":"Synthetic Data Generation","text":"<ul> <li>Statistical modeling: Generation of realistic demand patterns from aggregate data</li> <li>Scenario simulation: Creation of stress-test scenarios for resilience analysis</li> <li>Privacy protection: Synthetic alternatives to sensitive commercial data</li> <li>Model validation: Verification against real-world patterns and behaviors</li> </ul>"},{"location":"data_requirements/#data-marketplace-integration","title":"Data Marketplace Integration","text":"<ul> <li>Commercial data providers: Integration with specialized freight data services</li> <li>Industry consortiums: Participation in collaborative data sharing initiatives</li> <li>Research partnerships: Academic collaborations for data access and validation</li> <li>Government programs: Utilization of public sector data sharing initiatives</li> </ul>"},{"location":"implementation/","title":"Overview","text":"<p>Technical architecture, deployment guidelines, and practical use cases that will be provided for developers and system integrators.</p>"},{"location":"implementation/#architecture","title":"Architecture","text":""},{"location":"implementation/#controller-structure","title":"Controller Structure","text":"<p>The simulation will support multiple operators with hierarchical controller architecture:</p> <ul> <li>OperatorController: Each operator has its own controller containing:</li> <li>FleetController: Independent fleet management and vehicle operations</li> <li>Operator Configuration: Fleet composition, operational parameters, service areas</li> <li>DemandController (Global): Manages demand lifecycle and coordinates operator-specific assignments</li> <li>InfrastructureController (Shared): Manages shared charging/refueling resources</li> <li>NetworkController (Global): Provides road network services to all operators</li> </ul> <p>Operator Specifications: - Independent decision-making for route optimization and vehicle assignments - Competitive dynamics for shared infrastructure and customer demands</p>"},{"location":"implementation/#feature-system","title":"Feature System","text":"<p>Features will provide cross-cutting functionality across operators:</p> <ul> <li>Propulsion Features: Technology-specific behaviors (applied per operator fleet)</li> <li>Energy Management: Consumption and charging logic with shared infrastructure</li> <li>Multi-Route Execution: Following planned multi-delivery routes</li> <li>Maintenance Tracking: Service scheduling per operator</li> </ul>"},{"location":"implementation/#data-model","title":"Data Model","text":"<ul> <li>Operator Groups: Separate AgentGroups for each operator's fleet</li> <li>Shared Resources: Common infrastructure accessed by multiple operators</li> <li>Efficient Operations: Vectorized operations across large multi-operator scenarios</li> <li>Memory Efficiency: Sparse arrays for operator-specific properties</li> </ul>"},{"location":"implementation/#development-guidelines","title":"Development Guidelines","text":""},{"location":"implementation/#model-integration","title":"Model Integration","text":"<p>When integrating kairos-zen into larger systems, the following will be required:</p> <ol> <li>Data Requirements: Ensure access to demand patterns, operator specifications, vehicle fleets per operator, shared infrastructure locations, and road network data</li> <li>Configuration Management: Use structured configuration files for operator parameters, fleet compositions, and market dynamics</li> <li>Output Processing: Implement interfaces for operator-specific and system-wide results extraction</li> <li>Scalability Considerations: Plan computational resources for multiple operators, larger combined fleets, and complex multi-delivery routes</li> </ol>"},{"location":"implementation/#performance-optimization","title":"Performance Optimization","text":"<p>For large-scale simulations, the system will use:</p> <ul> <li>Vectorization: Leverage NumPy operations for bulk calculations</li> <li>Memory Management: Use sparse arrays for vehicle-specific properties</li> <li>Parallel Processing: Distribute independent calculations across cores</li> <li>Caching: Store frequently accessed calculations for reuse</li> </ul>"},{"location":"implementation/#integration-with-kairos-framework","title":"Integration with Kairos Framework","text":"<p>kairos-zen will leverage the following Kairos capabilities:</p> <ul> <li>Agent Groups: Efficient management of vehicle and demand collections</li> <li>Property Arrays: Memory-efficient storage of entity attributes</li> <li>Feature System: Modular functionality for cross-cutting concerns</li> <li>State Management: Robust handling of entity state transitions</li> <li>Clock Management: Synchronized time progression across all components</li> </ul>"},{"location":"operations/","title":"Operations & Monitoring","text":""},{"location":"operations/#operational-execution","title":"Operational Execution","text":""},{"location":"operations/#multi-delivery-vehicle-states","title":"Multi-Delivery Vehicle States","text":"<p>Vehicles executing multi-delivery routes will progress through expanded operational states:</p> <pre><code>IDLE \u2192 LOADING \u2192 EN_ROUTE \u2192 STOP_1 \u2192 EN_ROUTE \u2192 STOP_2 \u2192 ... \u2192 STOP_N \u2192 RETURNING\n         \u2193                    \u2193                    \u2193              \u2193\n    CHARGING/REFUELING    DELIVERING         DELIVERING      DELIVERING\n                             \u2193                    \u2193              \u2193\n                        CHARGING/REFUELING  CHARGING/REFUELING  CHARGING/REFUELING\n</code></pre> <p>Multi-Operator Coordination:</p> <ul> <li>Infrastructure Sharing: Vehicles from different operators may queue at shared charging/refueling stations</li> <li>Route Conflicts: Multiple operators may serve overlapping areas with different efficiency</li> </ul>"},{"location":"operations/#dynamic-event-handling","title":"Dynamic Event Handling","text":"<p>The simulation will handle multi-operator scenarios:</p> <ul> <li>Traffic delays affecting multiple operators' routes</li> <li>Vehicle breakdowns requiring route reassignment within operator fleet</li> <li>Infrastructure queues with multiple operators competing for access</li> <li>Cascading delays where one operator's delays affect shared infrastructure</li> <li>Competitive responses where operators adapt to competitors' actions</li> </ul>"},{"location":"operations/#performance-monitoring","title":"Performance Monitoring","text":"<p>The system will provide real-time tracking across operators:</p> <ul> <li>Vehicle utilization per operator and system-wide</li> <li>Multi-delivery efficiency (deliveries per route, consolidation rates)</li> <li>Energy consumption by operator and technology type</li> <li>Delivery performance with competitive benchmarking</li> <li>Infrastructure utilization showing shared resource usage</li> <li>Cost accumulation with operator-specific and comparative metrics</li> </ul>"},{"location":"operations/#key-performance-indicators","title":"Key Performance Indicators","text":""},{"location":"operations/#operational-metrics-multi-operator","title":"Operational Metrics (Multi-Operator)","text":"<ul> <li>Fleet Utilization by Operator: Comparative productivity metrics</li> <li>Multi-Delivery Efficiency: Average stops per route, consolidation success</li> <li>On-Time Delivery Rate: Performance by operator and system-wide</li> <li>Service Performance: Demand fulfillment and delivery success rates by operator</li> <li>Infrastructure Competition: Queue times and resource conflicts</li> </ul>"},{"location":"operations/#energy-and-environmental-metrics","title":"Energy and Environmental Metrics","text":"<ul> <li>Energy Efficiency: kWh/tonne-km or kWh/delivery</li> <li>CO2 Emissions: Total and per tonne-km</li> <li>Renewable Energy Usage: Percentage from green sources</li> <li>Air Quality Impact: NOx and PM emissions</li> </ul>"},{"location":"operations/#financial-metrics","title":"Financial Metrics","text":"<ul> <li>Cost per Delivery: Total operational cost divided by deliveries</li> <li>Energy Cost: Electricity/hydrogen/diesel expenses</li> <li>Vehicle TCO: Total cost of ownership by vehicle type</li> <li>Infrastructure Utilization: Usage vs. capacity</li> </ul>"},{"location":"operations/#compliance-metrics","title":"Compliance Metrics","text":"<ul> <li>Driver Hours Violations: Regulation breaches</li> <li>Weight Limit Exceedances: Overloading incidents</li> <li>Maintenance Compliance: Scheduled vs. actual</li> </ul>"},{"location":"overview/","title":"kairos-zen: Overview","text":"<p>kairos-zen is an agent-based simulation model developed as part of the ZENFreight project. Built using the Kairos modelling architecture developed by the Transport Systems &amp; Logistics Laboratory.</p> <p>kairos-zen will simulate freight operations during the transition to zero-emission vehicles. It will model multiple freight operators, each managing their own mixed fleet of Battery Electric, Hydrogen Fuel Cell, and Diesel vehicles. The system will optimize multi-delivery routes and vehicle assignments while respecting real-world constraints and operator interactions.</p> <p>The simulation will provide insights into:</p> <ul> <li>Optimal fleet composition strategies across multiple operators</li> <li>Multi-delivery route efficiency and consolidation opportunities</li> <li>Infrastructure investment requirements and shared resource utilization</li> <li>Operational cost comparisons between different fleet compositions</li> </ul>"},{"location":"overview/#system-architecture","title":"System Architecture","text":""},{"location":"overview/#core-design-principles","title":"Core Design Principles","text":"<ol> <li> <p>Multi-Operator Architecture: Will simulate multiple competing or collaborating freight operators, each with independent fleet management and customer bases.</p> </li> <li> <p>Multi-Delivery Route Optimization: Vehicles will serve multiple customers per trip, optimizing consolidation and efficiency opportunities.</p> </li> <li> <p>Vectorized Operations: All entities will use AgentGroup architecture with PropertyArrays for efficient NumPy-based operations across large-scale scenarios.</p> </li> <li> <p>Pre-Execution Optimization: Multi-stop route planning and vehicle assignment will occur before simulation execution, with real-time adjustments for disruptions.</p> </li> <li> <p>Mixed Fleet Management: Will provide unified handling of different propulsion types through sparse property arrays within each operator's fleet.</p> </li> <li> <p>Regulatory Compliance: Will include built-in validation of driver hours regulations, weight limits, and operational constraints across all operators.</p> </li> </ol>"},{"location":"overview/#system-components","title":"System Components","text":"<pre><code>World (Simulation Container)\n\u2502\n\u251c\u2500\u2500 Operator 1\n\u2502   \u2514\u2500\u2500 OperatorController\n\u2502       \u251c\u2500\u2500 FleetController\n\u2502       \u2502   \u251c\u2500\u2500 Will manage operator's vehicle fleet\n\u2502       \u2502   \u251c\u2500\u2500 Will handle multi-delivery route assignments\n\u2502       \u2502   \u2514\u2500\u2500 Will monitor vehicle states and performance\n\u2502       \u251c\u2500\u2500 Operator Configuration\n\u2502       \u2502   \u251c\u2500\u2500 Fleet composition and specifications\n\u2502       \u2502   \u251c\u2500\u2500 Service areas and operational parameters\n\u2502       \u2502   \u2514\u2500\u2500 Business rules and constraints\n\u2502       \u2514\u2500\u2500 Features:\n\u2502           \u251c\u2500\u2500 BEVPropulsionFeature\n\u2502           \u251c\u2500\u2500 HFCEVPropulsionFeature\n\u2502           \u251c\u2500\u2500 DieselPropulsionFeature\n\u2502           \u251c\u2500\u2500 EnergyManagementFeature\n\u2502           \u2514\u2500\u2500 MaintenanceFeature\n\u2502\n\u251c\u2500\u2500 Operator 2...N (Additional Operators)\n\u2502   \u2514\u2500\u2500 OperatorController (Independent operator management)\n\u2502\n\u251c\u2500\u2500 DemandController\n\u2502   \u251c\u2500\u2500 Will manage all customer demands across operators\n\u2502   \u251c\u2500\u2500 Will track demand allocation and lifecycle\n\u2502   \u2514\u2500\u2500 Will monitor service levels by operator\n\u2502\n\u251c\u2500\u2500 InfrastructureController (Shared Resources)\n\u2502   \u251c\u2500\u2500 ChargingNetwork (BEV) - shared or operator-specific\n\u2502   \u251c\u2500\u2500 HydrogenStations (HFCEV) - shared infrastructure\n\u2502   \u2514\u2500\u2500 DepotFacilities - operator-owned facilities\n\u2502\n\u2514\u2500\u2500 NetworkController\n    \u251c\u2500\u2500 Road network model (shared)\n    \u251c\u2500\u2500 Distance calculations\n    \u2514\u2500\u2500 Travel time estimation\n</code></pre>"},{"location":"overview/#operational-flow","title":"Operational Flow","text":"<p>Pre-Simulation Phase:</p> <ol> <li>Load customer demands across all operators (pre-allocated to operators)</li> <li>Process operator-specific demands within each fleet controller</li> <li>Optimize multi-delivery vehicle routes for each operator</li> <li>Validate feasibility against constraints and operator capabilities</li> <li>Load final plans into simulation</li> </ol> <p>Simulation Execution Phase:</p> <ol> <li>Vehicles execute multi-stop delivery routes</li> <li>Handle dynamic events and inter-operator interactions</li> <li>Manage charging/refueling operations (shared infrastructure)</li> <li>Track performance metrics by operator and system-wide</li> <li>Generate comparative operational reports</li> </ol>"},{"location":"planning/","title":"Planning &amp; Optimization","text":"<p>Algorithms and processes that will be used for optimal vehicle-to-demand assignment and route generation.</p>"},{"location":"planning/#multi-delivery-route-optimization","title":"Multi-Delivery Route Optimization","text":""},{"location":"planning/#multi-stop-assignment-problem","title":"Multi-Stop Assignment Problem","text":"<p>Given a set of demands allocated to each operator and their available vehicles, determine optimal multi-delivery routes that:</p> <ul> <li>Minimize Total Cost: Operational costs across multi-stop routes</li> <li>Maximize Consolidation: Multiple deliveries per vehicle trip</li> <li>Respect Constraints: Vehicle capacity, time windows, range limitations</li> <li>Optimize Efficiency: Reduce empty miles and maximize payload utilization</li> </ul>"},{"location":"planning/#multi-delivery-route-algorithm","title":"Multi-Delivery Route Algorithm","text":"<p>The system will use a three-phase approach for each operator:</p> <p>Phase 1: Demand Clustering</p> <ul> <li>Group operator's demands by geographic proximity</li> <li>Consider time window compatibility across multiple stops</li> <li>Balance total cluster weight/volume with vehicle capacity</li> <li>Create delivery sequences within clusters</li> </ul> <p>Phase 2: Route Construction</p> <ul> <li>Build multi-stop routes connecting clustered demands</li> <li>Optimize stop order for minimum travel distance</li> <li>Consider pickup and delivery time windows</li> <li>Account for loading/unloading time at each stop</li> </ul> <p>Phase 3: Vehicle-Route Assignment</p> <ul> <li>Match vehicle capabilities to multi-stop route requirements</li> <li>Consider total route duration vs. vehicle range (especially BEVs)</li> <li>Plan charging/refueling stops for longer routes</li> <li>Validate driver hours compliance for entire route</li> </ul>"},{"location":"planning/#multi-route-feasibility-validation","title":"Multi-Route Feasibility Validation","text":"<p>Each multi-delivery route will be validated for:</p> <ul> <li>Cumulative Capacity: Total cargo across all stops fits vehicle capacity</li> <li>Route Range: Total distance including all stops within vehicle range</li> <li>Time Window Feasibility: All delivery windows can be satisfied in sequence</li> <li>Driver Hours: Complete route complies with break and rest regulations</li> <li>Infrastructure Access: Required charging/refueling stations available on route</li> </ul>"},{"location":"planning/#route-planning","title":"Route Planning","text":""},{"location":"planning/#multi-stop-route-optimization","title":"Multi-Stop Route Optimization","text":"<p>For each multi-delivery route assignment, the system will generate optimized sequences that:</p> <ul> <li>Minimize Total Distance: Optimal stop order across multiple deliveries</li> <li>Respect All Time Windows: Sequential delivery windows for all stops</li> <li>Include Service Time: Loading/unloading duration at each customer</li> <li>Plan Infrastructure Stops: Strategic charging/refueling during route</li> <li>Optimize Payload: Consider cargo pickup and delivery order</li> </ul>"},{"location":"planning/#energy-planning","title":"Energy Planning","text":"<p>BEV Multi-Stop Route Planning:</p> <ul> <li>Calculate cumulative energy consumption across all delivery stops</li> <li>Identify optimal charging stops during multi-delivery routes</li> <li>Schedule charging sessions to minimize route time</li> <li>Maintain minimum SOC buffer throughout extended routes</li> </ul> <p>HFCEV Multi-Stop Route Planning:</p> <ul> <li>Calculate hydrogen consumption for complete multi-delivery sequence</li> <li>Plan refueling stops strategically during longer routes</li> <li>Consider station availability and queue times with other operators</li> </ul>"},{"location":"planning/#driver-scheduling","title":"Driver Scheduling","text":"<p>The system will ensure compliance with UK/EU regulations:</p> <ul> <li>Maximum 4.5 hours continuous driving</li> <li>45-minute break requirement</li> <li>9-hour daily driving limit</li> <li>11-hour daily rest period</li> </ul>"},{"location":"planning/#optimization-characteristics","title":"Optimization Characteristics","text":""},{"location":"planning/#algorithm-performance","title":"Algorithm Performance","text":"<ul> <li>Efficiency: Vectorized operations for large-scale problems</li> <li>Quality: Balanced trade-off between optimality and execution time</li> </ul>"},{"location":"planning/#constraint-types","title":"Constraint Types","text":"<ul> <li>Capacity Constraints: Vehicle weight/volume limits</li> <li>Temporal Constraints: Time windows, driver hours regulations</li> <li>Energy Constraints: Range limitations, charging requirements</li> <li>Operational Constraints: Infrastructure availability, customer preferences</li> </ul> <p>Navigation: - \u2190 System Components | Operations &amp; Monitoring \u2192</p>"},{"location":"reference/","title":"Technical Reference","text":"<p>Detailed specifications, configuration parameters, and troubleshooting resources that will be provided.</p>"},{"location":"reference/#appendices","title":"Appendices","text":""},{"location":"reference/#a-uk-regulatory-framework","title":"A. UK Regulatory Framework","text":"<ul> <li>Driver hours regulations (EU 561/2006)</li> <li>Vehicle weight limits (44 tonnes)</li> <li>Working time directive</li> <li>Environmental zones</li> </ul>"},{"location":"reference/#b-vehicle-technology-specifications","title":"B. Vehicle Technology Specifications","text":"<ul> <li>Battery technologies (LFP vs NMC)</li> <li>Charging standards (CCS, MCS)</li> <li>Hydrogen production methods</li> <li>Maintenance requirements</li> </ul>"},{"location":"reference/#c-optimization-algorithms","title":"C. Optimization Algorithms","text":"<ul> <li>Vehicle routing problem (VRP)</li> <li>Clustering techniques</li> <li>Constraint programming</li> <li>Heuristic methods</li> </ul>"},{"location":"reference/#d-data-requirements","title":"D. Data Requirements","text":"<ul> <li>Demand patterns</li> <li>Vehicle specifications</li> <li>Infrastructure locations</li> <li>Road network data</li> </ul>"},{"location":"reference/#configuration-reference","title":"Configuration Reference","text":""},{"location":"reference/#model-parameters","title":"Model Parameters","text":"<p>Fleet Configuration:</p> <ul> <li>Vehicle types and specifications</li> <li>Fleet composition ratios</li> <li>Maintenance schedules</li> <li>Driver availability</li> </ul> <p>Demand Configuration:</p> <ul> <li>Demand generation patterns</li> <li>Time window constraints</li> <li>Service level requirements</li> <li>Geographic distribution</li> </ul> <p>Infrastructure Configuration:</p> <ul> <li>Charging station locations and capabilities</li> <li>Hydrogen refueling stations</li> <li>Depot facilities</li> <li>Grid connection specifications</li> </ul> <p>Operational Configuration:</p> <ul> <li>Driver hours regulations</li> <li>Environmental restrictions</li> <li>Cost parameters</li> <li>Performance targets</li> </ul>"},{"location":"reference/#output-specifications","title":"Output Specifications","text":"<p>Performance Metrics:</p> <ul> <li>Delivery success rates</li> <li>Energy consumption</li> <li>Cost breakdowns</li> <li>Environmental impact</li> </ul> <p>Operational Data:</p> <ul> <li>Vehicle trajectories</li> <li>Charging/refueling events</li> <li>State transitions</li> <li>Event logs</li> </ul> <p>Analysis Results:</p> <ul> <li>Optimization outcomes</li> <li>Constraint violations</li> <li>Sensitivity analysis</li> <li>Scenario comparisons</li> </ul>"},{"location":"reference/#api-documentation","title":"API Documentation","text":""},{"location":"reference/#core-classes","title":"Core Classes","text":"<p>World: Main simulation container</p> <ul> <li>Will manage all controllers and features</li> <li>Will coordinate simulation execution</li> <li>Will provide global clock and random number generation</li> </ul> <p>FleetController: Vehicle fleet management</p> <ul> <li>Will handle vehicle assignment and routing</li> <li>Will manage state transitions</li> <li>Will monitor performance</li> </ul> <p>DemandController: Customer demand handling</p> <ul> <li>Will manage demand lifecycle</li> <li>Will track service levels</li> <li>Will handle customer interaction</li> </ul> <p>InfrastructureController: Infrastructure modeling</p> <ul> <li>Will model charging/refueling resources</li> <li>Will manage capacity</li> <li>Will handle queues</li> </ul>"},{"location":"reference/#key-methods","title":"Key Methods","text":"<p>Initialization:</p> <ul> <li><code>initialize_simulation()</code>: Set up all components</li> <li><code>load_configuration()</code>: Import model parameters</li> <li><code>validate_inputs()</code>: Check data consistency</li> </ul> <p>Execution:</p> <ul> <li><code>step_simulation()</code>: Advance one time step</li> <li><code>process_events()</code>: Handle dynamic events</li> <li><code>update_metrics()</code>: Calculate performance indicators</li> </ul> <p>Output:</p> <ul> <li><code>generate_reports()</code>: Create analysis outputs</li> <li><code>export_data()</code>: Save simulation results</li> <li><code>visualize_results()</code>: Generate charts and maps</li> </ul>"},{"location":"reference/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"reference/#common-issues","title":"Common Issues","text":"<p>Performance Problems:</p> <ul> <li>Large fleet sizes causing memory issues</li> <li>Optimization algorithms taking too long</li> <li>Inefficient data structures</li> </ul> <p>Data Quality Issues:</p> <ul> <li>Inconsistent demand patterns</li> <li>Missing infrastructure data</li> <li>Invalid vehicle specifications</li> </ul> <p>Validation Failures:</p> <ul> <li>Constraint violations in assignments</li> <li>Infeasible routes</li> <li>Regulatory compliance issues</li> </ul>"},{"location":"reference/#debugging-strategies","title":"Debugging Strategies","text":"<p>Logging:</p> <ul> <li>Enable detailed logging for problem diagnosis</li> <li>Use structured logging with timestamps</li> <li>Separate logs by component type</li> </ul> <p>Profiling:</p> <ul> <li>Identify computational bottlenecks</li> <li>Monitor memory usage patterns</li> <li>Track algorithm convergence</li> </ul> <p>Validation:</p> <ul> <li>Implement data quality checks</li> <li>Verify constraint satisfaction</li> <li>Compare against analytical benchmarks</li> </ul>"},{"location":"reference/#planned-enhancements","title":"Planned Enhancements","text":"<ul> <li>Multi-operator scenarios</li> <li>Advanced ML integration</li> <li>Real-time optimization</li> <li>Enhanced visualization</li> </ul>"},{"location":"use_cases/","title":"Use Cases and Applications","text":"<p>kairos-zen will support a wide range of analytical and planning use cases for freight operations, policy analysis, and technology evaluation.</p>"},{"location":"use_cases/#multi-operator-fleet-planning","title":"Multi-Operator Fleet Planning","text":"<ul> <li>Optimal fleet size determination per operator</li> <li>Vehicle type selection strategies by operator</li> <li>Replacement scheduling across multiple fleets</li> <li>Shared infrastructure investment analysis</li> </ul>"},{"location":"use_cases/#multi-delivery-operational-planning","title":"Multi-Delivery Operational Planning","text":"<ul> <li>Multi-stop route optimization strategies</li> <li>Consolidation opportunity identification</li> <li>Charging schedule development for extended routes</li> <li>Depot location analysis considering competitive dynamics</li> </ul>"},{"location":"use_cases/#market-policy-analysis","title":"Market Policy Analysis","text":"<ul> <li>Multi-operator incentive impact assessment</li> <li>Shared infrastructure investment planning</li> <li>Market-wide emission reduction pathways</li> <li>Regulation feasibility across competitive operators</li> </ul>"},{"location":"use_cases/#technology-evaluation","title":"Technology Evaluation","text":"<ul> <li>Comparative vehicle studies across operators</li> <li>Shared charging technology assessment</li> <li>Multi-delivery energy management strategies</li> <li>Competitive cost-benefit analysis</li> </ul>"},{"location":"use_cases/#strategic-business-analysis","title":"Strategic Business Analysis","text":""},{"location":"use_cases/#market-entry-studies","title":"Market Entry Studies","text":"<ul> <li>New operator viability analysis</li> <li>Competitive positioning assessment</li> <li>Service area optimization</li> <li>Customer acquisition strategies</li> </ul>"},{"location":"use_cases/#infrastructure-planning","title":"Infrastructure Planning","text":"<ul> <li>Charging network expansion planning</li> <li>Hydrogen refueling station placement</li> <li>Depot consolidation opportunities</li> <li>Grid capacity requirement analysis</li> </ul>"},{"location":"use_cases/#regulatory-impact-assessment","title":"Regulatory Impact Assessment","text":"<ul> <li>Zero emission zone compliance</li> <li>Driver hours regulation effects</li> <li>Weight limit policy impacts</li> <li>Incentive program effectiveness</li> </ul>"},{"location":"use_cases/#research-applications","title":"Research Applications","text":""},{"location":"use_cases/#industry-studies","title":"Industry Studies","text":"<ul> <li>Fleet electrification pathways</li> <li>Total cost of ownership analysis</li> <li>Infrastructure sharing models</li> <li>Operational efficiency benchmarking</li> </ul>"},{"location":"use_cases/#policy-research","title":"Policy Research","text":"<ul> <li>Carbon reduction scenario modeling</li> <li>Infrastructure investment prioritization</li> <li>Regulatory framework design</li> <li>Market mechanism evaluation</li> </ul> <p>Navigation: - \u2190 Technical Reference | Data Requirements \u2192</p>"},{"location":"code_samples/fleet_controller/","title":"Fleet Controller Implementation","text":""},{"location":"code_samples/fleet_controller/#controller-settings","title":"Controller Settings","text":"<pre><code>from kairoslib.primitives.controller_settings import ControllerSettings, settings_dataclass\nfrom dataclasses import field\nfrom typing import Dict, List\n\n@settings_dataclass\nclass FleetControllerSettings(ControllerSettings):\n    \"\"\"Configuration for fleet operations.\"\"\"\n\n    # Fleet composition\n    fleet_composition: Dict[str, int] = field(default_factory=lambda: {\n        'VOLVO_FH_BEV_540': 10,        # 10 Volvo electric trucks\n        'DAIMLER_EACTROS_600': 5,      # 5 Daimler electric trucks\n        'TOYOTA_HINO_HFCEV': 3,        # 3 Toyota hydrogen trucks\n        'VOLVO_FH_DIESEL': 15,         # 15 Volvo diesel trucks\n    })\n\n    # Operational parameters\n    depot_location: Tuple[float, float] = (51.5074, -0.1278)  # London\n    service_area_radius_km: float = 150.0\n    max_daily_demands: int = 200\n\n    # Strategy parameters\n    charging_strategy: str = \"return_to_depot\"  # or \"opportunistic\"\n    route_optimization_focus: str = \"cost\"  # or \"emissions\", \"time\"\n    min_battery_soc_pct: float = 20.0  # Minimum SOC before charging\n</code></pre>"},{"location":"code_samples/fleet_controller/#fleet-controller-class","title":"Fleet Controller Class","text":"<pre><code>from kairoslib.primitives.controller import Controller\nfrom kairoslib.primitives.agent_view_pool import AgentViewPoolMixin\n\nclass FleetController(Controller, AgentViewPoolMixin[VehicleView]):\n    \"\"\"\n    Manages all vehicles for a freight operator.\n    Handles vehicle creation, assignment, and monitoring.\n    \"\"\"\n\n    def __init__(self, settings: FleetControllerSettings = None):\n        Controller.__init__(self, name=\"FleetController\")\n        self.settings = settings or FleetControllerSettings()\n\n        # Vehicle management\n        self.agent_group = VehicleAgentGroup(self)\n        self.vehicle_catalog = create_uk_vehicle_catalog()\n\n        # Optimization components\n        self.assignment_optimizer = VehicleAssignmentOptimizer()\n        self.route_planner = RouteOptimizer()\n\n        # Operational state\n        self.active_assignments: Dict[str, List[str]] = {}\n        self.planned_routes: Dict[str, PlannedRoute] = {}\n\n    def initialize_controller(self):\n        \"\"\"Initialize fleet based on configuration.\"\"\"\n\n        # Initialize view pool\n        total_vehicles = sum(self.settings.fleet_composition.values())\n        self.initialize_view_pool(\n            agent_group=self.agent_group,\n            view_class=VehicleView,\n            initial_size=total_vehicles\n        )\n\n        # Create vehicles from composition\n        self._create_fleet()\n\n        # Register features\n        self._register_features()\n\n        # Connect to other controllers\n        self.demand_controller = self.world.get_controller_by_class(DemandController)\n        self.infrastructure_controller = self.world.get_controller_by_class(InfrastructureController)\n\n        self.logger.info(f\"Initialized fleet with {total_vehicles} vehicles\")\n</code></pre>"},{"location":"code_samples/fleet_controller/#fleet-creation","title":"Fleet Creation","text":"<pre><code>def _create_fleet(self):\n    \"\"\"Create vehicles based on fleet composition settings.\"\"\"\n\n    depot_x, depot_y = self.settings.depot_location\n\n    for spec_id, count in self.settings.fleet_composition.items():\n        spec = self.vehicle_catalog.get_spec(spec_id)\n\n        if not spec:\n            self.logger.warning(f\"Unknown vehicle spec: {spec_id}\")\n            continue\n\n        for i in range(count):\n            vehicle_id = f\"VEH_{self.agent_group.agents_created:04d}\"\n\n            # Determine initial values based on propulsion type\n            vehicle_data = {\n                'vehicle_id': vehicle_id,\n                'spec_id': spec_id,\n                'manufacturer': spec.manufacturer,\n                'model': spec.model,\n                'propulsion_type': spec.primary_propulsion.propulsion_type.value,\n                'location_x': depot_x,\n                'location_y': depot_y,\n                'depot_id': 'DEPOT_001',\n                'state': VehicleState.IDLE\n            }\n\n            # Set propulsion-specific properties\n            if spec.primary_propulsion.propulsion_type == PropulsionType.BEV:\n                vehicle_data.update({\n                    'battery_capacity_kwh': spec.primary_propulsion.battery_capacity_kwh,\n                    'current_soc_pct': 90.0,  # Start at 90% charge\n                })\n            elif spec.primary_propulsion.propulsion_type == PropulsionType.HFCEV:\n                vehicle_data.update({\n                    'h2_tank_capacity_kg': spec.primary_propulsion.h2_tank_capacity_kg,\n                    'current_h2_level_kg': spec.primary_propulsion.h2_tank_capacity_kg * 0.9,\n                })\n            elif spec.primary_propulsion.propulsion_type == PropulsionType.DIESEL:\n                vehicle_data.update({\n                    'fuel_tank_capacity_l': spec.primary_propulsion.fuel_tank_capacity_l,\n                    'current_fuel_level_l': spec.primary_propulsion.fuel_tank_capacity_l * 0.9,\n                })\n\n            vehicle = self.agent_group.create_agent(**vehicle_data)\n\n            self.logger.info(\n                f\"Created {vehicle.propulsion_type} vehicle {vehicle_id} \"\n                f\"({spec.manufacturer} {spec.model})\",\n                tag=\"fleet_creation\",\n                object_id=vehicle_id\n            )\n</code></pre>"},{"location":"code_samples/fleet_controller/#feature-registration","title":"Feature Registration","text":"<pre><code>def _register_features(self):\n    \"\"\"Register propulsion and operational features.\"\"\"\n\n    # Propulsion features\n    self.register_feature(BEVPropulsionFeature())\n    self.register_feature(HFCEVPropulsionFeature())\n    self.register_feature(DieselPropulsionFeature())\n\n    # Operational features\n    self.register_feature(EnergyManagementFeature())\n    self.register_feature(RouteExecutionFeature())\n    self.register_feature(MaintenanceTrackingFeature())\n\n    # Monitoring features\n    self.register_feature(PerformanceMonitoringFeature())\n    self.register_feature(CostTrackingFeature())\n</code></pre>"},{"location":"code_samples/fleet_controller/#main-step-function","title":"Main Step Function","text":"<pre><code>def step_controller(self):\n    \"\"\"Main controller step - called each simulation tick.\"\"\"\n\n    current_time = self.world.clock.sim_time_now\n\n    # Phase 1: Check for new demands\n    new_demands = self.demand_controller.get_unassigned_demands()\n    if new_demands:\n        self._process_new_demands(new_demands)\n\n    # Phase 2: Update vehicle states\n    self._update_vehicle_states(current_time)\n\n    # Phase 3: Handle charging/refueling\n    self._manage_energy_replenishment(current_time)\n\n    # Phase 4: Monitor performance\n    self._update_performance_metrics()\n\ndef _process_new_demands(self, demands: List[DemandView]):\n    \"\"\"Process new demands and assign to vehicles.\"\"\"\n\n    # Get available vehicles\n    available_vehicles = self.agent_group.get_available_vehicles()\n\n    if not available_vehicles:\n        self.logger.warning(\n            f\"No vehicles available for {len(demands)} demands\",\n            tag=\"assignment\"\n        )\n        return\n\n    # Run assignment optimization\n    result = self.assignment_optimizer.assign_demands_to_vehicles(\n        vehicles=available_vehicles,\n        demands=demands,\n        infrastructure=self.infrastructure_controller.get_infrastructure()\n    )\n\n    # Process assignments\n    for vehicle_id, demand_ids in result.vehicle_assignments.items():\n        self._assign_demands_to_vehicle(vehicle_id, demand_ids)\n\n    if result.unassigned_demands:\n        self.logger.warning(\n            f\"Could not assign {len(result.unassigned_demands)} demands\",\n            tag=\"assignment\"\n        )\n</code></pre>"},{"location":"code_samples/fleet_controller/#vehicle-state-management","title":"Vehicle State Management","text":"<pre><code>def _update_vehicle_states(self, current_time):\n    \"\"\"Update all vehicle states based on current activities.\"\"\"\n\n    # Get vehicles by state for efficient processing\n    for state in VehicleState:\n        mask = self.agent_group.state == state.value\n        if not mask.any():\n            continue\n\n        if state == VehicleState.EN_ROUTE:\n            self._update_vehicles_en_route(mask, current_time)\n        elif state == VehicleState.DELIVERING:\n            self._update_vehicles_delivering(mask, current_time)\n        elif state == VehicleState.CHARGING:\n            self._update_vehicles_charging(mask, current_time)\n        elif state == VehicleState.LOADING:\n            self._update_vehicles_loading(mask, current_time)\n\ndef _update_vehicles_en_route(self, mask, current_time):\n    \"\"\"Update vehicles that are traveling.\"\"\"\n\n    # Update positions\n    dt = self.world.clock.dt\n    self.agent_group.update_locations(dt)\n\n    # Update energy consumption\n    self._update_energy_consumption(mask, dt)\n\n    # Check for arrival at destination\n    for idx in np.where(mask)[0]:\n        vehicle = VehicleView(self.agent_group, idx)\n\n        if self._has_arrived_at_destination(vehicle):\n            self._handle_arrival(vehicle, current_time)\n\ndef _update_energy_consumption(self, mask, dt):\n    \"\"\"Update energy consumption for moving vehicles.\"\"\"\n\n    # BEV consumption\n    bev_mask = mask &amp; (self.agent_group.propulsion_type == \"BEV\")\n    if bev_mask.any():\n        # Calculate energy consumed\n        distance_km = self.agent_group.speed_kmh[bev_mask] * (dt / 3600)\n        energy_consumed = distance_km * 1.2  # Simplified consumption\n\n        # Update SOC\n        battery_capacity = self.agent_group.battery_capacity_kwh[bev_mask]\n        soc_decrease = (energy_consumed / battery_capacity) * 100\n        self.agent_group.current_soc_pct[bev_mask] -= soc_decrease\n\n        # Track total energy\n        self.agent_group.energy_consumed_kwh_equiv[bev_mask] += energy_consumed\n\n    # HFCEV consumption\n    hfcev_mask = mask &amp; (self.agent_group.propulsion_type == \"HFCEV\")\n    if hfcev_mask.any():\n        distance_km = self.agent_group.speed_kmh[hfcev_mask] * (dt / 3600)\n        h2_consumed = distance_km * 0.08  # kg/km\n        self.agent_group.current_h2_level_kg[hfcev_mask] -= h2_consumed\n\n    # Diesel consumption\n    diesel_mask = mask &amp; (self.agent_group.propulsion_type == \"DIESEL\")\n    if diesel_mask.any():\n        distance_km = self.agent_group.speed_kmh[diesel_mask] * (dt / 3600)\n        fuel_consumed = distance_km * 0.35  # L/km\n        self.agent_group.current_fuel_level_l[diesel_mask] -= fuel_consumed\n</code></pre>"},{"location":"code_samples/fleet_controller/#energy-management","title":"Energy Management","text":"<pre><code>def _manage_energy_replenishment(self, current_time):\n    \"\"\"Manage charging and refueling operations.\"\"\"\n\n    # Check BEVs for low battery\n    bev_mask = self.agent_group.propulsion_type == \"BEV\"\n    low_soc_mask = (\n        bev_mask &amp;\n        (self.agent_group.current_soc_pct &lt; self.settings.min_battery_soc_pct) &amp;\n        (self.agent_group.state == VehicleState.IDLE.value)\n    )\n\n    if low_soc_mask.any():\n        for idx in np.where(low_soc_mask)[0]:\n            vehicle = VehicleView(self.agent_group, idx)\n            self._initiate_charging(vehicle)\n\n    # Check HFCEVs for low hydrogen\n    hfcev_mask = self.agent_group.propulsion_type == \"HFCEV\"\n    low_h2_mask = (\n        hfcev_mask &amp;\n        (self.agent_group.current_h2_level_kg &lt; 5.0) &amp;\n        (self.agent_group.state == VehicleState.IDLE.value)\n    )\n\n    if low_h2_mask.any():\n        for idx in np.where(low_h2_mask)[0]:\n            vehicle = VehicleView(self.agent_group, idx)\n            self._initiate_refueling(vehicle)\n\ndef _initiate_charging(self, vehicle: VehicleView):\n    \"\"\"Start charging process for a BEV.\"\"\"\n\n    # Find available charging station\n    station = self.infrastructure_controller.find_available_charger(\n        location=(vehicle.location_x, vehicle.location_y),\n        power_required=350  # kW\n    )\n\n    if station:\n        vehicle.state = VehicleState.CHARGING.value\n        vehicle.charging_power_kw = min(350, station.max_power_kw)\n\n        self.logger.info(\n            f\"Vehicle {vehicle.vehicle_id} started charging at {station.station_id}\",\n            tag=\"charging\",\n            object_id=vehicle.vehicle_id\n        )\n    else:\n        self.logger.warning(\n            f\"No charging station available for {vehicle.vehicle_id}\",\n            tag=\"charging\",\n            object_id=vehicle.vehicle_id\n        )\n</code></pre>"},{"location":"code_samples/fleet_controller/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>def _update_performance_metrics(self):\n    \"\"\"Calculate and update fleet performance metrics.\"\"\"\n\n    # Fleet utilization\n    total_vehicles = self.agent_group.active_agents\n    idle_vehicles = np.sum(self.agent_group.state == VehicleState.IDLE.value)\n    utilization = 1 - (idle_vehicles / total_vehicles) if total_vehicles &gt; 0 else 0\n\n    # Energy efficiency by type\n    for propulsion_type in [\"BEV\", \"HFCEV\", \"DIESEL\"]:\n        mask = self.agent_group.propulsion_type == propulsion_type\n        if mask.any():\n            total_energy = np.sum(self.agent_group.energy_consumed_kwh_equiv[mask])\n            total_distance = np.sum(self.agent_group.odometer_km[mask])\n\n            if total_distance &gt; 0:\n                efficiency = total_energy / total_distance\n                self.logger.info(\n                    f\"{propulsion_type} fleet efficiency: {efficiency:.2f} kWh/km\",\n                    tag=\"efficiency\"\n                )\n\n    # Service metrics\n    completed_trips = np.sum(self.agent_group.trips_completed)\n\n    self.logger.info(\n        f\"Fleet utilization: {utilization:.1%}, Completed trips: {completed_trips}\",\n        tag=\"performance\"\n    )\n\ndef get_fleet_summary(self) -&gt; Dict:\n    \"\"\"Get summary statistics for the fleet.\"\"\"\n\n    summary = {\n        'total_vehicles': self.agent_group.active_agents,\n        'by_type': {},\n        'by_state': {},\n        'total_distance_km': np.sum(self.agent_group.odometer_km),\n        'total_energy_kwh': np.sum(self.agent_group.energy_consumed_kwh_equiv),\n        'total_trips': np.sum(self.agent_group.trips_completed)\n    }\n\n    # Count by propulsion type\n    for ptype in [\"BEV\", \"HFCEV\", \"DIESEL\"]:\n        count = np.sum(self.agent_group.propulsion_type == ptype)\n        summary['by_type'][ptype] = count\n\n    # Count by state\n    for state in VehicleState:\n        count = np.sum(self.agent_group.state == state.value)\n        summary['by_state'][state.name] = count\n\n    return summary\n</code></pre>"},{"location":"code_samples/future_resilience_concept/","title":"Future Resilience Analysis Concepts","text":""},{"location":"code_samples/future_resilience_concept/#overview","title":"Overview","text":"<p>This document outlines conceptual approaches for resilience analysis that could be implemented as general Kairos framework features in the future.</p>"},{"location":"code_samples/future_resilience_concept/#proposed-kairos-resilience-module","title":"Proposed Kairos Resilience Module","text":""},{"location":"code_samples/future_resilience_concept/#core-concepts","title":"Core Concepts","text":"<pre><code># Conceptual interface for a Kairos resilience module\nclass KairosResilienceModule:\n    \"\"\"\n    Framework-level resilience testing capability.\n    Could be applied to any Kairos simulation.\n    \"\"\"\n\n    def define_baseline(self, simulation):\n        \"\"\"Capture baseline performance metrics.\"\"\"\n        pass\n\n    def inject_disruption(self, disruption_type, parameters):\n        \"\"\"Inject standardized disruptions into simulation.\"\"\"\n        pass\n\n    def measure_degradation(self):\n        \"\"\"Compare current performance to baseline.\"\"\"\n        pass\n\n    def analyze_recovery(self):\n        \"\"\"Track recovery patterns and time to normal.\"\"\"\n        pass\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#disruption-types-generic","title":"Disruption Types (Generic)","text":"<pre><code>class DisruptionType(Enum):\n    \"\"\"\n    Generic disruption types applicable to any simulation.\n    \"\"\"\n    AGENT_FAILURE = \"Agent becomes unavailable\"\n    RESOURCE_SHORTAGE = \"Resource capacity reduced\"\n    DEMAND_SURGE = \"Increased demand for services\"\n    NETWORK_DISRUPTION = \"Connection/path failures\"\n    EXTERNAL_SHOCK = \"External event affecting system\"\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#application-to-zenfreight","title":"Application to ZENFreight","text":""},{"location":"code_samples/future_resilience_concept/#freight-specific-disruptions","title":"Freight-Specific Disruptions","text":"<pre><code># How generic disruptions map to freight operations:\nDISRUPTION_MAPPING = {\n    'AGENT_FAILURE': ['vehicle_breakdown', 'driver_absence'],\n    'RESOURCE_SHORTAGE': ['charging_station_offline', 'fuel_shortage'],\n    'DEMAND_SURGE': ['seasonal_peak', 'emergency_deliveries'],\n    'NETWORK_DISRUPTION': ['road_closure', 'depot_inaccessible'],\n    'EXTERNAL_SHOCK': ['weather_event', 'regulatory_change']\n}\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#resilience-metrics-framework","title":"Resilience Metrics Framework","text":"<pre><code>class ResilienceMetrics:\n    \"\"\"\n    Standard metrics that could be calculated by Kairos.\n    \"\"\"\n\n    # Performance retention\n    service_level_retention: float  # Current / Baseline\n    capacity_retention: float\n    efficiency_retention: float\n\n    # Recovery characteristics\n    time_to_recovery: float  # Time to return to 95% baseline\n    recovery_rate: float  # Performance improvement per hour\n\n    # Impact assessment\n    total_impact_cost: float\n    affected_agents: int\n    cascade_depth: int  # How many secondary failures\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#strategy-comparison-framework","title":"Strategy Comparison Framework","text":""},{"location":"code_samples/future_resilience_concept/#generic-comparison-engine","title":"Generic Comparison Engine","text":"<pre><code>class KairosComparisonEngine:\n    \"\"\"\n    Framework feature for comparing different configurations.\n    \"\"\"\n\n    def define_strategy(self, name, configuration):\n        \"\"\"Define a configuration to test.\"\"\"\n        pass\n\n    def run_scenarios(self, strategies, scenarios):\n        \"\"\"Run multiple strategies through scenarios.\"\"\"\n        pass\n\n    def generate_comparison_matrix(self):\n        \"\"\"Create standardized comparison outputs.\"\"\"\n        pass\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#application-to-fleet-strategies","title":"Application to Fleet Strategies","text":"<pre><code># Example: How ZENFreight would use the comparison engine\n\nstrategies = [\n    {\n        'name': 'Baseline Diesel',\n        'config': {'fleet_composition': {'diesel': 50}}\n    },\n    {\n        'name': '50% Electric',\n        'config': {'fleet_composition': {'bev': 25, 'diesel': 25}}\n    },\n    {\n        'name': 'Full Electric',\n        'config': {'fleet_composition': {'bev': 50}}\n    }\n]\n\ncomparison_engine.run_scenarios(strategies, standard_scenarios)\nresults = comparison_engine.generate_comparison_matrix()\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#cost-tracking-framework","title":"Cost Tracking Framework","text":""},{"location":"code_samples/future_resilience_concept/#universal-cost-tracker","title":"Universal Cost Tracker","text":"<pre><code>class KairosCostTracker:\n    \"\"\"\n    Generic cost tracking that could work for any simulation.\n    \"\"\"\n\n    cost_categories = {\n        'capital': \"One-time or amortized acquisition costs\",\n        'operational': \"Ongoing operational expenses\",\n        'penalty': \"Costs from failures or violations\",\n        'opportunity': \"Lost revenue from unavailability\"\n    }\n\n    def register_cost(self, agent_id, category, amount, description):\n        \"\"\"Track any cost in standardized way.\"\"\"\n        pass\n\n    def calculate_tco(self, agent_id, time_horizon):\n        \"\"\"Calculate total cost of ownership.\"\"\"\n        pass\n</code></pre>"},{"location":"code_samples/future_resilience_concept/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"code_samples/future_resilience_concept/#phase-1-core-framework-features","title":"Phase 1: Core Framework Features","text":"<ul> <li>Basic disruption injection</li> <li>Metric collection infrastructure</li> <li>Simple comparison tools</li> </ul>"},{"location":"code_samples/future_resilience_concept/#phase-2-advanced-analytics","title":"Phase 2: Advanced Analytics","text":"<ul> <li>Machine learning integration</li> <li>Predictive failure modeling</li> <li>Optimization under uncertainty</li> </ul>"},{"location":"code_samples/future_resilience_concept/#phase-3-visualization-and-reporting","title":"Phase 3: Visualization and Reporting","text":"<ul> <li>Interactive dashboards</li> <li>Automated insights</li> <li>Policy recommendations</li> </ul>"},{"location":"code_samples/future_resilience_concept/#benefits-of-framework-level-implementation","title":"Benefits of Framework-Level Implementation","text":"<ol> <li>Reusability: All Kairos simulations benefit</li> <li>Standardization: Consistent metrics across domains</li> <li>Validation: Tested across multiple use cases</li> <li>Maintenance: Single codebase to maintain</li> <li>Integration: Works with existing Kairos features</li> </ol>"},{"location":"code_samples/future_resilience_concept/#required-kairos-enhancements","title":"Required Kairos Enhancements","text":"<p>To support resilience analysis, Kairos would need:</p> <ol> <li>Event System: Standardized event injection</li> <li>Metric Registry: Automatic metric collection</li> <li>Scenario Manager: Scenario definition and execution</li> <li>Comparison Tools: Multi-run comparison utilities</li> <li>Reporting Framework: Standardized output generation</li> </ol>"},{"location":"code_samples/future_resilience_concept/#next-steps","title":"Next Steps","text":"<ol> <li>Define requirements with Kairos team</li> <li>Create proof-of-concept with ZENFreight</li> <li>Generalize to framework level</li> <li>Test with other simulations</li> <li>Release as Kairos feature</li> </ol> <p>Note: This is a conceptual design for future implementation. The actual implementation would be part of the Kairos framework development roadmap.</p>"},{"location":"code_samples/resilience_analysis/","title":"Resilience Analysis Implementation","text":""},{"location":"code_samples/resilience_analysis/#disruption-event-system","title":"Disruption Event System","text":"<pre><code>from enum import Enum, auto\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional, Callable\nimport numpy as np\n\nclass DisruptionType(Enum):\n    \"\"\"Types of disruptions that can occur.\"\"\"\n    VEHICLE_BREAKDOWN = auto()\n    CHARGING_STATION_FAILURE = auto()\n    ROAD_CLOSURE = auto()\n    DEMAND_SPIKE = auto()\n    DRIVER_UNAVAILABLE = auto()\n    POWER_OUTAGE = auto()\n    WEATHER_SEVERE = auto()\n\n@dataclass\nclass DisruptionEvent:\n    \"\"\"Represents a disruption in the network.\"\"\"\n    event_id: str\n    disruption_type: DisruptionType\n    start_time: float\n    duration_min: float\n    severity: float  # 0.0 to 1.0\n    affected_entities: List[str]  # IDs of affected vehicles/stations/roads\n    location: Optional[Tuple[float, float]] = None\n    radius_km: Optional[float] = None  # For area effects\n</code></pre>"},{"location":"code_samples/resilience_analysis/#resilience-manager","title":"Resilience Manager","text":"<pre><code>class ResilienceManager:\n    \"\"\"\n    Manages disruption events and measures system resilience.\n    \"\"\"\n\n    def __init__(self):\n        self.active_disruptions: List[DisruptionEvent] = []\n        self.disruption_history: List[DisruptionEvent] = []\n        self.baseline_metrics: Dict = {}\n        self.stress_metrics: Dict = {}\n\n    def inject_disruption(self, disruption: DisruptionEvent):\n        \"\"\"Inject a disruption into the simulation.\"\"\"\n        self.active_disruptions.append(disruption)\n\n        # Apply disruption effects\n        if disruption.disruption_type == DisruptionType.CHARGING_STATION_FAILURE:\n            self._apply_charging_failure(disruption)\n        elif disruption.disruption_type == DisruptionType.VEHICLE_BREAKDOWN:\n            self._apply_vehicle_breakdown(disruption)\n        elif disruption.disruption_type == DisruptionType.DEMAND_SPIKE:\n            self._apply_demand_spike(disruption)\n\n        self.logger.warning(\n            f\"Disruption injected: {disruption.disruption_type.name} \"\n            f\"affecting {len(disruption.affected_entities)} entities\",\n            tag=\"resilience\"\n        )\n\n    def _apply_charging_failure(self, disruption: DisruptionEvent):\n        \"\"\"Apply charging station failure effects.\"\"\"\n        for station_id in disruption.affected_entities:\n            station = self.infrastructure_controller.get_station(station_id)\n            if station:\n                # Reduce available chargers based on severity\n                original_chargers = station.num_chargers\n                failed_chargers = int(original_chargers * disruption.severity)\n                station.chargers_available = max(0, original_chargers - failed_chargers)\n                station.state = ChargingStationState.DEGRADED\n\n    def _apply_vehicle_breakdown(self, disruption: DisruptionEvent):\n        \"\"\"Apply vehicle breakdown effects.\"\"\"\n        for vehicle_id in disruption.affected_entities:\n            vehicle = self.fleet_controller.get_vehicle(vehicle_id)\n            if vehicle:\n                vehicle.state = VehicleState.BROKEN_DOWN\n                # Trigger reassignment of vehicle's demands\n                self._reassign_vehicle_demands(vehicle)\n\n    def measure_resilience(self) -&gt; Dict:\n        \"\"\"\n        Calculate resilience metrics comparing stressed vs baseline performance.\n        \"\"\"\n        current_metrics = self._calculate_current_metrics()\n\n        resilience_scores = {\n            'service_level_retention': (\n                current_metrics['on_time_rate'] /\n                self.baseline_metrics.get('on_time_rate', 1.0)\n            ),\n            'capacity_retention': (\n                current_metrics['completed_deliveries'] /\n                self.baseline_metrics.get('completed_deliveries', 1)\n            ),\n            'cost_increase_factor': (\n                current_metrics['total_cost'] /\n                self.baseline_metrics.get('total_cost', 1)\n            ),\n            'recovery_time_estimate': self._estimate_recovery_time(),\n            'alternative_routes_used': current_metrics['reroute_count'],\n            'cascade_failures': self._count_cascade_failures()\n        }\n\n        return resilience_scores\n</code></pre>"},{"location":"code_samples/resilience_analysis/#fleet-strategy-comparator","title":"Fleet Strategy Comparator","text":"<pre><code>@dataclass\nclass FleetStrategy:\n    \"\"\"Defines a fleet composition and operational strategy.\"\"\"\n    strategy_id: str\n    name: str\n    fleet_composition: Dict[str, int]  # vehicle_spec_id -&gt; count\n    charging_strategy: str  # \"depot_only\", \"opportunistic\", \"scheduled\"\n    operational_hours: Tuple[int, int]  # (start_hour, end_hour)\n    infrastructure_level: str  # \"minimal\", \"moderate\", \"comprehensive\"\n\nclass FleetStrategyComparator:\n    \"\"\"\n    Compares different fleet strategies across multiple scenarios.\n    \"\"\"\n\n    def __init__(self):\n        self.strategies: List[FleetStrategy] = []\n        self.scenario_results: Dict[str, Dict] = {}\n\n    def add_strategy(self, strategy: FleetStrategy):\n        \"\"\"Add a fleet strategy for comparison.\"\"\"\n        self.strategies.append(strategy)\n\n    def run_comparison(\n        self,\n        demand_scenarios: List[DemandScenario],\n        disruption_scenarios: List[DisruptionScenario],\n        simulation_days: int = 30\n    ) -&gt; Dict:\n        \"\"\"\n        Run all strategies through all scenarios and compare.\n        \"\"\"\n        results = {}\n\n        for strategy in self.strategies:\n            strategy_results = {\n                'baseline': {},\n                'disrupted': {},\n                'averages': {}\n            }\n\n            # Run baseline scenarios\n            for demand_scenario in demand_scenarios:\n                scenario_key = f\"demand_{demand_scenario.name}\"\n                metrics = self._run_strategy_scenario(\n                    strategy, demand_scenario, None, simulation_days\n                )\n                strategy_results['baseline'][scenario_key] = metrics\n\n            # Run disruption scenarios\n            for disruption_scenario in disruption_scenarios:\n                scenario_key = f\"disruption_{disruption_scenario.name}\"\n                metrics = self._run_strategy_scenario(\n                    strategy, demand_scenarios[0], disruption_scenario, simulation_days\n                )\n                strategy_results['disrupted'][scenario_key] = metrics\n\n            # Calculate averages and summaries\n            strategy_results['averages'] = self._calculate_strategy_averages(\n                strategy_results\n            )\n\n            results[strategy.strategy_id] = strategy_results\n\n        # Generate comparison report\n        return self._generate_comparison_report(results)\n\n    def _run_strategy_scenario(\n        self,\n        strategy: FleetStrategy,\n        demand_scenario: DemandScenario,\n        disruption_scenario: Optional[DisruptionScenario],\n        days: int\n    ) -&gt; Dict:\n        \"\"\"Run a single strategy through a scenario.\"\"\"\n\n        # Initialize simulation with strategy\n        sim = self._create_simulation(strategy)\n\n        # Apply demand scenario\n        sim.demand_controller.set_demand_pattern(demand_scenario)\n\n        # Apply disruptions if specified\n        if disruption_scenario:\n            sim.resilience_manager.schedule_disruptions(disruption_scenario)\n\n        # Run simulation\n        sim.run(days=days)\n\n        # Collect metrics\n        return {\n            'total_deliveries': sim.get_total_deliveries(),\n            'on_time_rate': sim.get_on_time_rate(),\n            'total_cost': sim.get_total_cost(),\n            'cost_per_delivery': sim.get_cost_per_delivery(),\n            'co2_emissions': sim.get_total_emissions(),\n            'vehicle_utilization': sim.get_average_utilization(),\n            'energy_consumption': sim.get_total_energy(),\n            'failed_deliveries': sim.get_failed_deliveries(),\n            'recovery_events': sim.get_recovery_count()\n        }\n</code></pre>"},{"location":"code_samples/resilience_analysis/#cost-analysis-system","title":"Cost Analysis System","text":"<pre><code>class CostAnalyzer:\n    \"\"\"\n    Comprehensive cost tracking and analysis.\n    \"\"\"\n\n    def __init__(self):\n        self.cost_categories = {\n            'capital': {},\n            'operational': {},\n            'penalty': {},\n            'opportunity': {}\n        }\n\n    def track_vehicle_costs(self, vehicle: VehicleView, dt: float):\n        \"\"\"Track all costs associated with a vehicle.\"\"\"\n\n        vehicle_id = vehicle.vehicle_id\n        spec = self.vehicle_catalog.get_spec(vehicle.spec_id)\n\n        # Capital cost amortization (per hour)\n        if vehicle_id not in self.cost_categories['capital']:\n            # Initialize capital cost tracking\n            if spec.lease_price_monthly_gbp &gt; 0:\n                hourly_lease = spec.lease_price_monthly_gbp / (30 * 24)\n            else:\n                # Assume 5-year depreciation\n                hourly_depreciation = spec.purchase_price_gbp / (5 * 365 * 24)\n                hourly_lease = hourly_depreciation\n\n            self.cost_categories['capital'][vehicle_id] = 0\n\n        self.cost_categories['capital'][vehicle_id] += hourly_lease * (dt / 3600)\n\n        # Operational costs\n        if vehicle.state == VehicleState.EN_ROUTE:\n            # Energy costs\n            energy_cost = self._calculate_energy_cost(vehicle, dt)\n            self._add_operational_cost(vehicle_id, 'energy', energy_cost)\n\n            # Driver costs\n            driver_cost = 25.0 * (dt / 3600)  # \u00a325/hour\n            self._add_operational_cost(vehicle_id, 'driver', driver_cost)\n\n            # Wear and maintenance\n            distance_km = vehicle.speed_kmh * (dt / 3600)\n            maintenance_cost = distance_km * 0.05  # \u00a30.05/km\n            self._add_operational_cost(vehicle_id, 'maintenance', maintenance_cost)\n\n    def _calculate_energy_cost(self, vehicle: VehicleView, dt: float) -&gt; float:\n        \"\"\"Calculate energy cost based on vehicle type.\"\"\"\n\n        distance_km = vehicle.speed_kmh * (dt / 3600)\n\n        if vehicle.propulsion_type == \"BEV\":\n            # Electricity cost\n            kwh_consumed = distance_km * 1.2  # kWh/km\n            if vehicle.state == VehicleState.CHARGING:\n                # Rapid charging premium\n                cost_per_kwh = 0.45\n            else:\n                # Depot charging\n                cost_per_kwh = 0.25\n            return kwh_consumed * cost_per_kwh\n\n        elif vehicle.propulsion_type == \"HFCEV\":\n            # Hydrogen cost\n            kg_consumed = distance_km * 0.08  # kg/km\n            cost_per_kg = 10.0  # \u00a310/kg\n            return kg_consumed * cost_per_kg\n\n        elif vehicle.propulsion_type == \"DIESEL\":\n            # Diesel cost\n            liters_consumed = distance_km * 0.35  # L/km\n            cost_per_liter = 1.50\n            return liters_consumed * cost_per_liter\n\n        return 0\n\n    def calculate_tco(self, vehicle_id: str, years: int = 5) -&gt; Dict:\n        \"\"\"Calculate Total Cost of Ownership for a vehicle.\"\"\"\n\n        vehicle = self.fleet_controller.get_vehicle(vehicle_id)\n        spec = self.vehicle_catalog.get_spec(vehicle.spec_id)\n\n        # Capital costs\n        if spec.lease_price_monthly_gbp &gt; 0:\n            capital_cost = spec.lease_price_monthly_gbp * 12 * years\n        else:\n            capital_cost = spec.purchase_price_gbp\n            # Add residual value\n            residual = spec.purchase_price_gbp * (spec.residual_value_pct / 100)\n            capital_cost -= residual\n\n        # Operational costs (projected)\n        annual_distance = vehicle.odometer_km * 365 / self.simulation_days\n\n        # Energy\n        if vehicle.propulsion_type == \"BEV\":\n            annual_energy_cost = annual_distance * 1.2 * 0.25  # kWh/km * \u00a3/kWh\n        elif vehicle.propulsion_type == \"HFCEV\":\n            annual_energy_cost = annual_distance * 0.08 * 10.0  # kg/km * \u00a3/kg\n        else:\n            annual_energy_cost = annual_distance * 0.35 * 1.50  # L/km * \u00a3/L\n\n        energy_total = annual_energy_cost * years\n\n        # Maintenance\n        maintenance_total = annual_distance * 0.05 * years\n\n        # Driver costs (assuming 250 working days/year, 10 hours/day)\n        driver_total = 25 * 10 * 250 * years\n\n        return {\n            'capital': capital_cost,\n            'energy': energy_total,\n            'maintenance': maintenance_total,\n            'driver': driver_total,\n            'total': capital_cost + energy_total + maintenance_total + driver_total,\n            'per_km': (capital_cost + energy_total + maintenance_total) / (annual_distance * years),\n            'per_year': (capital_cost + energy_total + maintenance_total + driver_total) / years\n        }\n</code></pre>"},{"location":"code_samples/resilience_analysis/#scenario-generator","title":"Scenario Generator","text":"<pre><code>class ScenarioGenerator:\n    \"\"\"\n    Generates test scenarios for resilience and strategy testing.\n    \"\"\"\n\n    def generate_progressive_electrification(self) -&gt; List[FleetStrategy]:\n        \"\"\"Generate strategies for progressive fleet electrification.\"\"\"\n\n        strategies = []\n        base_fleet_size = 50\n\n        for bev_percentage in [0, 20, 40, 60, 80, 100]:\n            bev_count = int(base_fleet_size * bev_percentage / 100)\n            diesel_count = base_fleet_size - bev_count\n\n            strategy = FleetStrategy(\n                strategy_id=f\"electrification_{bev_percentage}\",\n                name=f\"{bev_percentage}% Electric Fleet\",\n                fleet_composition={\n                    'VOLVO_FH_BEV_540': bev_count // 2,\n                    'DAIMLER_EACTROS_600': bev_count - (bev_count // 2),\n                    'VOLVO_FH_DIESEL': diesel_count\n                },\n                charging_strategy=\"depot_only\" if bev_percentage &lt;= 40 else \"opportunistic\",\n                operational_hours=(6, 22),\n                infrastructure_level=\"minimal\" if bev_percentage &lt;= 20 else \"moderate\"\n            )\n            strategies.append(strategy)\n\n        return strategies\n\n    def generate_disruption_scenarios(self) -&gt; List[DisruptionScenario]:\n        \"\"\"Generate standard disruption scenarios for testing.\"\"\"\n\n        scenarios = []\n\n        # Infrastructure failure scenario\n        scenarios.append(DisruptionScenario(\n            name=\"infrastructure_failure\",\n            description=\"30% charging infrastructure offline\",\n            events=[\n                DisruptionEvent(\n                    event_id=\"chrg_fail_1\",\n                    disruption_type=DisruptionType.CHARGING_STATION_FAILURE,\n                    start_time=7 * 3600,  # 7 AM\n                    duration_min=240,  # 4 hours\n                    severity=0.3,\n                    affected_entities=[\"STATION_001\", \"STATION_003\", \"STATION_005\"]\n                )\n            ]\n        ))\n\n        # Peak demand scenario\n        scenarios.append(DisruptionScenario(\n            name=\"peak_demand\",\n            description=\"150% demand spike during peak hours\",\n            events=[\n                DisruptionEvent(\n                    event_id=\"demand_spike_1\",\n                    disruption_type=DisruptionType.DEMAND_SPIKE,\n                    start_time=9 * 3600,\n                    duration_min=180,\n                    severity=0.5,  # 50% increase\n                    affected_entities=[]\n                )\n            ]\n        ))\n\n        # Combined stress scenario\n        scenarios.append(DisruptionScenario(\n            name=\"combined_stress\",\n            description=\"Multiple simultaneous disruptions\",\n            events=[\n                DisruptionEvent(\n                    event_id=\"vehicle_fail_1\",\n                    disruption_type=DisruptionType.VEHICLE_BREAKDOWN,\n                    start_time=8 * 3600,\n                    duration_min=480,\n                    severity=1.0,\n                    affected_entities=[\"VEH_0001\", \"VEH_0005\", \"VEH_0010\"]\n                ),\n                DisruptionEvent(\n                    event_id=\"weather_1\",\n                    disruption_type=DisruptionType.WEATHER_SEVERE,\n                    start_time=6 * 3600,\n                    duration_min=720,\n                    severity=0.3,  # 30% speed reduction\n                    affected_entities=[],\n                    location=(51.5, -0.1),\n                    radius_km=50\n                )\n            ]\n        ))\n\n        return scenarios\n</code></pre>"},{"location":"code_samples/resilience_analysis/#reporting-and-visualization","title":"Reporting and Visualization","text":"<pre><code>class ResilienceReport:\n    \"\"\"\n    Generates comprehensive resilience analysis reports.\n    \"\"\"\n\n    def generate_comparison_matrix(\n        self,\n        strategies: List[FleetStrategy],\n        results: Dict\n    ) -&gt; pd.DataFrame:\n        \"\"\"Generate comparison matrix of strategies.\"\"\"\n\n        data = []\n        for strategy in strategies:\n            strategy_results = results[strategy.strategy_id]\n\n            row = {\n                'Strategy': strategy.name,\n                'Fleet Size': sum(strategy.fleet_composition.values()),\n                'BEV %': self._calculate_bev_percentage(strategy),\n                'TCO (5yr)': strategy_results['averages']['tco_5yr'],\n                'Cost/Delivery': strategy_results['averages']['cost_per_delivery'],\n                'On-Time Rate': strategy_results['averages']['on_time_rate'],\n                'CO2/tonne-km': strategy_results['averages']['co2_per_tonne_km'],\n                'Resilience Score': strategy_results['averages']['resilience_score'],\n                'Recovery Time': strategy_results['averages']['recovery_time_min']\n            }\n            data.append(row)\n\n        df = pd.DataFrame(data)\n        df = df.sort_values('TCO (5yr)')\n\n        return df\n\n    def generate_resilience_dashboard(self, results: Dict) -&gt; Dict:\n        \"\"\"Generate dashboard data for resilience visualization.\"\"\"\n\n        dashboard = {\n            'summary_metrics': {\n                'best_tco_strategy': self._find_best_strategy(results, 'tco_5yr'),\n                'most_resilient_strategy': self._find_best_strategy(results, 'resilience_score'),\n                'lowest_emissions_strategy': self._find_best_strategy(results, 'co2_total'),\n                'optimal_bev_percentage': self._find_optimal_bev_percentage(results)\n            },\n            'charts': {\n                'tco_comparison': self._generate_tco_chart_data(results),\n                'resilience_spider': self._generate_resilience_spider_data(results),\n                'emission_trajectory': self._generate_emission_trajectory_data(results),\n                'cost_breakdown': self._generate_cost_breakdown_data(results)\n            },\n            'recommendations': self._generate_recommendations(results)\n        }\n\n        return dashboard\n</code></pre>"},{"location":"code_samples/vehicle_assignment/","title":"Vehicle Assignment Optimization","text":""},{"location":"code_samples/vehicle_assignment/#core-assignment-problem","title":"Core Assignment Problem","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Dict, Optional, Tuple\nimport numpy as np\n\n@dataclass\nclass AssignmentResult:\n    \"\"\"Result of vehicle assignment optimization.\"\"\"\n    vehicle_assignments: Dict[str, List[str]]  # vehicle_id -&gt; demand_ids\n    unassigned_demands: List[str]\n    total_cost: float\n    total_distance_km: float\n    avg_utilization: float\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#vehicle-assignment-optimizer","title":"Vehicle Assignment Optimizer","text":"<pre><code>class VehicleAssignmentOptimizer:\n    \"\"\"\n    Assigns demands to vehicles for a single operator.\n    Optimizes for cost, feasibility, and service level.\n    \"\"\"\n\n    def __init__(self):\n        # UK operational parameters\n        self.max_driving_time_min = 540  # 9 hours daily limit\n        self.max_continuous_driving_min = 270  # 4.5 hours\n        self.required_break_min = 45\n\n    def assign_demands_to_vehicles(\n        self,\n        vehicles: List[VehicleView],\n        demands: List[DemandView],\n        infrastructure: Dict\n    ) -&gt; AssignmentResult:\n        \"\"\"\n        Main assignment method using two-phase approach:\n        1. Cluster demands geographically and temporally\n        2. Assign best vehicle to each cluster\n        \"\"\"\n\n        # Filter available vehicles\n        available_vehicles = [v for v in vehicles if v.state == VehicleState.IDLE.value]\n\n        if not available_vehicles:\n            return AssignmentResult(\n                vehicle_assignments={},\n                unassigned_demands=[d.demand_id for d in demands],\n                total_cost=0,\n                total_distance_km=0,\n                avg_utilization=0\n            )\n\n        # Phase 1: Cluster demands\n        clusters = self._cluster_demands(demands)\n\n        # Phase 2: Assign vehicles to clusters\n        assignments = self._assign_vehicles_to_clusters(\n            available_vehicles, clusters, infrastructure\n        )\n\n        # Calculate metrics\n        metrics = self._calculate_assignment_metrics(assignments, demands)\n\n        return AssignmentResult(\n            vehicle_assignments=assignments,\n            unassigned_demands=metrics['unassigned'],\n            total_cost=metrics['total_cost'],\n            total_distance_km=metrics['total_distance'],\n            avg_utilization=metrics['avg_utilization']\n        )\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#demand-clustering","title":"Demand Clustering","text":"<pre><code>def _cluster_demands(self, demands: List[DemandView]) -&gt; List[List[DemandView]]:\n    \"\"\"\n    Cluster demands based on proximity and time windows.\n    Uses DBSCAN for density-based clustering.\n    \"\"\"\n    from sklearn.cluster import DBSCAN\n\n    if len(demands) &lt; 2:\n        return [[d] for d in demands]\n\n    # Build feature matrix: [x, y, time_window_center]\n    features = []\n    for demand in demands:\n        x = demand.destination_x\n        y = demand.destination_y\n        # Normalize time to same scale as distance\n        time_center = (demand.delivery_window_start + demand.delivery_window_end) / 2\n        time_normalized = time_center / (24 * 3600) * 100  # Scale to ~100km\n\n        features.append([x, y, time_normalized])\n\n    features = np.array(features)\n\n    # DBSCAN clustering\n    clustering = DBSCAN(eps=30, min_samples=2).fit(features)\n    labels = clustering.labels_\n\n    # Group by cluster\n    clusters = {}\n    for demand, label in zip(demands, labels):\n        if label == -1:  # Noise point - create individual cluster\n            clusters[f\"single_{demand.demand_id}\"] = [demand]\n        else:\n            if label not in clusters:\n                clusters[label] = []\n            clusters[label].append(demand)\n\n    return list(clusters.values())\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#vehicle-to-cluster-assignment","title":"Vehicle-to-Cluster Assignment","text":"<pre><code>def _assign_vehicles_to_clusters(\n    self,\n    vehicles: List[VehicleView],\n    clusters: List[List[DemandView]],\n    infrastructure: Dict\n) -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Assign best vehicle to each demand cluster.\n    Considers vehicle capabilities and constraints.\n    \"\"\"\n\n    assignments = {}\n    assigned_vehicles = set()\n\n    # Sort clusters by priority and size\n    sorted_clusters = sorted(\n        clusters,\n        key=lambda c: (\n            -max(d.priority for d in c),  # Higher priority first\n            -sum(d.weight_kg for d in c)   # Larger loads first\n        )\n    )\n\n    for cluster in sorted_clusters:\n        # Calculate cluster requirements\n        cluster_weight = sum(d.weight_kg for d in cluster)\n        cluster_volume = sum(d.volume_m3 for d in cluster)\n        cluster_distance = self._estimate_cluster_distance(cluster)\n\n        # Find best available vehicle\n        best_vehicle = None\n        best_score = float('inf')\n\n        for vehicle in vehicles:\n            if vehicle.vehicle_id in assigned_vehicles:\n                continue\n\n            # Check feasibility\n            if not self._is_vehicle_feasible_for_cluster(\n                vehicle, cluster, cluster_weight, cluster_distance\n            ):\n                continue\n\n            # Calculate assignment score\n            score = self._calculate_assignment_score(\n                vehicle, cluster, cluster_distance, infrastructure\n            )\n\n            if score &lt; best_score:\n                best_score = score\n                best_vehicle = vehicle\n\n        # Make assignment\n        if best_vehicle:\n            assignments[best_vehicle.vehicle_id] = [d.demand_id for d in cluster]\n            assigned_vehicles.add(best_vehicle.vehicle_id)\n\n    return assignments\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#feasibility-checking","title":"Feasibility Checking","text":"<pre><code>def _is_vehicle_feasible_for_cluster(\n    self,\n    vehicle: VehicleView,\n    cluster: List[DemandView],\n    total_weight: float,\n    estimated_distance: float\n) -&gt; bool:\n    \"\"\"\n    Check if vehicle can feasibly serve the cluster.\n    \"\"\"\n\n    # Get vehicle specification\n    spec = self.vehicle_catalog.get_spec(vehicle.spec_id)\n\n    # Check weight capacity\n    if total_weight &gt; spec.payload_capacity_kg:\n        return False\n\n    # Check range for BEVs\n    if vehicle.propulsion_type == \"BEV\":\n        energy_required = estimated_distance * spec.primary_propulsion.consumption_baseline\n        battery_energy = spec.primary_propulsion.battery_capacity_kwh * (vehicle.current_soc_pct / 100)\n\n        # Need 20% buffer\n        if energy_required &gt; battery_energy * 0.8:\n            return False\n\n    # Check range for HFCEVs\n    elif vehicle.propulsion_type == \"HFCEV\":\n        h2_required = estimated_distance * spec.primary_propulsion.consumption_baseline\n        if h2_required &gt; vehicle.current_h2_level_kg * 0.8:\n            return False\n\n    # Check time feasibility\n    estimated_time = self._estimate_delivery_time(cluster, estimated_distance)\n    if estimated_time &gt; self.max_driving_time_min:\n        return False\n\n    # Check time windows\n    earliest_start = min(d.delivery_window_start for d in cluster)\n    latest_end = max(d.delivery_window_end for d in cluster)\n    window_span = (latest_end - earliest_start) / 3600  # hours\n\n    if window_span &gt; 10:  # Too spread out\n        return False\n\n    return True\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#assignment-scoring","title":"Assignment Scoring","text":"<pre><code>def _calculate_assignment_score(\n    self,\n    vehicle: VehicleView,\n    cluster: List[DemandView],\n    distance: float,\n    infrastructure: Dict\n) -&gt; float:\n    \"\"\"\n    Calculate score for assigning vehicle to cluster.\n    Lower score is better.\n    \"\"\"\n\n    spec = self.vehicle_catalog.get_spec(vehicle.spec_id)\n    score = 0.0\n\n    # Distance cost\n    distance_cost = distance * 2.0  # \u00a32 per km base cost\n    score += distance_cost\n\n    # Energy cost\n    if vehicle.propulsion_type == \"BEV\":\n        energy_kwh = distance * spec.primary_propulsion.consumption_baseline\n        energy_cost = energy_kwh * 0.25  # \u00a30.25 per kWh\n        score += energy_cost\n\n        # Charging time penalty if needed\n        if vehicle.current_soc_pct &lt; 50:\n            score += 50  # Penalty for low SOC\n\n    elif vehicle.propulsion_type == \"HFCEV\":\n        h2_kg = distance * spec.primary_propulsion.consumption_baseline\n        h2_cost = h2_kg * 10.0  # \u00a310 per kg H2\n        score += h2_cost\n\n    elif vehicle.propulsion_type == \"DIESEL\":\n        fuel_l = distance * spec.primary_propulsion.consumption_baseline\n        fuel_cost = fuel_l * 1.5  # \u00a31.50 per liter\n        score += fuel_cost\n\n    # Utilization bonus (prefer using vehicles efficiently)\n    cluster_weight = sum(d.weight_kg for d in cluster)\n    utilization = cluster_weight / spec.payload_capacity_kg\n    if utilization &gt; 0.7:  # Good utilization\n        score *= 0.9  # 10% bonus\n\n    # Time window tightness penalty\n    time_flexibility = self._calculate_time_flexibility(cluster)\n    if time_flexibility &lt; 2:  # Less than 2 hours flexibility\n        score *= 1.2  # 20% penalty\n\n    return score\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#helper-methods","title":"Helper Methods","text":"<pre><code>def _estimate_cluster_distance(self, cluster: List[DemandView]) -&gt; float:\n    \"\"\"\n    Estimate total distance to serve all demands in cluster.\n    Uses TSP approximation.\n    \"\"\"\n\n    if len(cluster) == 1:\n        demand = cluster[0]\n        # Distance from depot to demand and back\n        return 2 * np.sqrt(demand.destination_x**2 + demand.destination_y**2)\n\n    # Build distance matrix\n    n = len(cluster)\n    positions = [(d.destination_x, d.destination_y) for d in cluster]\n\n    # Add depot at origin\n    positions.insert(0, (0, 0))\n\n    # Calculate pairwise distances\n    total_distance = 0\n    current_pos = 0  # Start at depot\n\n    unvisited = set(range(1, n + 1))\n\n    # Nearest neighbor heuristic\n    while unvisited:\n        nearest = min(unvisited, key=lambda i: self._euclidean_distance(\n            positions[current_pos], positions[i]\n        ))\n        total_distance += self._euclidean_distance(\n            positions[current_pos], positions[nearest]\n        )\n        current_pos = nearest\n        unvisited.remove(nearest)\n\n    # Return to depot\n    total_distance += self._euclidean_distance(positions[current_pos], positions[0])\n\n    return total_distance\n\ndef _euclidean_distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -&gt; float:\n    \"\"\"Calculate Euclidean distance between two positions.\"\"\"\n    return np.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\n\ndef _estimate_delivery_time(self, cluster: List[DemandView], distance: float) -&gt; float:\n    \"\"\"\n    Estimate time needed to complete all deliveries.\n    \"\"\"\n\n    # Driving time at average speed\n    avg_speed_kmh = 50\n    driving_time = (distance / avg_speed_kmh) * 60  # minutes\n\n    # Add time for each delivery\n    delivery_time = len(cluster) * 15  # 15 minutes per delivery\n\n    # Add break time if needed\n    total_time = driving_time + delivery_time\n    if total_time &gt; self.max_continuous_driving_min:\n        total_time += self.required_break_min\n\n    return total_time\n\ndef _calculate_time_flexibility(self, cluster: List[DemandView]) -&gt; float:\n    \"\"\"\n    Calculate average time window flexibility in hours.\n    \"\"\"\n\n    flexibilities = []\n    for demand in cluster:\n        window_hours = (demand.delivery_window_end - demand.delivery_window_start) / 3600\n        flexibilities.append(window_hours)\n\n    return np.mean(flexibilities)\n</code></pre>"},{"location":"code_samples/vehicle_assignment/#optimization-result-processing","title":"Optimization Result Processing","text":"<pre><code>def _calculate_assignment_metrics(\n    self,\n    assignments: Dict[str, List[str]],\n    all_demands: List[DemandView]\n) -&gt; Dict:\n    \"\"\"\n    Calculate metrics for the assignment result.\n    \"\"\"\n\n    assigned_demand_ids = set()\n    total_distance = 0\n    total_cost = 0\n    utilizations = []\n\n    for vehicle_id, demand_ids in assignments.items():\n        assigned_demand_ids.update(demand_ids)\n\n        # Get assigned demands\n        assigned = [d for d in all_demands if d.demand_id in demand_ids]\n\n        # Calculate distance\n        distance = self._estimate_cluster_distance(assigned)\n        total_distance += distance\n\n        # Calculate cost (simplified)\n        cost = distance * 2.0  # Base cost\n        total_cost += cost\n\n        # Calculate utilization\n        vehicle = self.get_vehicle(vehicle_id)\n        spec = self.vehicle_catalog.get_spec(vehicle.spec_id)\n        weight = sum(d.weight_kg for d in assigned)\n        utilization = weight / spec.payload_capacity_kg\n        utilizations.append(utilization)\n\n    # Find unassigned demands\n    all_demand_ids = {d.demand_id for d in all_demands}\n    unassigned = list(all_demand_ids - assigned_demand_ids)\n\n    return {\n        'unassigned': unassigned,\n        'total_cost': total_cost,\n        'total_distance': total_distance,\n        'avg_utilization': np.mean(utilizations) if utilizations else 0\n    }\n</code></pre>"},{"location":"code_samples/vehicle_entities/","title":"Vehicle Entity Implementation","text":""},{"location":"code_samples/vehicle_entities/#vehicle-state-definition","title":"Vehicle State Definition","text":"<pre><code>from enum import Enum, auto\n\nclass VehicleState(Enum):\n    \"\"\"Possible operational states for vehicles.\"\"\"\n    IDLE = auto()          # At depot, available\n    LOADING = auto()       # Loading cargo\n    EN_ROUTE = auto()      # Traveling to destination\n    DELIVERING = auto()     # At customer site\n    CHARGING = auto()      # BEV charging\n    REFUELING = auto()     # HFCEV/Diesel refueling\n    RETURNING = auto()     # Returning to depot\n    MAINTENANCE = auto()   # Scheduled maintenance\n    BROKEN_DOWN = auto()   # Unplanned breakdown\n</code></pre>"},{"location":"code_samples/vehicle_entities/#vehicle-view-type-safe-access","title":"Vehicle View (Type-Safe Access)","text":"<pre><code>from kairoslib.primitives.agent_view import AgentView, AgentViewWithState\n\nclass VehicleView(AgentView, AgentViewWithState):\n    \"\"\"Type-safe view for accessing vehicle properties.\"\"\"\n\n    # Core identification\n    vehicle_id: str\n    spec_id: str              # Links to vehicle specification\n    manufacturer: str\n    model: str\n    propulsion_type: str      # \"BEV\", \"HFCEV\", \"DIESEL\"\n\n    # Location and movement\n    location_x: float\n    location_y: float\n    speed_kmh: float\n    heading_deg: float\n\n    # Operational state\n    state: int                # VehicleState enum value\n    depot_id: str\n    current_route_id: str\n    assigned_demand_ids: str  # Comma-separated list\n\n    # Common properties (all vehicles)\n    payload_kg: float\n    odometer_km: float\n    trips_completed: int\n    energy_consumed_kwh_equiv: float\n\n    # BEV-specific (NaN for non-BEV)\n    battery_capacity_kwh: float\n    current_soc_pct: float\n    charging_power_kw: float\n    battery_temperature_c: float\n\n    # HFCEV-specific (NaN for non-HFCEV)\n    h2_tank_capacity_kg: float\n    current_h2_level_kg: float\n    fuel_cell_temp_c: float\n\n    # Diesel-specific (NaN for non-Diesel)\n    fuel_tank_capacity_l: float\n    current_fuel_level_l: float\n    adblue_level_l: float\n</code></pre>"},{"location":"code_samples/vehicle_entities/#vehicle-agent-group-vectorized-storage","title":"Vehicle Agent Group (Vectorized Storage)","text":"<pre><code>from kairoslib.primitives.agent_group import AgentGroup\nfrom kairoslib.primitives.property_array import PropertyArray\nimport numpy as np\n\nclass VehicleAgentGroup(AgentGroup[VehicleView]):\n    \"\"\"Efficient storage for all vehicles using PropertyArrays.\"\"\"\n\n    # Core identification\n    vehicle_id: PropertyArray[str] = PropertyArray(str, '')\n    spec_id: PropertyArray[str] = PropertyArray(str, '')\n    manufacturer: PropertyArray[str] = PropertyArray(str, '')\n    model: PropertyArray[str] = PropertyArray(str, '')\n    propulsion_type: PropertyArray[str] = PropertyArray(str, '')\n\n    # Location arrays\n    location_x: PropertyArray[float] = PropertyArray(float, 0.0)\n    location_y: PropertyArray[float] = PropertyArray(float, 0.0)\n    speed_kmh: PropertyArray[float] = PropertyArray(float, 0.0)\n    heading_deg: PropertyArray[float] = PropertyArray(float, 0.0)\n\n    # State arrays\n    state: PropertyArray[int] = PropertyArray(int, VehicleState.IDLE.value)\n    depot_id: PropertyArray[str] = PropertyArray(str, '')\n    current_route_id: PropertyArray[str] = PropertyArray(str, '')\n    assigned_demand_ids: PropertyArray[str] = PropertyArray(str, '')\n\n    # Common operational data\n    payload_kg: PropertyArray[float] = PropertyArray(float, 0.0)\n    odometer_km: PropertyArray[float] = PropertyArray(float, 0.0)\n    trips_completed: PropertyArray[int] = PropertyArray(int, 0)\n    energy_consumed_kwh_equiv: PropertyArray[float] = PropertyArray(float, 0.0)\n\n    # BEV arrays (sparse - NaN for non-BEV)\n    battery_capacity_kwh: PropertyArray[float] = PropertyArray(float, float('nan'))\n    current_soc_pct: PropertyArray[float] = PropertyArray(float, float('nan'))\n    charging_power_kw: PropertyArray[float] = PropertyArray(float, float('nan'))\n    battery_temperature_c: PropertyArray[float] = PropertyArray(float, float('nan'))\n\n    # HFCEV arrays (sparse - NaN for non-HFCEV)\n    h2_tank_capacity_kg: PropertyArray[float] = PropertyArray(float, float('nan'))\n    current_h2_level_kg: PropertyArray[float] = PropertyArray(float, float('nan'))\n    fuel_cell_temp_c: PropertyArray[float] = PropertyArray(float, float('nan'))\n\n    # Diesel arrays (sparse - NaN for non-Diesel)\n    fuel_tank_capacity_l: PropertyArray[float] = PropertyArray(float, float('nan'))\n    current_fuel_level_l: PropertyArray[float] = PropertyArray(float, float('nan'))\n    adblue_level_l: PropertyArray[float] = PropertyArray(float, float('nan'))\n\n    def get_vehicles_by_type(self, propulsion_type: str) -&gt; List[VehicleView]:\n        \"\"\"Get all vehicles of a specific propulsion type.\"\"\"\n        mask = self.propulsion_type == propulsion_type\n        indices = np.where(mask)[0]\n        return [VehicleView(self, idx) for idx in indices]\n\n    def get_available_vehicles(self) -&gt; List[VehicleView]:\n        \"\"\"Get vehicles currently available for assignment.\"\"\"\n        mask = self.state == VehicleState.IDLE.value\n        indices = np.where(mask)[0]\n        return [VehicleView(self, idx) for idx in indices]\n\n    def update_locations(self, dt: float):\n        \"\"\"Vectorized update of all vehicle positions.\"\"\"\n        # Only update vehicles that are moving\n        moving_mask = self.state == VehicleState.EN_ROUTE.value\n\n        # Calculate distance traveled\n        distance_km = self.speed_kmh[moving_mask] * (dt / 3600)\n\n        # Update positions (simplified - real would use road network)\n        self.location_x[moving_mask] += distance_km * np.cos(np.radians(self.heading_deg[moving_mask]))\n        self.location_y[moving_mask] += distance_km * np.sin(np.radians(self.heading_deg[moving_mask]))\n\n        # Update odometer\n        self.odometer_km[moving_mask] += distance_km\n</code></pre>"},{"location":"code_samples/vehicle_entities/#vehicle-creation-example","title":"Vehicle Creation Example","text":"<pre><code>def create_vehicle(self, spec_id: str, depot_id: str) -&gt; VehicleView:\n    \"\"\"Create a new vehicle from a specification.\"\"\"\n\n    # Get vehicle specification\n    spec = self.vehicle_catalog.get_spec(spec_id)\n    if not spec:\n        raise ValueError(f\"Unknown vehicle spec: {spec_id}\")\n\n    # Determine propulsion type\n    propulsion_type = spec.primary_propulsion.propulsion_type.value\n\n    # Create vehicle with appropriate properties\n    vehicle_data = {\n        'vehicle_id': f\"VEH_{self.agent_group.agents_created:04d}\",\n        'spec_id': spec_id,\n        'manufacturer': spec.manufacturer,\n        'model': spec.model,\n        'propulsion_type': propulsion_type,\n        'depot_id': depot_id,\n        'state': VehicleState.IDLE,\n    }\n\n    # Set propulsion-specific properties\n    if propulsion_type == \"BEV\":\n        vehicle_data.update({\n            'battery_capacity_kwh': spec.primary_propulsion.battery_capacity_kwh,\n            'current_soc_pct': 90.0,  # Start at 90% charge\n        })\n    elif propulsion_type == \"HFCEV\":\n        vehicle_data.update({\n            'h2_tank_capacity_kg': spec.primary_propulsion.h2_tank_capacity_kg,\n            'current_h2_level_kg': spec.primary_propulsion.h2_tank_capacity_kg * 0.9,\n        })\n    elif propulsion_type == \"DIESEL\":\n        vehicle_data.update({\n            'fuel_tank_capacity_l': spec.primary_propulsion.fuel_tank_capacity_l,\n            'current_fuel_level_l': spec.primary_propulsion.fuel_tank_capacity_l * 0.9,\n        })\n\n    # Create the vehicle\n    vehicle = self.agent_group.create_agent(**vehicle_data)\n\n    self.logger.info(\n        f\"Created {propulsion_type} vehicle {vehicle.vehicle_id} \"\n        f\"({spec.manufacturer} {spec.model})\"\n    )\n\n    return vehicle\n</code></pre>"},{"location":"code_samples/vehicle_entities/#efficient-bulk-operations","title":"Efficient Bulk Operations","text":"<pre><code>def update_bev_charging(self, dt: float):\n    \"\"\"Update battery state for all charging BEVs.\"\"\"\n\n    # Find charging BEVs\n    charging_mask = (\n        (self.agent_group.state == VehicleState.CHARGING.value) &amp;\n        (self.agent_group.propulsion_type == \"BEV\")\n    )\n\n    if not charging_mask.any():\n        return\n\n    # Get charging power and battery capacity\n    charging_power = self.agent_group.charging_power_kw[charging_mask]\n    battery_capacity = self.agent_group.battery_capacity_kwh[charging_mask]\n    current_soc = self.agent_group.current_soc_pct[charging_mask]\n\n    # Calculate energy added\n    energy_added_kwh = charging_power * (dt / 3600)\n\n    # Update SOC\n    soc_increase = (energy_added_kwh / battery_capacity) * 100\n    new_soc = np.minimum(current_soc + soc_increase, 100.0)\n\n    # Apply updates\n    self.agent_group.current_soc_pct[charging_mask] = new_soc\n\n    # Check for completed charging\n    completed_mask = charging_mask.copy()\n    completed_mask[charging_mask] = (new_soc &gt;= 80.0)  # Charge to 80%\n\n    if completed_mask.any():\n        self.agent_group.state[completed_mask] = VehicleState.IDLE.value\n        self.agent_group.charging_power_kw[completed_mask] = 0.0\n</code></pre>"}]}