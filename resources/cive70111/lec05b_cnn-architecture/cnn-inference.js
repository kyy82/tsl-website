class CNNInference{constructor(){this.weights=null,this.architecture=null}loadModel(weights,architecture){this.weights=weights,this.architecture=architecture}conv2d(input,kernels,biases,stride=1,padding=0){const[in_channels,in_height,in_width]=[input.length,input[0].length,input[0][0].length],[out_channels,_,kernel_h,kernel_w]=[kernels.length,kernels[0].length,kernels[0][0].length,kernels[0][0][0].length],out_height=Math.floor((in_height+2*padding-kernel_h)/stride)+1,out_width=Math.floor((in_width+2*padding-kernel_w)/stride)+1,output=new Array(out_channels);for(let oc=0;oc<out_channels;oc++){output[oc]=new Array(out_height);for(let oh=0;oh<out_height;oh++)output[oc][oh]=new Array(out_width).fill(0)}const padded_input=this.applyPadding(input,padding);for(let oc=0;oc<out_channels;oc++)for(let oh=0;oh<out_height;oh++)for(let ow=0;ow<out_width;ow++){let sum=biases[oc];for(let ic=0;ic<in_channels;ic++)for(let kh=0;kh<kernel_h;kh++)for(let kw=0;kw<kernel_w;kw++){const ih=oh*stride+kh,iw=ow*stride+kw;sum+=padded_input[ic][ih][iw]*kernels[oc][ic][kh][kw]}output[oc][oh][ow]=sum}return output}applyPadding(input,padding){if(0===padding)return input;const[channels,height,width]=[input.length,input[0].length,input[0][0].length],padded_height=height+2*padding,padded_width=width+2*padding,padded=new Array(channels);for(let c=0;c<channels;c++){padded[c]=new Array(padded_height);for(let h=0;h<padded_height;h++)padded[c][h]=new Array(padded_width).fill(0);for(let h=0;h<height;h++)for(let w=0;w<width;w++)padded[c][h+padding][w+padding]=input[c][h][w]}return padded}relu(input){return Array.isArray(input[0])?input.map(row=>this.relu(row)):input.map(x=>Math.max(0,x))}maxPool2d(input,kernel_size=2,stride=2){const[channels,height,width]=[input.length,input[0].length,input[0][0].length],out_height=Math.floor((height-kernel_size)/stride)+1,out_width=Math.floor((width-kernel_size)/stride)+1,output=new Array(channels);for(let c=0;c<channels;c++){output[c]=new Array(out_height);for(let oh=0;oh<out_height;oh++){output[c][oh]=new Array(out_width);for(let ow=0;ow<out_width;ow++){let max_val=-1/0;for(let kh=0;kh<kernel_size;kh++)for(let kw=0;kw<kernel_size;kw++){const ih=oh*stride+kh,iw=ow*stride+kw;max_val=Math.max(max_val,input[c][ih][iw])}output[c][oh][ow]=max_val}}}return output}flatten(input){const result=[];for(let c=0;c<input.length;c++)for(let h=0;h<input[c].length;h++)for(let w=0;w<input[c][h].length;w++)result.push(input[c][h][w]);return result}linear(input,weights,biases){const out_features=weights.length,output=new Array(out_features);for(let o=0;o<out_features;o++){let sum=biases[o];for(let i=0;i<input.length;i++)sum+=input[i]*weights[o][i];output[o]=sum}return output}softmax(input){const max_val=Math.max(...input),exp_values=input.map(x=>Math.exp(x-max_val)),sum_exp=exp_values.reduce((a,b)=>a+b,0);return exp_values.map(x=>x/sum_exp)}preprocessImage(imageData){return[imageData.map(row=>row.map(pixel=>(pixel/255-.1307)/.3081))]}forward(imageData,weights){const activations={};let x=this.preprocessImage(imageData);activations.input=x,x=this.conv2d(x,weights.conv1.weight,weights.conv1.bias,1,0),activations.conv1=this.deepCopy(x),x=this.relu(x),x=this.maxPool2d(x,2,2),activations.pool1=this.deepCopy(x),x=this.conv2d(x,weights.conv2.weight,weights.conv2.bias,1,0),activations.conv2=this.deepCopy(x),x=this.relu(x),x=this.maxPool2d(x,2,2),activations.pool2=this.deepCopy(x),x=this.flatten(x),activations.flatten=[...x],x=this.linear(x,weights.fc1.weight,weights.fc1.bias),x=this.relu(x),activations.fc1=[...x],x=this.linear(x,weights.fc2.weight,weights.fc2.bias),activations.output=[...x];const probabilities=this.softmax(x);return{logits:x,probabilities:probabilities,prediction:probabilities.indexOf(Math.max(...probabilities)),activations:activations}}deepCopy(arr){return Array.isArray(arr)?arr.map(item=>Array.isArray(item)?this.deepCopy(item):item):arr}predict(imageData,epochIndex,pretrainedData){if(!pretrainedData||!pretrainedData.training_epochs[epochIndex])throw new Error(`No weights available for epoch ${epochIndex}`);const epochWeights=pretrainedData.training_epochs[epochIndex].weights;return this.forward(imageData,epochWeights)}}