class CNNInference{constructor(){this.weights=null,this.architecture=null}loadModel(t,e){this.weights=t,this.architecture=e}conv2d(t,e,r,o=1,n=0){const[l,a,h]=[t.length,t[0].length,t[0][0].length],[i,s,f,c]=[e.length,e[0].length,e[0][0].length,e[0][0][0].length],p=Math.floor((a+2*n-f)/o)+1,g=Math.floor((h+2*n-c)/o)+1,u=new Array(i);for(let t=0;t<i;t++){u[t]=new Array(p);for(let e=0;e<p;e++)u[t][e]=new Array(g).fill(0)}const d=this.applyPadding(t,n);for(let t=0;t<i;t++)for(let n=0;n<p;n++)for(let a=0;a<g;a++){let h=r[t];for(let r=0;r<l;r++)for(let l=0;l<f;l++)for(let i=0;i<c;i++){const s=n*o+l,f=a*o+i;h+=d[r][s][f]*e[t][r][l][i]}u[t][n][a]=h}return u}applyPadding(t,e){if(0===e)return t;const[r,o,n]=[t.length,t[0].length,t[0][0].length],l=o+2*e,a=n+2*e,h=new Array(r);for(let i=0;i<r;i++){h[i]=new Array(l);for(let t=0;t<l;t++)h[i][t]=new Array(a).fill(0);for(let r=0;r<o;r++)for(let o=0;o<n;o++)h[i][r+e][o+e]=t[i][r][o]}return h}relu(t){return Array.isArray(t[0])?t.map(t=>this.relu(t)):t.map(t=>Math.max(0,t))}maxPool2d(t,e=2,r=2){const[o,n,l]=[t.length,t[0].length,t[0][0].length],a=Math.floor((n-e)/r)+1,h=Math.floor((l-e)/r)+1,i=new Array(o);for(let n=0;n<o;n++){i[n]=new Array(a);for(let o=0;o<a;o++){i[n][o]=new Array(h);for(let l=0;l<h;l++){let a=-1/0;for(let h=0;h<e;h++)for(let i=0;i<e;i++){const e=o*r+h,s=l*r+i;a=Math.max(a,t[n][e][s])}i[n][o][l]=a}}}return i}flatten(t){const e=[];for(let r=0;r<t.length;r++)for(let o=0;o<t[r].length;o++)for(let n=0;n<t[r][o].length;n++)e.push(t[r][o][n]);return e}linear(t,e,r){const o=e.length,n=new Array(o);for(let l=0;l<o;l++){let o=r[l];for(let r=0;r<t.length;r++)o+=t[r]*e[l][r];n[l]=o}return n}softmax(t){const e=Math.max(...t),r=t.map(t=>Math.exp(t-e)),o=r.reduce((t,e)=>t+e,0);return r.map(t=>t/o)}preprocessImage(t){return[t.map(t=>t.map(t=>(t/255-.1307)/.3081))]}forward(t,e){const r={};let o=this.preprocessImage(t);r.input=o,o=this.conv2d(o,e.conv1.weight,e.conv1.bias,1,0),r.conv1=this.deepCopy(o),o=this.relu(o),o=this.maxPool2d(o,2,2),r.pool1=this.deepCopy(o),o=this.conv2d(o,e.conv2.weight,e.conv2.bias,1,0),r.conv2=this.deepCopy(o),o=this.relu(o),o=this.maxPool2d(o,2,2),r.pool2=this.deepCopy(o),o=this.flatten(o),r.flatten=[...o],o=this.linear(o,e.fc1.weight,e.fc1.bias),o=this.relu(o),r.fc1=[...o],o=this.linear(o,e.fc2.weight,e.fc2.bias),r.output=[...o];const n=this.softmax(o);return{logits:o,probabilities:n,prediction:n.indexOf(Math.max(...n)),activations:r}}deepCopy(t){return Array.isArray(t)?t.map(t=>Array.isArray(t)?this.deepCopy(t):t):t}predict(t,e,r){if(!r||!r.training_epochs[e])throw new Error(`No weights available for epoch ${e}`);const o=r.training_epochs[e].weights;return this.forward(t,o)}}