class LinearRegressionDemo{constructor(){this.competitionMode=!1,this.competitionUsername=null,this.scoreUpdateTimeout=null,this.canvas=document.getElementById("plot"),this.ctx=this.canvas.getContext("2d"),this.alphaSlider=document.getElementById("alpha"),this.betaSlider=document.getElementById("beta"),this.alphaValue=document.getElementById("alpha-value"),this.betaValue=document.getElementById("beta-value"),this.equation=document.getElementById("equation"),this.mseDisplay=document.getElementById("mse"),this.maeDisplay=document.getElementById("mae"),this.r2Display=document.getElementById("r2"),this.solutionBtn=document.getElementById("solution-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.showSquaresCheckbox=document.getElementById("show-squares"),this.showConfidenceCheckbox=document.getElementById("show-confidence"),this.structuresBtn=document.getElementById("structures-btn"),this.geotechBtn=document.getElementById("geotech-btn"),this.transportBtn=document.getElementById("transport-btn"),this.environmentBtn=document.getElementById("environment-btn"),this.leaderboard=new LeaderboardClient({roomId:"lec02a_linear-regression",autoConnect:!1,debug:!0,roomConfig:{display:"Linear Regression Challenge",metrics:["r2","mse"],sortBy:"r2",order:"desc",description:"Achieve the highest R² score on the linear regression demo",maxUsers:200,sessionTimeout:6e5},onConnect:()=>{this.leaderboard.updateStatus("Connected to leaderboard","connected"),this.competitionMode&&(document.getElementById("leaderboard-panel").style.display="block")},onDisconnect:()=>{this.leaderboard.updateStatus("Disconnected","disconnected")},onLeaderboardUpdate:data=>{this.leaderboard.updateLeaderboard(data),this.leaderboard.updateUserPositionFromLeaderboard(data)},onPositionUpdate:position=>{this.leaderboard.updateUserPosition(position)},onError:error=>{this.leaderboard.updateStatus("Connection error","disconnected")},onStatusChange:status=>{"error"===status?this.leaderboard.updateStatus("Server unavailable","disconnected"):"joined"===status&&this.leaderboard.updateStatus("Competition active","connected")},onUsernameAssigned:username=>{this.competitionUsername=username,document.getElementById("competition-username").textContent=username}}),this.tabController=new DemoTabController({onTabChange:tabName=>this.handleTabChange(tabName)}),this.setupHighDPICanvas(),this.plotWidth=this.displayWidth-90,this.plotHeight=this.displayHeight-80,this.plotX=50,this.plotY=40,this.xMin=-10,this.xMax=10,this.yMin=-100,this.yMax=100,this.xLabel="X",this.yLabel="Y",this.datasets={structures:{name:"Structures - Concrete Strength",file:"example-data/structures_concrete.csv",xLabel:"Cement (kg/m³)",yLabel:"Compressive Strength (MPa)",xColumn:"Cement_kg_per_m3",yColumn:"Compressive_Strength_MPa",title:"Structures: Concrete Strength",description:"This dataset shows how increasing cement content tends to increase concrete strength. The data comes from concrete compressive strength measurements.",variables:"Variables: Cement content (kg/m³) vs Compressive strength (MPa)"},geotech:{name:"Geotechnics - Soil Properties",file:"example-data/geotechnics_soil.csv",xLabel:"Sand Content (%)",yLabel:"Uniformity Coefficient",xColumn:"Sand_Percent",yColumn:"Uniformity_Coefficient",title:"Geotechnics: Soil Properties",description:"This dataset explores how soil composition relates to gradation properties. It demonstrates the relationship between sand percentage and uniformity coefficient in soil samples.",variables:"Variables: Sand percentage (%) vs Uniformity coefficient (measure of soil gradation)"},transport:{name:"Transport - Traffic Flow",file:"example-data/transport_traffic.csv",xLabel:"Vehicle Count",yLabel:"Vehicle Speed (km/h)",xColumn:"Vehicle_Count",yColumn:"Vehicle_Speed_kmh",title:"Transport: Urban Traffic Flow",description:"This dataset shows the negative relationship between vehicle count and speed, demonstrating traffic congestion effects in urban environments.",variables:"Variables: Number of vehicles detected vs Average vehicle speed (km/h)"},environment:{name:"Environment - Wastewater Energy",file:"example-data/environment_wastewater.csv",xLabel:"Inflow (m³/s)",yLabel:"Energy Consumption (MWh)",xColumn:"Inflow_m3_s",yColumn:"Energy_Consumption_MWh",title:"Environment: Wastewater Treatment",description:"This dataset explores how higher inflow rates are associated with greater energy use in wastewater treatment plants, showing the energy demands of processing larger volumes.",variables:"Variables: Average daily inflow (m³/s) vs Daily energy consumption (MWh)"}},this.generateDataPoints(),this.setupEventListeners(),this.initializeDisplay()}generateDataPoints(){this.dataPoints=[];const trueAlpha=14*(Math.random()-.5),trueBeta=40*(Math.random()-.5);for(let i=0;i<10;i++){const x=18*(Math.random()-.5),y=trueAlpha*x+trueBeta+25*(Math.random()-.5)*2;this.dataPoints.push({x:x,y:y})}}setupHighDPICanvas(){const dpr=window.devicePixelRatio||1,displayWidth=this.canvas.clientWidth||600,displayHeight=this.canvas.clientHeight||400;this.canvas.width=displayWidth*dpr,this.canvas.height=displayHeight*dpr,this.canvas.style.width=displayWidth+"px",this.canvas.style.height=displayHeight+"px",this.ctx.scale(dpr,dpr),this.ctx.imageSmoothingEnabled=!0,this.ctx.imageSmoothingQuality="high",this.dpr=dpr,this.displayWidth=displayWidth,this.displayHeight=displayHeight}seededRandom(seed){const x=1e4*Math.sin(seed);return x-Math.floor(x)}generateCompetitionDataset(){this.dataPoints=[];for(let i=0;i<24;i++){const x=20*(this.seededRandom(12345+3*i)-.5),y=2.8*x+12+(50*(this.seededRandom(12345+3*i+1)-.5)+30*(this.seededRandom(12345+3*i+2)-.5)*Math.sin(.8*i));this.dataPoints.push({x:x,y:y})}this.draw()}randomizeParameters(){const randomAlpha=Math.floor(151*Math.random())-50;this.alphaSlider.value=randomAlpha;const randomBeta=(20*Math.random()-5).toFixed(1);this.betaSlider.value=randomBeta,this.updateDisplay(),this.draw()}enterCompetitionMode(){this.competitionMode=!0,this.generateCompetitionDataset(),this.randomizeParameters(),document.getElementById("solution-btn").style.display="none",document.getElementById("generate-data-btn").style.display="none",document.getElementById("clear-data-btn").style.display="none",document.querySelector(".dataset-buttons-section").style.display="none",document.getElementById("leaderboard-panel").style.display="block",document.getElementById("competition-username").textContent="Generating...",this.leaderboard.connect(),this.leaderboard.setUserId("generate-username"),this.leaderboard.join(),setTimeout(()=>{this.sendScoreUpdate()},1e3)}exitCompetitionMode(){this.competitionMode&&(this.competitionMode=!1,document.getElementById("solution-btn").style.display="block",document.getElementById("generate-data-btn").style.display="block",document.getElementById("clear-data-btn").style.display="block",document.querySelector(".dataset-buttons-section").style.display="block",document.getElementById("leaderboard-panel").style.display="none",this.leaderboard.leave(),this.leaderboard.disconnect(),console.log("Exited competition mode"))}handleTabChange(tabName){"compete"===tabName?this.enterCompetitionMode():this.exitCompetitionMode()}sendScoreUpdate(){if(!this.leaderboard.isReady())return;const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),r2=this.calculateR2(alpha,beta),mse=this.calculateMSE(alpha,beta),scores={r2:Math.round(1e3*r2)/1e3,mse:Math.round(100*mse)/100},inputs={alpha:Math.round(1e3*alpha)/1e3,beta:Math.round(1e3*beta)/1e3};this.leaderboard.updateScores(scores,inputs)}debouncedScoreUpdate(){this.competitionMode&&(this.scoreUpdateTimeout&&clearTimeout(this.scoreUpdateTimeout),this.scoreUpdateTimeout=setTimeout(()=>{this.sendScoreUpdate()},100))}initializeDisplay(){this.draw(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}updateDisplayPlainText(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.alphaValue.textContent=Math.round(alpha).toString(),this.betaValue.textContent=beta.toFixed(1);const alphaSign=alpha>=0?"+":"-",alphaValue=Math.abs(alpha);this.equation.innerHTML=`y = ${beta.toFixed(1)}x ${alphaSign} ${alphaValue}<div class="equation-label">Fitted Function</div>`;const mse=this.calculateMSE(alpha,beta),mae=this.calculateMAE(alpha,beta),r2=this.calculateR2(alpha,beta);this.mseDisplay.innerHTML=`MSE = ${mse.toFixed(2)}<div class="equation-label">Mean Squared Error</div>`,this.maeDisplay.innerHTML=`MAE = ${mae.toFixed(2)}<div class="equation-label">Mean Absolute Error</div>`,this.updateR2Display(r2)}updateR2Display(r2){this.r2Display.innerHTML=`R² = ${r2.toFixed(3)}<div class="equation-label">Coefficient of Determination</div>`,this.r2Display.classList.remove("r2-poor","r2-moderate","r2-good"),r2<.3?this.r2Display.classList.add("r2-poor"):r2<.7?this.r2Display.classList.add("r2-moderate"):this.r2Display.classList.add("r2-good")}setupEventListeners(){this.alphaSlider.addEventListener("input",()=>{this.updateDisplay(),this.draw(),this.debouncedScoreUpdate()}),this.betaSlider.addEventListener("input",()=>{this.updateDisplay(),this.draw(),this.debouncedScoreUpdate()}),this.solutionBtn.addEventListener("click",()=>{this.setOptimalValues()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()}),this.structuresBtn.addEventListener("click",()=>{this.loadStructuresData()}),this.geotechBtn.addEventListener("click",()=>{this.loadGeotechData()}),this.transportBtn.addEventListener("click",()=>{this.loadTransportData()}),this.environmentBtn.addEventListener("click",()=>{this.loadEnvironmentData()}),this.canvas.addEventListener("click",event=>{this.handleCanvasClick(event)}),this.showSquaresCheckbox.addEventListener("change",()=>{this.draw()}),this.showConfidenceCheckbox.addEventListener("change",()=>{this.draw()})}updateDisplay(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.alphaValue.textContent=Math.round(alpha).toString(),this.betaValue.textContent=beta.toFixed(1);const alphaSign=alpha>=0?"+":"-",alphaValue=Math.abs(alpha);this.equation.innerHTML=`$$y = ${beta.toFixed(1)}x ${alphaSign} ${alphaValue}$$<div class="equation-label">Fitted Function</div>`,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const mse=this.calculateMSE(alpha,beta),mae=this.calculateMAE(alpha,beta),r2=this.calculateR2(alpha,beta);this.mseDisplay.innerHTML=`$$\\text{MSE} = ${mse.toFixed(2)}$$<div class="equation-label">Mean Squared Error</div>`,this.maeDisplay.innerHTML=`$$\\text{MAE} = ${mae.toFixed(2)}$$<div class="equation-label">Mean Absolute Error</div>`,this.updateR2Display(r2),window.MathJax&&MathJax.typesetPromise([this.mseDisplay,this.maeDisplay,this.r2Display]).catch(err=>console.log(err))}dataToCanvas(x,y){return{x:this.plotX+(x-this.xMin)/(this.xMax-this.xMin)*this.plotWidth,y:this.plotY+this.plotHeight-(y-this.yMin)/(this.yMax-this.yMin)*this.plotHeight}}drawAxes(){this.ctx.strokeStyle="#333",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY+this.plotHeight),this.ctx.lineTo(this.plotX+this.plotWidth,this.plotY+this.plotHeight),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY),this.ctx.lineTo(this.plotX,this.plotY+this.plotHeight),this.ctx.stroke(),this.drawGrid(),this.drawLabels()}calculateTickInterval(min,max,targetTicks=5){const rawInterval=(max-min)/targetTicks,magnitude=Math.floor(Math.log10(rawInterval)),normalizedInterval=rawInterval/Math.pow(10,magnitude);let niceInterval;return niceInterval=normalizedInterval<=1?1:normalizedInterval<=2?2:normalizedInterval<=5?5:10,niceInterval*Math.pow(10,magnitude)}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1;const xInterval=this.calculateTickInterval(this.xMin,this.xMax),yInterval=this.calculateTickInterval(this.yMin,this.yMax);for(let x=Math.ceil(this.xMin/xInterval)*xInterval;x<=this.xMax;x+=xInterval){const canvasPos=this.dataToCanvas(x,0);this.ctx.beginPath(),this.ctx.moveTo(canvasPos.x,this.plotY),this.ctx.lineTo(canvasPos.x,this.plotY+this.plotHeight),this.ctx.stroke()}for(let y=Math.ceil(this.yMin/yInterval)*yInterval;y<=this.yMax;y+=yInterval){const canvasPos=this.dataToCanvas(0,y);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,canvasPos.y),this.ctx.lineTo(this.plotX+this.plotWidth,canvasPos.y),this.ctx.stroke()}}formatTickLabel(value){return Math.abs(value)>=1e6?(value/1e6).toFixed(1)+"M":Math.abs(value)>=1e3?(value/1e3).toFixed(1)+"K":Math.abs(value)<.01&&0!==value?value.toExponential(1):value%1==0?value.toString():value.toFixed(2)}drawLabels(){this.ctx.fillStyle="#666",this.ctx.font="12px Arial",this.ctx.textAlign="center";const xInterval=this.calculateTickInterval(this.xMin,this.xMax),yInterval=this.calculateTickInterval(this.yMin,this.yMax);for(let x=Math.ceil(this.xMin/xInterval)*xInterval;x<=this.xMax;x+=xInterval){const canvasPos=this.dataToCanvas(x,0);this.ctx.fillText(this.formatTickLabel(x),canvasPos.x,this.plotY+this.plotHeight+20)}this.ctx.textAlign="right";for(let y=Math.ceil(this.yMin/yInterval)*yInterval;y<=this.yMax;y+=yInterval){const canvasPos=this.dataToCanvas(0,y);this.ctx.fillText(this.formatTickLabel(y),this.plotX-10,canvasPos.y+4)}this.ctx.fillStyle="#333",this.ctx.font="14px Arial",this.ctx.textAlign="center",this.ctx.fillText(this.xLabel,this.plotX+this.plotWidth/2,this.displayHeight-5),this.ctx.save(),this.ctx.translate(15,this.plotY+this.plotHeight/2),this.ctx.rotate(-Math.PI/2),this.ctx.fillText(this.yLabel,0,0),this.ctx.restore()}drawDataPoints(){parseFloat(this.alphaSlider.value),parseFloat(this.betaSlider.value);this.ctx.fillStyle="#ff6b6b",this.ctx.strokeStyle="#d63447",this.ctx.lineWidth=2,this.dataPoints.forEach(point=>{const canvasPos=this.dataToCanvas(point.x,point.y);this.ctx.beginPath(),this.ctx.arc(canvasPos.x,canvasPos.y,5,0,2*Math.PI),this.ctx.fill(),this.ctx.stroke()})}drawRegressionLine(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),x1=this.xMin,y1=beta*x1+alpha,x2=this.xMax,y2=beta*x2+alpha,start=this.dataToCanvas(x1,y1),end=this.dataToCanvas(x2,y2);this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath(),this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke()}calculateMSE(alpha,beta){let sumSquaredErrors=0;return this.dataPoints.forEach(point=>{const predicted=beta*point.x+alpha,error=point.y-predicted;sumSquaredErrors+=error*error}),sumSquaredErrors/this.dataPoints.length}calculateMAE(alpha,beta){let sumAbsoluteErrors=0;return this.dataPoints.forEach(point=>{const predicted=beta*point.x+alpha,error=Math.abs(point.y-predicted);sumAbsoluteErrors+=error}),sumAbsoluteErrors/this.dataPoints.length}calculateR2(alpha,beta){if(0===this.dataPoints.length)return 0;const meanY=this.dataPoints.reduce((sum,point)=>sum+point.y,0)/this.dataPoints.length;let tss=0;this.dataPoints.forEach(point=>{const diff=point.y-meanY;tss+=diff*diff});let rss=0;return this.dataPoints.forEach(point=>{const predicted=beta*point.x+alpha,residual=point.y-predicted;rss+=residual*residual}),0===tss?0:1-rss/tss}calculateOptimalValues(){const n=this.dataPoints.length;let sumX=0,sumY=0,sumXY=0,sumXX=0;this.dataPoints.forEach(point=>{sumX+=point.x,sumY+=point.y,sumXY+=point.x*point.y,sumXX+=point.x*point.x});const optimalBeta=(n*sumXY-sumX*sumY)/(n*sumXX-sumX*sumX);return{alpha:(sumY-optimalBeta*sumX)/n,beta:optimalBeta}}setOptimalValues(){const optimal=this.calculateOptimalValues(),clampedAlpha=Math.max(-100,Math.min(200,optimal.alpha)),clampedBeta=Math.max(-10,Math.min(30,optimal.beta));this.alphaSlider.value=Math.round(clampedAlpha).toString(),this.betaSlider.value=clampedBeta.toFixed(1),this.updateDisplay(),this.draw()}generateNewData(){this.clearAllData(),this.generateDataPoints(),this.hideDatasetInfo(),this.updateDisplay(),this.draw()}clearAllData(){this.dataPoints=[],this.xLabel="X",this.yLabel="Y",this.xMin=-10,this.xMax=10,this.yMin=-100,this.yMax=100,this.hideDatasetInfo(),this.updateDisplay(),this.draw()}showDatasetInfo(datasetKey){const dataset=this.datasets[datasetKey];if(!dataset)return;const infoBox=document.getElementById("dataset-info-box"),titleElement=document.getElementById("dataset-info-title"),descriptionElement=document.getElementById("dataset-info-description"),variablesElement=document.getElementById("dataset-info-variables");titleElement.textContent=dataset.title,descriptionElement.textContent=dataset.description,variablesElement.textContent=dataset.variables,infoBox.classList.add("show")}hideDatasetInfo(){const infoBox=document.getElementById("dataset-info-box");infoBox&&infoBox.classList.remove("show")}async loadDataset(datasetKey){const dataset=this.datasets[datasetKey];if(dataset)try{const response=await fetch(dataset.file),lines=(await response.text()).trim().split("\n"),headers=lines[0].split(",").map(h=>h.trim()),xIndex=headers.indexOf(dataset.xColumn),yIndex=headers.indexOf(dataset.yColumn);if(-1===xIndex||-1===yIndex)return void console.error("Column names not found in CSV");const originalData=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(",");if(values.length>1){const x=parseFloat(values[xIndex]),y=parseFloat(values[yIndex]);isNaN(x)||isNaN(y)||originalData.push({x:x,y:y})}}this.dataPoints=originalData,this.xLabel=dataset.xLabel,this.yLabel=dataset.yLabel;const xValues=originalData.map(p=>p.x),yValues=originalData.map(p=>p.y),xRange=Math.max(...xValues)-Math.min(...xValues),yRange=Math.max(...yValues)-Math.min(...yValues),xMargin=.1*xRange,yMargin=.1*yRange;this.xMin=Math.min(...xValues)-xMargin,this.xMax=Math.max(...xValues)+xMargin,this.yMin=Math.min(...yValues)-yMargin,this.yMax=Math.max(...yValues)+yMargin,this.updateDisplay(),this.draw()}catch(error){console.error("Error loading dataset:",error)}}async loadStructuresData(){await this.loadDataset("structures"),this.showDatasetInfo("structures")}async loadGeotechData(){await this.loadDataset("geotech"),this.showDatasetInfo("geotech")}async loadTransportData(){await this.loadDataset("transport"),this.showDatasetInfo("transport")}async loadEnvironmentData(){await this.loadDataset("environment"),this.showDatasetInfo("environment")}handleCanvasClick(event){const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,dataCoords=this.canvasToData(canvasX,canvasY);this.isWithinPlotArea(canvasX,canvasY)&&(this.dataPoints.push({x:dataCoords.x,y:dataCoords.y}),this.updateDisplay(),this.draw())}canvasToData(canvasX,canvasY){return{x:this.xMin+(canvasX-this.plotX)/this.plotWidth*(this.xMax-this.xMin),y:this.yMax-(canvasY-this.plotY)/this.plotHeight*(this.yMax-this.yMin)}}isWithinPlotArea(canvasX,canvasY){return canvasX>=this.plotX&&canvasX<=this.plotX+this.plotWidth&&canvasY>=this.plotY&&canvasY<=this.plotY+this.plotHeight}drawErrorLines(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.ctx.strokeStyle="#777777",this.ctx.lineWidth=1,this.ctx.setLineDash([2,2]),this.dataPoints.forEach(point=>{const predicted=beta*point.x+alpha,pointCanvas=this.dataToCanvas(point.x,point.y),predictedCanvas=this.dataToCanvas(point.x,predicted);this.ctx.beginPath(),this.ctx.moveTo(pointCanvas.x,pointCanvas.y),this.ctx.lineTo(predictedCanvas.x,predictedCanvas.y),this.ctx.stroke()}),this.ctx.setLineDash([])}drawErrorSquares(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.ctx.fillStyle="rgba(255, 107, 107, 0.15)",this.ctx.strokeStyle="rgba(255, 107, 107, 0.25)",this.ctx.lineWidth=1,this.dataPoints.forEach(point=>{const predicted=beta*point.x+alpha,error=point.y-predicted,pointCanvas=(Math.abs(error),this.dataToCanvas(point.x,point.y)),predictedCanvas=this.dataToCanvas(point.x,predicted),squareSizePixels=Math.abs(pointCanvas.y-predictedCanvas.y);if(squareSizePixels>2){let squareX,squareY;error>0?(squareX=predictedCanvas.x,squareY=predictedCanvas.y-squareSizePixels):(squareX=predictedCanvas.x,squareY=predictedCanvas.y),this.ctx.fillRect(squareX,squareY,squareSizePixels,squareSizePixels),this.ctx.strokeRect(squareX,squareY,squareSizePixels,squareSizePixels)}})}drawConfidenceInterval(){if(this.dataPoints.length<3)return;const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),n=this.dataPoints.length,mse=this.calculateMSE(alpha,beta),residualStandardError=Math.sqrt(mse),meanX=this.dataPoints.reduce((sum,point)=>sum+point.x,0)/n,sumXSquaredDeviations=this.dataPoints.reduce((sum,point)=>sum+(point.x-meanX)**2,0);this.ctx.fillStyle="rgba(78, 205, 196, 0.2)",this.ctx.strokeStyle="rgba(78, 205, 196, 0.4)",this.ctx.lineWidth=1,this.ctx.beginPath();const xStep=(this.xMax-this.xMin)/50;let firstPoint=!0;for(let x=this.xMin;x<=this.xMax;x+=xStep){const predicted=beta*x+alpha,margin=2*(residualStandardError*Math.sqrt(1/n+(x-meanX)**2/sumXSquaredDeviations)),upperY=predicted+margin,lowerY=predicted-margin,upperCanvas=this.dataToCanvas(x,upperY);this.dataToCanvas(x,lowerY);firstPoint?(this.ctx.moveTo(upperCanvas.x,upperCanvas.y),firstPoint=!1):this.ctx.lineTo(upperCanvas.x,upperCanvas.y)}for(let x=this.xMax;x>=this.xMin;x-=xStep){const lowerY=beta*x+alpha-2*(residualStandardError*Math.sqrt(1/n+(x-meanX)**2/sumXSquaredDeviations)),lowerCanvas=this.dataToCanvas(x,lowerY);this.ctx.lineTo(lowerCanvas.x,lowerCanvas.y)}this.ctx.closePath(),this.ctx.fill(),this.ctx.stroke()}draw(){this.ctx.clearRect(0,0,this.displayWidth,this.displayHeight),this.ctx.lineCap="round",this.ctx.lineJoin="round",this.drawAxes(),this.showConfidenceCheckbox.checked&&this.drawConfidenceInterval(),this.drawErrorLines(),this.showSquaresCheckbox.checked&&this.drawErrorSquares(),this.drawDataPoints(),this.drawRegressionLine()}}let demoInstance;document.addEventListener("DOMContentLoaded",()=>{demoInstance=new LinearRegressionDemo});