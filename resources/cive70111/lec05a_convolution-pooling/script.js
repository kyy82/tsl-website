class ConvolutionPoolingDemo{constructor(){this.inputCanvas=document.getElementById("input-canvas"),this.convCanvas=document.getElementById("conv-canvas"),this.poolCanvas=document.getElementById("pool-canvas"),this.filterCanvas=document.getElementById("filter-canvas"),this.inputCtx=this.inputCanvas.getContext("2d"),this.convCtx=this.convCanvas.getContext("2d"),this.poolCtx=this.poolCanvas.getContext("2d"),this.filterCtx=this.filterCanvas.getContext("2d"),this.inputSelect=document.getElementById("input-select"),this.filterSelect=document.getElementById("filter-select"),this.poolingSelect=document.getElementById("pooling-select"),this.poolingSizeSlider=document.getElementById("pooling-size"),this.poolingSizeDisplay=document.getElementById("pooling-size-display"),this.filterEditor=document.getElementById("filter-editor"),this.filterInputs=[];for(let i=0;i<3;i++)for(let j=0;j<3;j++)this.filterInputs.push(document.getElementById(`f${i}${j}`));this.inputImage=[],this.currentFilter=[],this.convOutput=[],this.poolOutput=[],this.imageSize=8,this.filterSize=3,this.highlightedCells={input:[],conv:[],pool:[]},this.filters={"edge-vertical":[[-1,0,1],[-2,0,2],[-1,0,1]],"edge-horizontal":[[-1,-2,-1],[0,0,0],[1,2,1]],blur:[[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]],sharpen:[[0,-1,0],[-1,5,-1],[0,-1,0]]},this.inputPatterns={simple:this.createSimplePattern(),"vertical-edges":this.createVerticalEdgePattern(),"horizontal-edges":this.createHorizontalEdgePattern(),checkerboard:this.createCheckerboard(),gradient:this.createGradient()},this.setupEventListeners(),this.setupCanvasInteractivity(),this.initializeDemo()}setupEventListeners(){this.inputSelect.addEventListener("change",()=>this.updateInput()),this.filterSelect.addEventListener("change",()=>this.updateFilter()),this.poolingSelect.addEventListener("change",()=>this.updatePooling()),this.poolingSizeSlider.addEventListener("input",()=>this.updatePoolingSize()),this.filterInputs.forEach(input=>{input.addEventListener("input",()=>this.updateCustomFilter())})}setupCanvasInteractivity(){this.convCanvas.addEventListener("mousemove",e=>{const rect=this.convCanvas.getBoundingClientRect(),x=e.clientX-rect.left,y=e.clientY-rect.top;this.handleConvolutionHover(x,y)}),this.convCanvas.addEventListener("mouseleave",()=>{this.clearHighlighting()}),this.poolCanvas.addEventListener("mousemove",e=>{const rect=this.poolCanvas.getBoundingClientRect(),x=e.clientX-rect.left,y=e.clientY-rect.top;this.handlePoolingHover(x,y)}),this.poolCanvas.addEventListener("mouseleave",()=>{this.clearHighlighting()})}handleConvolutionHover(x,y){if(!this.convOutput||0===this.convOutput.length)return;const convSize=this.convOutput.length,cellWidth=this.convCanvas.width/convSize,cellHeight=this.convCanvas.height/convSize,col=Math.floor(x/cellWidth),row=Math.floor(y/cellHeight);if(row>=0&&row<convSize&&col>=0&&col<convSize){this.clearHighlighting(),this.highlightedCells.conv=[{row:row,col:col}],this.highlightedCells.input=[];for(let i=0;i<this.filterSize;i++)for(let j=0;j<this.filterSize;j++)this.highlightedCells.input.push({row:row+i,col:col+j});this.updateVisualization()}}handlePoolingHover(x,y){if(!this.poolOutput||0===this.poolOutput.length)return;const poolSize=this.poolOutput.length,cellWidth=this.poolCanvas.width/poolSize,cellHeight=this.poolCanvas.height/poolSize,col=Math.floor(x/cellWidth),row=Math.floor(y/cellHeight);if(row>=0&&row<poolSize&&col>=0&&col<poolSize){this.clearHighlighting(),this.highlightedCells.pool=[{row:row,col:col}];const poolingSize=parseInt(this.poolingSizeSlider.value);this.highlightedCells.conv=[];for(let i=0;i<poolingSize;i++)for(let j=0;j<poolingSize;j++){const convRow=row*poolingSize+i,convCol=col*poolingSize+j;convRow<this.convOutput.length&&convCol<this.convOutput[0].length&&this.highlightedCells.conv.push({row:convRow,col:convCol})}this.updateVisualization()}}clearHighlighting(){this.highlightedCells.input=[],this.highlightedCells.conv=[],this.highlightedCells.pool=[],this.updateVisualization()}initializeDemo(){this.currentFilter=this.filters["edge-vertical"],this.updateInput(),this.updateFilter(),this.updatePoolingSize(),this.performConvolution(),this.performPooling(),this.updateVisualization()}createSimplePattern(){const pattern=[];for(let i=0;i<this.imageSize;i++){pattern[i]=[];for(let j=0;j<this.imageSize;j++)i===Math.floor(this.imageSize/2)||j===Math.floor(this.imageSize/2)?pattern[i][j]=1:pattern[i][j]=0}return pattern}createVerticalEdgePattern(){const pattern=[];for(let i=0;i<this.imageSize;i++){pattern[i]=[];for(let j=0;j<this.imageSize;j++)j<this.imageSize/2?pattern[i][j]=0:pattern[i][j]=1}return pattern}createHorizontalEdgePattern(){const pattern=[];for(let i=0;i<this.imageSize;i++){pattern[i]=[];for(let j=0;j<this.imageSize;j++)i<this.imageSize/2?pattern[i][j]=0:pattern[i][j]=1}return pattern}createCheckerboard(){const pattern=[];for(let i=0;i<this.imageSize;i++){pattern[i]=[];for(let j=0;j<this.imageSize;j++)pattern[i][j]=(i+j)%2}return pattern}createGradient(){const pattern=[];for(let i=0;i<this.imageSize;i++){pattern[i]=[];for(let j=0;j<this.imageSize;j++)pattern[i][j]=j/(this.imageSize-1)}return pattern}updateInput(){const selectedPattern=this.inputSelect.value;this.inputImage=this.inputPatterns[selectedPattern],this.performConvolution(),this.performPooling(),this.updateVisualization()}updateFilter(){const selectedFilter=this.filterSelect.value;"custom"===selectedFilter?(this.filterEditor.style.display="block",this.updateCustomFilter()):(this.filterEditor.style.display="none",this.currentFilter=this.filters[selectedFilter]),this.performConvolution(),this.performPooling(),this.updateVisualization()}updateCustomFilter(){this.currentFilter=[];for(let i=0;i<3;i++){this.currentFilter[i]=[];for(let j=0;j<3;j++){const input=this.filterInputs[3*i+j];this.currentFilter[i][j]=parseFloat(input.value)||0}}"custom"===this.filterSelect.value&&(this.performConvolution(),this.performPooling(),this.updateVisualization())}updatePooling(){this.performPooling(),this.updateVisualization()}updatePoolingSize(){const size=parseInt(this.poolingSizeSlider.value);this.poolingSizeDisplay.textContent=`${size}Ã—${size}`,this.performPooling(),this.updateVisualization()}performConvolution(){if(!this.currentFilter||!this.inputImage)return;const inputSize=this.imageSize,filterSize=this.filterSize,outputSize=inputSize-filterSize+1;this.convOutput=[];for(let i=0;i<outputSize;i++){this.convOutput[i]=[];for(let j=0;j<outputSize;j++){let sum=0;for(let fi=0;fi<filterSize;fi++)for(let fj=0;fj<filterSize;fj++){const inputRow=i+fi,inputCol=j+fj;sum+=this.inputImage[inputRow][inputCol]*this.currentFilter[fi][fj]}this.convOutput[i][j]=sum}}}performPooling(){if(!this.convOutput||0===this.convOutput.length)return;const poolSize=parseInt(this.poolingSizeSlider.value),poolType=this.poolingSelect.value,inputSize=this.convOutput.length,outputSize=Math.floor(inputSize/poolSize);this.poolOutput=[];for(let i=0;i<outputSize;i++){this.poolOutput[i]=[];for(let j=0;j<outputSize;j++){const values=[];for(let pi=0;pi<poolSize;pi++)for(let pj=0;pj<poolSize;pj++){const row=i*poolSize+pi,col=j*poolSize+pj;row<inputSize&&col<inputSize&&values.push(this.convOutput[row][col])}if("max"===poolType)this.poolOutput[i][j]=Math.max(...values);else{const sum=values.reduce((a,b)=>a+b,0);this.poolOutput[i][j]=sum/values.length}}}}updateVisualization(){this.drawMatrix(this.inputCtx,this.inputImage,this.inputCanvas.width,this.inputCanvas.height,this.highlightedCells.input,-5,5),this.drawMatrix(this.convCtx,this.convOutput,this.convCanvas.width,this.convCanvas.height,this.highlightedCells.conv,-5,5),this.drawMatrix(this.poolCtx,this.poolOutput,this.poolCanvas.width,this.poolCanvas.height,this.highlightedCells.pool,-5,5),this.drawFilter(this.filterCtx,this.currentFilter,this.filterCanvas.width,this.filterCanvas.height,-5,5)}valueToColor(value,minVal=-5,maxVal=5){const clampedValue=Math.max(minVal,Math.min(maxVal,value));if(0===clampedValue)return"rgb(255, 255, 255)";if(clampedValue<0){const x=Math.abs(clampedValue),intensity=1/Math.log(4)*Math.log(1+x),targetRed=216.75,targetGreen=82.875,targetBlue=.098*255;return`rgb(${Math.floor(255*(1-intensity)+targetRed*intensity)}, ${Math.floor(255*(1-intensity)+targetGreen*intensity)}, ${Math.floor(255*(1-intensity)+targetBlue*intensity)})`}{const x=clampedValue,intensity=1/Math.log(4)*Math.log(1+x),targetRed=0,targetGreen=113.985,targetBlue=.741*255;return`rgb(${Math.floor(255*(1-intensity)+targetRed*intensity)}, ${Math.floor(255*(1-intensity)+targetGreen*intensity)}, ${Math.floor(255*(1-intensity)+targetBlue*intensity)})`}}getTextColor(value,minVal=-5,maxVal=5){const clampedValue=Math.max(minVal,Math.min(maxVal,value));return Math.abs(clampedValue)/Math.max(Math.abs(minVal),Math.abs(maxVal))<.5?"#000":"#fff"}drawMatrix(ctx,matrix,width,height,highlightedCells=[],globalMin=null,globalMax=null){if(!matrix||0===matrix.length)return;ctx.clearRect(0,0,width,height);const rows=matrix.length,cols=matrix[0].length,cellWidth=width/cols,cellHeight=height/rows;let minVal,maxVal;if(null!==globalMin&&null!==globalMax)minVal=globalMin,maxVal=globalMax;else{minVal=1/0,maxVal=-1/0;for(let i=0;i<rows;i++)for(let j=0;j<cols;j++)minVal=Math.min(minVal,matrix[i][j]),maxVal=Math.max(maxVal,matrix[i][j])}const highlightSet=new Set;highlightedCells.forEach(cell=>{highlightSet.add(`${cell.row},${cell.col}`)});for(let i=0;i<rows;i++)for(let j=0;j<cols;j++){const value=matrix[i][j];ctx.fillStyle=this.valueToColor(value,minVal,maxVal),ctx.fillRect(j*cellWidth,i*cellHeight,cellWidth,cellHeight),ctx.strokeStyle="#333",ctx.lineWidth=1,ctx.strokeRect(j*cellWidth,i*cellHeight,cellWidth,cellHeight);const textColor=this.getTextColor(value,minVal,maxVal);ctx.fillStyle=textColor,ctx.font=.3*Math.min(cellWidth,cellHeight)+"px Arial",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(value.toFixed(1),j*cellWidth+cellWidth/2,i*cellHeight+cellHeight/2)}highlightedCells.length>0&&this.drawHighlightOutline(ctx,highlightedCells,cellWidth,cellHeight)}drawHighlightOutline(ctx,highlightedCells,cellWidth,cellHeight){const highlightSet=new Set;highlightedCells.forEach(cell=>{highlightSet.add(`${cell.row},${cell.col}`)}),ctx.strokeStyle="#ff0000",ctx.lineWidth=2,highlightedCells.forEach(cell=>{const{row:row,col:col}=cell,x=col*cellWidth,y=row*cellHeight;highlightSet.has(`${row-1},${col}`)||(ctx.beginPath(),ctx.moveTo(x,y),ctx.lineTo(x+cellWidth,y),ctx.stroke()),highlightSet.has(`${row},${col+1}`)||(ctx.beginPath(),ctx.moveTo(x+cellWidth,y),ctx.lineTo(x+cellWidth,y+cellHeight),ctx.stroke()),highlightSet.has(`${row+1},${col}`)||(ctx.beginPath(),ctx.moveTo(x,y+cellHeight),ctx.lineTo(x+cellWidth,y+cellHeight),ctx.stroke()),highlightSet.has(`${row},${col-1}`)||(ctx.beginPath(),ctx.moveTo(x,y),ctx.lineTo(x,y+cellHeight),ctx.stroke())})}drawFilter(ctx,filter,width,height,minVal=-5,maxVal=5){if(!filter)return;ctx.clearRect(0,0,width,height);const cellWidth=width/3,cellHeight=height/3;for(let i=0;i<3;i++)for(let j=0;j<3;j++){const value=filter[i][j];ctx.fillStyle=this.valueToColor(value,minVal,maxVal),ctx.fillRect(j*cellWidth,i*cellHeight,cellWidth,cellHeight),ctx.strokeStyle="#000",ctx.lineWidth=2,ctx.strokeRect(j*cellWidth,i*cellHeight,cellWidth,cellHeight),ctx.fillStyle=this.getTextColor(value,minVal,maxVal),ctx.font=.25*Math.min(cellWidth,cellHeight)+"px Arial",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(value.toFixed(2),j*cellWidth+cellWidth/2,i*cellHeight+cellHeight/2)}}}document.addEventListener("DOMContentLoaded",()=>{new DemoTabController,new ConvolutionPoolingDemo});