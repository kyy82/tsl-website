class GradientDescentDemo{constructor(){this.dataCanvas=document.getElementById("dataCanvas"),this.costCanvas=document.getElementById("costCanvas"),this.dataCtx=this.dataCanvas.getContext("2d"),this.costCtx=this.costCanvas.getContext("2d"),this.datasetSelect=document.getElementById("datasetSelect"),this.alpha0Input=document.getElementById("alpha0"),this.beta0Input=document.getElementById("beta0"),this.etaInput=document.getElementById("eta"),this.stepBtn=document.getElementById("stepBtn"),this.resetBtn=document.getElementById("resetBtn"),this.showCaptionsCheck=document.getElementById("showCaptions"),this.iterOut=document.getElementById("iter"),this.alphaOut=document.getElementById("alphaOut"),this.betaOut=document.getElementById("betaOut"),this.jOut=document.getElementById("jOut"),this.gradNormOut=document.getElementById("gradNormOut"),this.captionText=document.getElementById("captionText"),this.state={alpha:0,beta:0,eta:.01,iter:0,history:[]},this.datasets={sample:{data:[{x:1,y:2.2},{x:2,y:3.8},{x:3,y:5.1},{x:4,y:6.9},{x:5,y:8.2},{x:6,y:9.8},{x:7,y:11.1}],optimal:{alpha:1.4,beta:.8}},structures:{file:"example-data/structures_concrete.csv",xColumn:"Cement_kg_per_m3",yColumn:"Compressive_Strength_MPa",optimal:{alpha:0,beta:0}},geotech:{file:"example-data/geotechnics_soil.csv",xColumn:"Sand_Percent",yColumn:"Uniformity_Coefficient",optimal:{alpha:0,beta:0}},transport:{file:"example-data/transport_traffic.csv",xColumn:"Vehicle_Count",yColumn:"Vehicle_Speed_kmh",optimal:{alpha:0,beta:0}},environment:{file:"example-data/environment_wastewater.csv",xColumn:"Inflow_m3_s",yColumn:"Energy_Consumption_MWh",optimal:{alpha:0,beta:0}}},this.normStats={xMean:0,xStd:1,yMean:0,yStd:1},this.costGrid=null,this.gridBounds={alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2,resolution:100},this.setupHighDPICanvas(),this.setupEventListeners(),this.tabController=new DemoTabController,this.setRandomInitialValues(),this.loadSampleDataset()}setupHighDPICanvas(){const dpr=window.devicePixelRatio||1,dataRect=this.dataCanvas.getBoundingClientRect();this.dataCanvas.width=dataRect.width*dpr,this.dataCanvas.height=400*dpr,this.dataCanvas.style.width=dataRect.width+"px",this.dataCanvas.style.height="400px",this.dataCtx.scale(dpr,dpr);const costRect=this.costCanvas.getBoundingClientRect();this.costCanvas.width=costRect.width*dpr,this.costCanvas.height=400*dpr,this.costCanvas.style.width=costRect.width+"px",this.costCanvas.style.height="400px",this.costCtx.scale(dpr,dpr),this.dataWidth=dataRect.width,this.dataHeight=400,this.costWidth=costRect.width,this.costHeight=400}setupEventListeners(){this.datasetSelect.addEventListener("change",e=>{const selectedValue=e.target.value;"sample"===selectedValue?this.loadSampleDataset():this.loadDataset(selectedValue)}),this.alpha0Input.addEventListener("change",()=>this.reset()),this.beta0Input.addEventListener("change",()=>this.reset()),this.etaInput.addEventListener("change",()=>this.reset()),this.stepBtn.addEventListener("click",()=>this.step()),this.resetBtn.addEventListener("click",()=>this.reset()),this.showCaptionsCheck.addEventListener("change",()=>{this.showCaptionsCheck.checked?this.captionText.classList.add("show"):this.captionText.classList.remove("show")})}updateGridBounds(datasetKey){const bounds={sample:{alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2},structures:{alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2},geotech:{alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2},transport:{alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2},environment:{alphaMin:-2,alphaMax:2,betaMin:-2,betaMax:2}},datasetBounds=bounds[datasetKey]||bounds.sample;this.gridBounds={alphaMin:datasetBounds.alphaMin,alphaMax:datasetBounds.alphaMax,betaMin:datasetBounds.betaMin,betaMax:datasetBounds.betaMax,resolution:100}}getDataBounds(datasetKey){const bounds={sample:{xMin:-3,xMax:3,yMin:-3,yMax:3},structures:{xMin:-3,xMax:3,yMin:-3,yMax:3},geotech:{xMin:-3,xMax:3,yMin:-3,yMax:3},transport:{xMin:-3,xMax:3,yMin:-3,yMax:3},environment:{xMin:-3,xMax:3,yMin:-3,yMax:3}};return bounds[datasetKey]||bounds.sample}getDefaultLearningRate(datasetKey){const rates={sample:.1,structures:.1,geotech:.1,transport:.1,environment:.1};return rates[datasetKey]||rates.sample}setRandomInitialValues(){const randomAlpha=4*(Math.random()-.5),randomBeta=4*(Math.random()-.5);this.alpha0Input.value=randomAlpha.toFixed(1),this.beta0Input.value=randomBeta.toFixed(1)}normalizeData(data){const xMean=data.reduce((sum,point)=>sum+point.x,0)/data.length,yMean=data.reduce((sum,point)=>sum+point.y,0)/data.length,xVariance=data.reduce((sum,point)=>sum+Math.pow(point.x-xMean,2),0)/data.length,yVariance=data.reduce((sum,point)=>sum+Math.pow(point.y-yMean,2),0)/data.length,xStd=Math.sqrt(xVariance),yStd=Math.sqrt(yVariance);return this.normStats={xMean:xMean,xStd:xStd,yMean:yMean,yStd:yStd},data.map(point=>({x:(point.x-xMean)/xStd,y:(point.y-yMean)/yStd}))}calculateOptimalSolution(data){const n=data.length;let sumX=0,sumY=0,sumXY=0,sumXX=0;for(const{x:x,y:y}of data)sumX+=x,sumY+=y,sumXY+=x*y,sumXX+=x*x;const denominator=n*sumXX-sumX*sumX;if(Math.abs(denominator)<1e-10)return{alpha:0,beta:0};const beta=(n*sumXY-sumX*sumY)/denominator;return{alpha:(sumY-beta*sumX)/n,beta:beta}}loadSampleDataset(){const rawData=this.datasets.sample.data;this.dataset=this.normalizeData(rawData);const optimal=this.calculateOptimalSolution(this.dataset);this.datasets.sample.optimal=optimal,this.currentDatasetKey="sample",this.updateGridBounds("sample"),this.setRandomInitialValues();const defaultEta=this.getDefaultLearningRate("sample");this.etaInput.value=defaultEta,this.initialize()}async loadDataset(datasetKey){const datasetConfig=this.datasets[datasetKey];if(datasetConfig&&datasetConfig.file)try{const response=await fetch(datasetConfig.file),lines=(await response.text()).trim().split("\n"),headers=lines[0].split(",").map(h=>h.trim()),xIndex=headers.indexOf(datasetConfig.xColumn),yIndex=headers.indexOf(datasetConfig.yColumn);if(-1===xIndex||-1===yIndex)return void console.error("Column names not found in CSV");const data=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(",");if(values.length>1){const x=parseFloat(values[xIndex]),y=parseFloat(values[yIndex]);isNaN(x)||isNaN(y)||data.push({x:x,y:y})}}const normalizedData=this.normalizeData(data);this.dataset=normalizedData;const optimal=this.calculateOptimalSolution(normalizedData);this.datasets[datasetKey].optimal=optimal,this.currentDatasetKey=datasetKey,this.updateGridBounds(datasetKey),this.setRandomInitialValues();const defaultEta=this.getDefaultLearningRate(datasetKey);this.etaInput.value=defaultEta,this.initialize()}catch(error){console.error("Error loading dataset:",error)}}initialize(){this.state.alpha=parseFloat(this.alpha0Input.value)||0,this.state.beta=parseFloat(this.beta0Input.value)||0,this.state.eta=parseFloat(this.etaInput.value)||.1,this.state.iter=0,this.state.history=[{alpha:this.state.alpha,beta:this.state.beta,J:this.costJ(this.state.alpha,this.state.beta)}],this.computeCostGrid(),this.updateReadouts(),this.render(),this.showCaptionsCheck.checked&&(this.captionText.textContent='Ready to start gradient descent. Click "Step" to begin.',this.captionText.classList.add("show")),this.stepBtn.disabled=!1}costJ(alpha,beta){const n=this.dataset.length;let sum=0;for(const{x:x,y:y}of this.dataset){const residual=alpha+beta*x-y;sum+=residual*residual}return sum/(2*n)}gradients(alpha,beta){const n=this.dataset.length;let dAlpha=0,dBeta=0;for(const{x:x,y:y}of this.dataset){const residual=alpha+beta*x-y;dAlpha+=residual,dBeta+=residual*x}return{dAlpha:dAlpha/n,dBeta:dBeta/n}}step(){const{dAlpha:dAlpha,dBeta:dBeta}=this.gradients(this.state.alpha,this.state.beta),oldAlpha=this.state.alpha,oldBeta=this.state.beta,oldJ=this.costJ(oldAlpha,oldBeta);this.state.alpha=this.state.alpha-this.state.eta*dAlpha,this.state.beta=this.state.beta-this.state.eta*dBeta,this.state.iter++;const newJ=this.costJ(this.state.alpha,this.state.beta);if(this.state.history.push({alpha:this.state.alpha,beta:this.state.beta,J:newJ}),this.updateReadouts(),this.showCaptionsCheck.checked){Math.sqrt(dAlpha*dAlpha+dBeta*dBeta);this.captionText.textContent=newJ>1.5*oldJ?`Warning: Cost increased from ${oldJ.toFixed(3)} to ${newJ.toFixed(3)}. Learning rate might be too large.`:`Step ${this.state.iter}: Updated α: ${oldAlpha.toFixed(3)} → ${this.state.alpha.toFixed(3)}, β: ${oldBeta.toFixed(3)} → ${this.state.beta.toFixed(3)}. Cost: ${oldJ.toFixed(3)} → ${newJ.toFixed(3)}`}this.render()}reset(){this.setRandomInitialValues(),this.initialize()}computeCostGrid(){const{alphaMin:alphaMin,alphaMax:alphaMax,betaMin:betaMin,betaMax:betaMax,resolution:resolution}=this.gridBounds;this.costGrid=[];for(let i=0;i<resolution;i++){const row=[];for(let j=0;j<resolution;j++){const alpha=alphaMin+(alphaMax-alphaMin)*i/(resolution-1),beta=betaMin+(betaMax-betaMin)*j/(resolution-1);row.push(this.costJ(alpha,beta))}this.costGrid.push(row)}}updateReadouts(){const{dAlpha:dAlpha,dBeta:dBeta}=this.gradients(this.state.alpha,this.state.beta),gradNorm=Math.sqrt(dAlpha*dAlpha+dBeta*dBeta);this.iterOut.textContent=this.state.iter,this.alphaOut.textContent=this.state.alpha.toFixed(3),this.betaOut.textContent=this.state.beta.toFixed(3),this.jOut.textContent=this.costJ(this.state.alpha,this.state.beta).toFixed(3),this.gradNormOut.textContent=gradNorm.toFixed(3)}render(){this.renderDataView(),this.renderCostView()}renderDataView(){const ctx=this.dataCtx,width=this.dataWidth,height=this.dataHeight;ctx.clearRect(0,0,width,height);const dataBounds=this.getDataBounds(this.currentDatasetKey),xMin=dataBounds.xMin,xMax=dataBounds.xMax,yMin=dataBounds.yMin,yMax=dataBounds.yMax,xScale=x=>40+(x-xMin)/(xMax-xMin)*(width-80),yScale=y=>height-40-(y-yMin)/(yMax-yMin)*(height-80);ctx.strokeStyle="#333",ctx.lineWidth=2,ctx.beginPath(),ctx.moveTo(40,height-40),ctx.lineTo(width-40,height-40),ctx.moveTo(40,40),ctx.lineTo(40,height-40),ctx.stroke(),ctx.strokeStyle="#e0e0e0",ctx.lineWidth=1;for(let i=0;i<=5;i++){const x=40+i*(width-80)/5,y=40+i*(height-80)/5;ctx.beginPath(),ctx.moveTo(x,40),ctx.lineTo(x,height-40),ctx.stroke(),ctx.beginPath(),ctx.moveTo(40,y),ctx.lineTo(width-40,y),ctx.stroke()}ctx.fillStyle="#666",ctx.font="12px Arial",ctx.textAlign="center",ctx.fillText("x (normalized)",width/2,height-10),ctx.save(),ctx.translate(15,height/2),ctx.rotate(-Math.PI/2),ctx.fillText("y (normalized)",0,0),ctx.restore(),ctx.font="10px Arial";for(let i=0;i<=5;i++){const xVal=xMin+i*(xMax-xMin)/5,yVal=yMin+i*(yMax-yMin)/5;ctx.textAlign="center",ctx.fillText(xVal.toFixed(1),xScale(xVal),height-40+15),ctx.textAlign="right",ctx.fillText(yVal.toFixed(1),35,yScale(yVal)+3)}const lineY1=this.state.alpha+this.state.beta*xMin,lineY2=this.state.alpha+this.state.beta*xMax;ctx.strokeStyle="#4ecdc4",ctx.lineWidth=3,ctx.beginPath(),ctx.moveTo(xScale(xMin),yScale(lineY1)),ctx.lineTo(xScale(xMax),yScale(lineY2)),ctx.stroke(),ctx.strokeStyle="#ff6b6b",ctx.lineWidth=1,ctx.setLineDash([5,5]);for(const{x:x,y:y}of this.dataset){const predicted=this.state.alpha+this.state.beta*x;ctx.beginPath(),ctx.moveTo(xScale(x),yScale(y)),ctx.lineTo(xScale(x),yScale(predicted)),ctx.stroke()}ctx.setLineDash([]),ctx.fillStyle="#ff6b6b",ctx.strokeStyle="#d63447",ctx.lineWidth=2;for(const{x:x,y:y}of this.dataset)ctx.beginPath(),ctx.arc(xScale(x),yScale(y),5,0,2*Math.PI),ctx.fill(),ctx.stroke()}renderCostView(){const ctx=this.costCtx,width=this.costWidth,height=this.costHeight;ctx.clearRect(0,0,width,height);const{alphaMin:alphaMin,alphaMax:alphaMax,betaMin:betaMin,betaMax:betaMax,resolution:resolution}=this.gridBounds,xScale=alpha=>40+(alpha-alphaMin)/(alphaMax-alphaMin)*(width-80),yScale=beta=>height-40-(beta-betaMin)/(betaMax-betaMin)*(height-80);if(ctx.strokeStyle="#333",ctx.lineWidth=2,ctx.beginPath(),ctx.moveTo(40,height-40),ctx.lineTo(width-40,height-40),ctx.moveTo(40,40),ctx.lineTo(40,height-40),ctx.stroke(),ctx.fillStyle="#666",ctx.font="12px Arial",ctx.textAlign="center",ctx.fillText("α (normalized intercept)",width/2,height-10),ctx.save(),ctx.translate(15,height/2),ctx.rotate(-Math.PI/2),ctx.fillText("β (normalized slope)",0,0),ctx.restore(),this.costGrid){const cellWidth=(width-80)/resolution,cellHeight=(height-80)/resolution;let minCost=1/0,maxCost=-1/0;for(let i=0;i<resolution;i++)for(let j=0;j<resolution;j++){const cost=this.costGrid[i][j];minCost=Math.min(minCost,cost),maxCost=Math.max(maxCost,cost)}for(let i=0;i<resolution;i++)for(let j=0;j<resolution;j++){const normalized=(this.costGrid[i][j]-minCost)/(maxCost-minCost),r=Math.floor(255*normalized),g=Math.floor(100*(1-normalized)),b=Math.floor(255*(1-normalized));ctx.fillStyle=`rgb(${r}, ${g}, ${b})`,ctx.fillRect(40+i*cellWidth,40+(resolution-1-j)*cellHeight,cellWidth+1,cellHeight+1)}ctx.strokeStyle="rgba(255, 255, 255, 0.3)",ctx.lineWidth=1;const numContours=10;for(let c=1;c<numContours;c++){const threshold=minCost+(maxCost-minCost)*c/numContours;for(let i=0;i<resolution-1;i++)for(let j=0;j<resolution-1;j++){const v00=this.costGrid[i][j],v10=this.costGrid[i+1][j],v01=this.costGrid[i][j+1],v11=this.costGrid[i+1][j+1];if([v00<threshold&&v10>=threshold||v00>=threshold&&v10<threshold,v10<threshold&&v11>=threshold||v10>=threshold&&v11<threshold,v11<threshold&&v01>=threshold||v11>=threshold&&v01<threshold,v01<threshold&&v00>=threshold||v01>=threshold&&v00<threshold].some(c=>c)){const alpha=alphaMin+(alphaMax-alphaMin)*(i+.5)/(resolution-1),beta=betaMin+(betaMax-betaMin)*(j+.5)/(resolution-1);ctx.beginPath(),ctx.arc(xScale(alpha),yScale(beta),1,0,2*Math.PI),ctx.fill()}}}}if(this.state.history.length>1){ctx.strokeStyle="rgba(255, 255, 0, 0.8)",ctx.lineWidth=2,ctx.beginPath();for(let i=0;i<this.state.history.length;i++){const{alpha:alpha,beta:beta}=this.state.history[i];0===i?ctx.moveTo(xScale(alpha),yScale(beta)):ctx.lineTo(xScale(alpha),yScale(beta))}ctx.stroke(),ctx.fillStyle="rgba(255, 255, 0, 0.6)";for(let i=0;i<this.state.history.length-1;i++){const{alpha:alpha,beta:beta}=this.state.history[i];ctx.beginPath(),ctx.arc(xScale(alpha),yScale(beta),3,0,2*Math.PI),ctx.fill()}}ctx.fillStyle="#ff0000",ctx.strokeStyle="#ffffff",ctx.lineWidth=2,ctx.beginPath(),ctx.arc(xScale(this.state.alpha),yScale(this.state.beta),6,0,2*Math.PI),ctx.fill(),ctx.stroke(),ctx.fillStyle="#666",ctx.font="10px Arial";for(let i=0;i<=5;i++){const alphaVal=alphaMin+i*(alphaMax-alphaMin)/5,betaVal=betaMin+i*(betaMax-betaMin)/5;ctx.textAlign="center",ctx.fillText(alphaVal.toFixed(1),xScale(alphaVal),height-40+15),ctx.textAlign="right",ctx.fillText(betaVal.toFixed(1),35,yScale(betaVal)+3)}}}document.addEventListener("DOMContentLoaded",()=>{new GradientDescentDemo});