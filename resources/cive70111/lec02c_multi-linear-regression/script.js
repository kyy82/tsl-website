class MultiLinearRegressionDemo{constructor(){this.predictionCanvas=document.getElementById("prediction-plot"),this.predictionCtx=this.predictionCanvas.getContext("2d"),this.areaFeature=document.getElementById("area-feature"),this.bedroomsFeature=document.getElementById("bedrooms-feature"),this.bathroomsFeature=document.getElementById("bathrooms-feature"),this.storiesFeature=document.getElementById("stories-feature"),this.mseValue=document.getElementById("mse-value"),this.maeValue=document.getElementById("mae-value"),this.r2Value=document.getElementById("r2-value"),this.trainData=[],this.testData=[],this.model=null,this.features=["area","bedrooms","bathrooms","stories"],this.featureStats={},this.setupHighDPICanvas(this.predictionCanvas,this.predictionCtx),this.loadData(),this.setupEventListeners(),this.updateDisplay()}setupHighDPICanvas(t,e){const i=t.getBoundingClientRect(),a=window.devicePixelRatio||1;t.width=i.width*a,t.height=i.height*a,t.style.width=i.width+"px",t.style.height=i.height+"px",e.scale(a,a),this.displayWidth=i.width,this.displayHeight=i.height}async loadData(){try{const[t,e]=await Promise.all([fetch("data/train.csv"),fetch("data/test.csv")]),i=await t.text(),a=await e.text();this.trainData=this.parseCSV(i),this.testData=this.parseCSV(a),console.log(`Loaded ${this.trainData.length} training samples and ${this.testData.length} test samples`),this.calculatePriceStats(),this.onFeatureSelectionChange()}catch(t){console.error("Error loading data:",t)}}parseCSV(t){const e=t.trim().split("\n"),i=e[0].split(","),a=[];for(let t=1;t<e.length;t++){const s=e[t].split(","),r={};i.forEach((t,e)=>{r[t]=parseFloat(s[e])}),a.push(r)}return a}calculatePriceStats(){const t=this.trainData.map(t=>t.price),e=t.reduce((t,e)=>t+e,0)/t.length,i=t.reduce((t,i)=>t+Math.pow(i-e,2),0)/t.length,a=Math.sqrt(i);this.priceStats={mean:e,std:a}}normalizePrice(t){return this.priceStats.std>0?(t-this.priceStats.mean)/this.priceStats.std:0}denormalizePrice(t){return t*this.priceStats.std+this.priceStats.mean}setupEventListeners(){[this.areaFeature,this.bedroomsFeature,this.bathroomsFeature,this.storiesFeature].forEach(t=>{t.addEventListener("change",()=>this.onFeatureSelectionChange())})}onFeatureSelectionChange(){this.getSelectedFeatures().length>0?this.trainModel():this.resetModel()}getSelectedFeatures(){const t=[];return this.areaFeature.checked&&t.push("area"),this.bedroomsFeature.checked&&t.push("bedrooms"),this.bathroomsFeature.checked&&t.push("bathrooms"),this.storiesFeature.checked&&t.push("stories"),t}prepareFeatureMatrix(t,e){const i=t.length,a=e.length+1,s=Array(i).fill(null).map(()=>Array(a).fill(0));for(let a=0;a<i;a++)s[a][0]=1,e.forEach((e,i)=>{s[a][i+1]=t[a][e]});return s}trainModel(){const t=this.getSelectedFeatures();if(0===t.length)return;const e=this.prepareFeatureMatrix(this.trainData,t),i=this.trainData.map(t=>this.normalizePrice(t.price));try{const a=this.matrixMultiply(this.matrixTranspose(e),e),s=this.matrixInverse(a),r=this.matrixVectorMultiply(this.matrixTranspose(e),i),l=this.matrixVectorMultiply(s,r);this.model={theta:l,selectedFeatures:t},this.evaluateModel(),this.updateDisplay(),this.renderPlots()}catch(t){console.error("Error training model:",t),alert("Error training model. Try selecting different features or normalization settings.")}}evaluateModel(){if(!this.model)return;const t=this.prepareFeatureMatrix(this.testData,this.model.selectedFeatures),e=this.testData.map(t=>this.normalizePrice(t.price)),i=t.map(t=>this.model.theta.reduce((e,i,a)=>e+i*t[a],0)),a=this.testData.map(t=>t.price),s=i.map(t=>this.denormalizePrice(t)),r=e.length,l=e.reduce((t,e,a)=>t+Math.pow(e-i[a],2),0)/r,h=e.reduce((t,e,a)=>t+Math.abs(e-i[a]),0)/r,o=e.reduce((t,e)=>t+e,0)/r,n=e.reduce((t,e)=>t+Math.pow(e-o,2),0),c=1-e.reduce((t,e,a)=>t+Math.pow(e-i[a],2),0)/n;this.model.metrics={mse:l,mae:h,r2:c},this.model.predictions=s,this.model.actual=a}resetModel(){this.model=null,this.updateDisplay(),this.clearPlots()}updateDisplay(){this.model?(this.mseValue.textContent=this.model.metrics.mse.toFixed(3),this.maeValue.textContent=this.model.metrics.mae.toFixed(3),this.r2Value.textContent=this.model.metrics.r2.toFixed(3)):(this.mseValue.textContent="-",this.maeValue.textContent="-",this.r2Value.textContent="-")}renderPlots(){this.model&&this.renderPredictionPlot()}renderPredictionPlot(){const t=this.predictionCtx,e=this.displayWidth,i=this.displayHeight;t.clearRect(0,0,e,i);const a=this.model.actual,s=this.model.predictions,r=[...a,...s],l=Math.min(...r),h=Math.max(...r),o=.1*(h-l),n=l-o,c=h+o,d=50,m=e-100,u=i-100;t.strokeStyle="#ddd",t.lineWidth=1,t.beginPath(),t.moveTo(d,d),t.lineTo(d,i-d),t.lineTo(e-d,i-d),t.stroke(),t.strokeStyle="#e74c3c",t.lineWidth=2,t.setLineDash([5,5]),t.beginPath(),t.moveTo(d,i-d),t.lineTo(e-d,d),t.stroke(),t.setLineDash([]),t.fillStyle="#3498db";for(let e=0;e<a.length;e++){const r=d+(s[e]-n)/(c-n)*m,l=i-d-(a[e]-n)/(c-n)*u;t.beginPath(),t.arc(r,l,4,0,2*Math.PI),t.fill()}t.fillStyle="#2c3e50",t.font="12px Arial",t.textAlign="center",t.fillText("Predicted Price",e/2,i-10),t.save(),t.translate(15,i/2),t.rotate(-Math.PI/2),t.fillText("Actual Price",0,0),t.restore()}clearPlots(){this.predictionCtx.clearRect(0,0,this.displayWidth,this.displayHeight)}matrixMultiply(t,e){const i=Array(t.length).fill(null).map(()=>Array(e[0].length).fill(0));for(let a=0;a<t.length;a++)for(let s=0;s<e[0].length;s++)for(let r=0;r<e.length;r++)i[a][s]+=t[a][r]*e[r][s];return i}matrixTranspose(t){return t[0].map((e,i)=>t.map(t=>t[i]))}matrixVectorMultiply(t,e){return t.map(t=>t.reduce((t,i,a)=>t+i*e[a],0))}matrixInverse(t){const e=t.length,i=t.map((t,i)=>[...t,...Array(e).fill(0).map((t,e)=>i===e?1:0)]);for(let t=0;t<e;t++){let a=t;for(let s=t+1;s<e;s++)Math.abs(i[s][t])>Math.abs(i[a][t])&&(a=s);[i[t],i[a]]=[i[a],i[t]];const s=i[t][t];if(Math.abs(s)<1e-10)throw new Error("Matrix is singular");for(let a=0;a<2*e;a++)i[t][a]/=s;for(let a=0;a<e;a++)if(a!==t){const s=i[a][t];for(let r=0;r<2*e;r++)i[a][r]-=s*i[t][r]}}return i.map(t=>t.slice(e))}}