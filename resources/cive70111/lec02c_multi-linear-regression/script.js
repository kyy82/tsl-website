class MultiLinearRegressionDemo{constructor(){this.predictionCanvas=document.getElementById("prediction-plot"),this.predictionCtx=this.predictionCanvas.getContext("2d"),this.areaFeature=document.getElementById("area-feature"),this.bedroomsFeature=document.getElementById("bedrooms-feature"),this.bathroomsFeature=document.getElementById("bathrooms-feature"),this.storiesFeature=document.getElementById("stories-feature"),this.mseValue=document.getElementById("mse-value"),this.maeValue=document.getElementById("mae-value"),this.r2Value=document.getElementById("r2-value"),this.trainData=[],this.testData=[],this.model=null,this.features=["area","bedrooms","bathrooms","stories"],this.featureStats={},this.setupHighDPICanvas(this.predictionCanvas,this.predictionCtx),this.loadData(),this.setupEventListeners(),this.updateDisplay(),this.tabController=new DemoTabController}setupHighDPICanvas(canvas,ctx){const rect=canvas.getBoundingClientRect(),dpr=window.devicePixelRatio||1;canvas.width=rect.width*dpr,canvas.height=rect.height*dpr,canvas.style.width=rect.width+"px",canvas.style.height=rect.height+"px",ctx.scale(dpr,dpr),this.displayWidth=rect.width,this.displayHeight=rect.height}async loadData(){try{const[trainResponse,testResponse]=await Promise.all([fetch("data/train.csv"),fetch("data/test.csv")]),trainText=await trainResponse.text(),testText=await testResponse.text();this.trainData=this.parseCSV(trainText),this.testData=this.parseCSV(testText),console.log(`Loaded ${this.trainData.length} training samples and ${this.testData.length} test samples`),this.calculatePriceStats(),this.onFeatureSelectionChange()}catch(error){console.error("Error loading data:",error)}}parseCSV(text){const lines=text.trim().split("\n"),headers=lines[0].split(","),data=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(","),row={};headers.forEach((header,index)=>{row[header]=parseFloat(values[index])}),data.push(row)}return data}calculatePriceStats(){const priceValues=this.trainData.map(row=>row.price),mean=priceValues.reduce((sum,val)=>sum+val,0)/priceValues.length,variance=priceValues.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/priceValues.length,std=Math.sqrt(variance);this.priceStats={mean:mean,std:std}}normalizePrice(price){return this.priceStats.std>0?(price-this.priceStats.mean)/this.priceStats.std:0}denormalizePrice(normalizedPrice){return normalizedPrice*this.priceStats.std+this.priceStats.mean}setupEventListeners(){[this.areaFeature,this.bedroomsFeature,this.bathroomsFeature,this.storiesFeature].forEach(checkbox=>{checkbox.addEventListener("change",()=>this.onFeatureSelectionChange())})}onFeatureSelectionChange(){this.getSelectedFeatures().length>0?this.trainModel():this.resetModel()}getSelectedFeatures(){const selected=[];return this.areaFeature.checked&&selected.push("area"),this.bedroomsFeature.checked&&selected.push("bedrooms"),this.bathroomsFeature.checked&&selected.push("bathrooms"),this.storiesFeature.checked&&selected.push("stories"),selected}prepareFeatureMatrix(data,selectedFeatures){const n=data.length,p=selectedFeatures.length+1,X=Array(n).fill(null).map(()=>Array(p).fill(0));for(let i=0;i<n;i++)X[i][0]=1,selectedFeatures.forEach((feature,j)=>{X[i][j+1]=data[i][feature]});return X}trainModel(){const selectedFeatures=this.getSelectedFeatures();if(0===selectedFeatures.length)return;const X=this.prepareFeatureMatrix(this.trainData,selectedFeatures),y=this.trainData.map(row=>this.normalizePrice(row.price));try{const XtX=this.matrixMultiply(this.matrixTranspose(X),X),XtXinv=this.matrixInverse(XtX),Xty=this.matrixVectorMultiply(this.matrixTranspose(X),y),theta=this.matrixVectorMultiply(XtXinv,Xty);this.model={theta:theta,selectedFeatures:selectedFeatures},this.evaluateModel(),this.updateDisplay(),this.renderPlots()}catch(error){console.error("Error training model:",error),alert("Error training model. Try selecting different features or normalization settings.")}}evaluateModel(){if(!this.model)return;const X_test=this.prepareFeatureMatrix(this.testData,this.model.selectedFeatures),y_test_normalized=this.testData.map(row=>this.normalizePrice(row.price)),predictions_normalized=X_test.map(row=>this.model.theta.reduce((sum,coef,i)=>sum+coef*row[i],0)),y_test=this.testData.map(row=>row.price),predictions=predictions_normalized.map(pred=>this.denormalizePrice(pred)),n=y_test_normalized.length,mse=y_test_normalized.reduce((sum,actual,i)=>sum+Math.pow(actual-predictions_normalized[i],2),0)/n,mae=y_test_normalized.reduce((sum,actual,i)=>sum+Math.abs(actual-predictions_normalized[i]),0)/n,y_mean=y_test_normalized.reduce((sum,val)=>sum+val,0)/n,ss_tot=y_test_normalized.reduce((sum,val)=>sum+Math.pow(val-y_mean,2),0),r2=1-y_test_normalized.reduce((sum,actual,i)=>sum+Math.pow(actual-predictions_normalized[i],2),0)/ss_tot;this.model.metrics={mse:mse,mae:mae,r2:r2},this.model.predictions=predictions,this.model.actual=y_test}resetModel(){this.model=null,this.updateDisplay(),this.clearPlots()}updateDisplay(){this.model?(this.mseValue.textContent=this.model.metrics.mse.toFixed(3),this.maeValue.textContent=this.model.metrics.mae.toFixed(3),this.r2Value.textContent=this.model.metrics.r2.toFixed(3)):(this.mseValue.textContent="-",this.maeValue.textContent="-",this.r2Value.textContent="-")}renderPlots(){this.model&&this.renderPredictionPlot()}renderPredictionPlot(){const ctx=this.predictionCtx,width=this.displayWidth,height=this.displayHeight;ctx.clearRect(0,0,width,height);const actual=this.model.actual,predictions=this.model.predictions,allValues=[...actual,...predictions],minVal=Math.min(...allValues),maxVal=Math.max(...allValues),padding=.1*(maxVal-minVal),plotMin=minVal-padding,plotMax=maxVal+padding,plotWidth=width-100,plotHeight=height-100;ctx.strokeStyle="#ddd",ctx.lineWidth=1,ctx.beginPath(),ctx.moveTo(50,50),ctx.lineTo(50,height-50),ctx.lineTo(width-50,height-50),ctx.stroke(),ctx.strokeStyle="#e74c3c",ctx.lineWidth=2,ctx.setLineDash([5,5]),ctx.beginPath(),ctx.moveTo(50,height-50),ctx.lineTo(width-50,50),ctx.stroke(),ctx.setLineDash([]),ctx.fillStyle="#3498db";for(let i=0;i<actual.length;i++){const x=50+(predictions[i]-plotMin)/(plotMax-plotMin)*plotWidth,y=height-50-(actual[i]-plotMin)/(plotMax-plotMin)*plotHeight;ctx.beginPath(),ctx.arc(x,y,4,0,2*Math.PI),ctx.fill()}ctx.fillStyle="#2c3e50",ctx.font="12px Arial",ctx.textAlign="center",ctx.fillText("Predicted Price",width/2,height-10),ctx.save(),ctx.translate(15,height/2),ctx.rotate(-Math.PI/2),ctx.fillText("Actual Price",0,0),ctx.restore()}clearPlots(){this.predictionCtx.clearRect(0,0,this.displayWidth,this.displayHeight)}matrixMultiply(A,B){const result=Array(A.length).fill(null).map(()=>Array(B[0].length).fill(0));for(let i=0;i<A.length;i++)for(let j=0;j<B[0].length;j++)for(let k=0;k<B.length;k++)result[i][j]+=A[i][k]*B[k][j];return result}matrixTranspose(A){return A[0].map((_,i)=>A.map(row=>row[i]))}matrixVectorMultiply(A,v){return A.map(row=>row.reduce((sum,val,i)=>sum+val*v[i],0))}matrixInverse(A){const n=A.length,augmented=A.map((row,i)=>[...row,...Array(n).fill(0).map((_,j)=>i===j?1:0)]);for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];const pivot=augmented[i][i];if(Math.abs(pivot)<1e-10)throw new Error("Matrix is singular");for(let j=0;j<2*n;j++)augmented[i][j]/=pivot;for(let k=0;k<n;k++)if(k!==i){const factor=augmented[k][i];for(let j=0;j<2*n;j++)augmented[k][j]-=factor*augmented[i][j]}}return augmented.map(row=>row.slice(n))}}