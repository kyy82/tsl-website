class TwoDClassificationDemo{constructor(){this.canvas=document.getElementById("plot"),this.ctx=this.canvas.getContext("2d"),this.w1Slider=document.getElementById("w1"),this.w2Slider=document.getElementById("w2"),this.biasSlider=document.getElementById("bias"),this.w1Value=document.getElementById("w1-value"),this.w2Value=document.getElementById("w2-value"),this.biasValue=document.getElementById("bias-value"),this.boundaryType=document.getElementById("boundary-type"),this.w11Slider=document.getElementById("w11"),this.w22Slider=document.getElementById("w22"),this.w12Slider=document.getElementById("w12"),this.radiusSlider=document.getElementById("radius"),this.centerX1Slider=document.getElementById("center-x1"),this.centerX2Slider=document.getElementById("center-x2"),this.w11Value=document.getElementById("w11-value"),this.w22Value=document.getElementById("w22-value"),this.w12Value=document.getElementById("w12-value"),this.radiusValue=document.getElementById("radius-value"),this.centerX1Value=document.getElementById("center-x1-value"),this.centerX2Value=document.getElementById("center-x2-value"),this.equation=document.getElementById("equation"),this.accuracyDisplay=document.getElementById("accuracy"),this.lossDisplay=document.getElementById("loss"),this.solutionBtn=document.getElementById("solution-btn"),this.classToggle=document.getElementById("class-toggle"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.setupHighDPICanvas(),this.plotWidth=this.displayWidth-80,this.plotHeight=this.displayHeight-80,this.plotX=40,this.plotY=40,this.x1Min=-5,this.x1Max=5,this.x2Min=-5,this.x2Max=5,this.generateDataPoints(),this.setupEventListeners(),this.tabController=new DemoTabController,this.updateControlsVisibility(),this.initializeDisplay()}generateDataPoints(){this.dataPoints=[];const patterns=["diagonal_clusters","horizontal_vertical","circular_pattern","random_mixed","corner_clusters"];switch(patterns[Math.floor(Math.random()*patterns.length)]){case"diagonal_clusters":this.generateDiagonalClusters();break;case"horizontal_vertical":this.generateHorizontalVertical();break;case"circular_pattern":this.generateCircularPattern();break;case"random_mixed":this.generateRandomMixed();break;case"corner_clusters":this.generateCornerClusters()}}generateDiagonalClusters(){for(let i=0;i<12;i++){const x1=2.5*Math.random()-3+1.5*(Math.random()-.5),x2=2.5*Math.random()-3+1.5*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<12;i++){const x1=.5+2.5*Math.random()+1.5*(Math.random()-.5),x2=.5+2.5*Math.random()+1.5*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}}generateHorizontalVertical(){const isHorizontal=Math.random()>.5;for(let i=0;i<12;i++)if(isHorizontal){const x1=8*(Math.random()-.5),x2=2*Math.random()-3+.8*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}else{const x1=2*Math.random()-3+.8*(Math.random()-.5),x2=8*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<12;i++)if(isHorizontal){const x1=8*(Math.random()-.5),x2=1+2*Math.random()+.8*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}else{const x1=1+2*Math.random()+.8*(Math.random()-.5),x2=8*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}}generateCircularPattern(){for(let i=0;i<12;i++){const angle=2*Math.random()*Math.PI,radius=1.5*Math.random()+.5,x1=radius*Math.cos(angle)+.8*(Math.random()-.5),x2=radius*Math.sin(angle)+.8*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<12;i++){const angle=2*Math.random()*Math.PI,radius=2.5+1.5*Math.random(),x1=radius*Math.cos(angle)+.8*(Math.random()-.5),x2=radius*Math.sin(angle)+.8*(Math.random()-.5);Math.abs(x1)<=4.5&&Math.abs(x2)<=4.5?this.dataPoints.push({x1:x1,x2:x2,y:1}):i--}}generateRandomMixed(){for(let i=0;i<12;i++){const x1=4*Math.random()-4+2*(Math.random()-.5),x2=4*Math.random()-4+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<12;i++){const x1=0+4*Math.random()+2*(Math.random()-.5),x2=0+4*Math.random()+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}}generateCornerClusters(){const corners=[{x1:-3,x2:-3},{x1:3,x2:3},{x1:-3,x2:3},{x1:3,x2:-3}];for(let i=0;i<6;i++){const corner=corners[0],x1=corner.x1+2*(Math.random()-.5),x2=corner.x2+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<6;i++){const corner=corners[1],x1=corner.x1+2*(Math.random()-.5),x2=corner.x2+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:0})}for(let i=0;i<6;i++){const corner=corners[2],x1=corner.x1+2*(Math.random()-.5),x2=corner.x2+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}for(let i=0;i<6;i++){const corner=corners[3],x1=corner.x1+2*(Math.random()-.5),x2=corner.x2+2*(Math.random()-.5);this.dataPoints.push({x1:x1,x2:x2,y:1})}}setupHighDPICanvas(){const dpr=window.devicePixelRatio||1,displayWidth=this.canvas.clientWidth||600,displayHeight=this.canvas.clientHeight||400;this.canvas.width=displayWidth*dpr,this.canvas.height=displayHeight*dpr,this.canvas.style.width=displayWidth+"px",this.canvas.style.height=displayHeight+"px",this.ctx.scale(dpr,dpr),this.ctx.imageSmoothingEnabled=!0,this.ctx.imageSmoothingQuality="high",this.dpr=dpr,this.displayWidth=displayWidth,this.displayHeight=displayHeight}initializeDisplay(){this.draw(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}updateDisplayPlainText(){const params=this.getCurrentParameters();this.w1Value.textContent=params.w1.toFixed(1),this.w2Value.textContent=params.w2.toFixed(1),this.biasValue.textContent=params.bias.toFixed(1),this.w11Value&&(this.w11Value.textContent=(params.w11||0).toFixed(1)),this.w22Value&&(this.w22Value.textContent=(params.w22||0).toFixed(1)),this.w12Value&&(this.w12Value.textContent=(params.w12||0).toFixed(1)),this.radiusValue&&(this.radiusValue.textContent=(params.radius||2).toFixed(1)),this.centerX1Value&&(this.centerX1Value.textContent=(params.centerX1||0).toFixed(1)),this.centerX2Value&&(this.centerX2Value.textContent=(params.centerX2||0).toFixed(1));const equationText=this.getEquationText(params);this.equation.textContent=equationText;const accuracy=this.calculateAccuracy(),loss=this.calculateLoss();this.accuracyDisplay.textContent=`Accuracy = ${(100*accuracy).toFixed(1)}%`,this.lossDisplay.textContent=`Loss = ${loss.toFixed(3)}`}getEquationText(params){switch(params.type){case"linear":default:return this.getLinearEquation(params);case"quadratic":return this.getQuadraticEquation(params);case"circular":return this.getCircularEquation(params)}}getLinearEquation(params){const biasSign=params.bias>=0?"+":"-";return`f(x) = σ(${params.w1.toFixed(1)}x₁ + ${params.w2.toFixed(1)}x₂ ${biasSign} ${Math.abs(params.bias).toFixed(1)})`}getQuadraticEquation(params){let terms=[];if(0!==params.w1&&terms.push(`${params.w1.toFixed(1)}x₁`),0!==params.w2&&terms.push(`${params.w2.toFixed(1)}x₂`),params.w11&&0!==params.w11&&terms.push(`${params.w11.toFixed(1)}x₁²`),params.w22&&0!==params.w22&&terms.push(`${params.w22.toFixed(1)}x₂²`),params.w12&&0!==params.w12&&terms.push(`${params.w12.toFixed(1)}x₁x₂`),0!==params.bias&&terms.push(`${params.bias.toFixed(1)}`),0===terms.length)return"f(x) = σ(0)";let equation=terms[0];for(let i=1;i<terms.length;i++){const term=terms[i];term.startsWith("-")?equation+=` - ${term.substring(1)}`:equation+=` + ${term}`}return`f(x) = σ(${equation})`}getCircularEquation(params){const centerX1=params.centerX1.toFixed(1),centerX2=params.centerX2.toFixed(1);return`f(x) = σ(${params.radius.toFixed(1)} - √[(${params.centerX1>=0?`x₁ - ${centerX1}`:`x₁ + ${Math.abs(params.centerX1).toFixed(1)}`})² + (${params.centerX2>=0?`x₂ - ${centerX2}`:`x₂ + ${Math.abs(params.centerX2).toFixed(1)}`})²])`}getLatexEquation(params){switch(params.type){case"linear":default:return this.getLinearLatex(params);case"quadratic":return this.getQuadraticLatex(params);case"circular":return this.getCircularLatex(params)}}getLinearLatex(params){const biasSign=params.bias>=0?"+":"-";return`$$f(\\mathbf{x}) = \\sigma(${params.w1.toFixed(1)}x_1 + ${params.w2.toFixed(1)}x_2 ${biasSign} ${Math.abs(params.bias).toFixed(1)})$$`}getQuadraticLatex(params){let terms=[];if(0!==params.w1&&terms.push(`${params.w1.toFixed(1)}x_1`),0!==params.w2&&terms.push(`${params.w2.toFixed(1)}x_2`),params.w11&&0!==params.w11&&terms.push(`${params.w11.toFixed(1)}x_1^2`),params.w22&&0!==params.w22&&terms.push(`${params.w22.toFixed(1)}x_2^2`),params.w12&&0!==params.w12&&terms.push(`${params.w12.toFixed(1)}x_1 x_2`),0!==params.bias&&terms.push(`${params.bias.toFixed(1)}`),0===terms.length)return"$$f(\\mathbf{x}) = \\sigma(0)$$";let equation=terms[0];for(let i=1;i<terms.length;i++){const term=terms[i];term.startsWith("-")?equation+=` - ${term.substring(1)}`:equation+=` + ${term}`}return`$$f(\\mathbf{x}) = \\sigma(${equation})$$`}getCircularLatex(params){const centerX1=params.centerX1.toFixed(1),centerX2=params.centerX2.toFixed(1);return`$$f(\\mathbf{x}) = \\sigma\\left(${params.radius.toFixed(1)} - \\sqrt{(${params.centerX1>=0?`x_1 - ${centerX1}`:`x_1 + ${Math.abs(params.centerX1).toFixed(1)}`})^2 + (${params.centerX2>=0?`x_2 - ${centerX2}`:`x_2 + ${Math.abs(params.centerX2).toFixed(1)}`})^2}\\right)$$`}setupEventListeners(){this.w1Slider.addEventListener("input",()=>{this.updateDisplay(),this.draw()}),this.w2Slider.addEventListener("input",()=>{this.updateDisplay(),this.draw()}),this.biasSlider.addEventListener("input",()=>{this.updateDisplay(),this.draw()}),this.solutionBtn.addEventListener("click",()=>{this.setOptimalValues()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()}),this.canvas.addEventListener("click",event=>{this.handleCanvasClick(event)}),this.boundaryType.addEventListener("change",()=>{this.updateControlsVisibility(),this.updateDisplay(),this.draw()}),[this.w11Slider,this.w22Slider,this.w12Slider,this.radiusSlider,this.centerX1Slider,this.centerX2Slider].forEach(slider=>{slider&&slider.addEventListener("input",()=>{this.updateDisplay(),this.draw()})})}updateControlsVisibility(){const boundaryType=this.boundaryType.value;switch(["w1-group","w2-group","bias-group","w11-group","w22-group","w12-group","radius-group","center-x1-group","center-x2-group"].forEach(id=>{const element=document.getElementById(id);element&&(element.style.display="none")}),boundaryType){case"linear":document.getElementById("w1-group").style.display="block",document.getElementById("w2-group").style.display="block",document.getElementById("bias-group").style.display="block";break;case"quadratic":document.getElementById("w1-group").style.display="block",document.getElementById("w2-group").style.display="block",document.getElementById("bias-group").style.display="block",document.getElementById("w11-group").style.display="block",document.getElementById("w22-group").style.display="block",document.getElementById("w12-group").style.display="block";break;case"circular":document.getElementById("radius-group").style.display="block",document.getElementById("center-x1-group").style.display="block",document.getElementById("center-x2-group").style.display="block"}}updateDisplay(){const params=this.getCurrentParameters();this.w1Value.textContent=params.w1.toFixed(1),this.w2Value.textContent=params.w2.toFixed(1),this.biasValue.textContent=params.bias.toFixed(1),this.w11Value&&(this.w11Value.textContent=(params.w11||0).toFixed(1)),this.w22Value&&(this.w22Value.textContent=(params.w22||0).toFixed(1)),this.w12Value&&(this.w12Value.textContent=(params.w12||0).toFixed(1)),this.radiusValue&&(this.radiusValue.textContent=(params.radius||2).toFixed(1)),this.centerX1Value&&(this.centerX1Value.textContent=(params.centerX1||0).toFixed(1)),this.centerX2Value&&(this.centerX2Value.textContent=(params.centerX2||0).toFixed(1));const latexEquation=this.getLatexEquation(params);this.equation.innerHTML=latexEquation,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const accuracy=this.calculateAccuracy(),loss=this.calculateLoss();this.accuracyDisplay.innerHTML=`$$\\text{Accuracy} = ${(100*accuracy).toFixed(1)}\\%$$`,this.lossDisplay.innerHTML=`$$\\text{Loss} = ${loss.toFixed(3)}$$`,window.MathJax&&MathJax.typesetPromise([this.accuracyDisplay,this.lossDisplay]).catch(err=>console.log(err))}sigmoid(x){return 1/(1+Math.exp(-x))}predict(x1,x2,parameters=null){parameters||(parameters=this.getCurrentParameters());const linear=this.computeLinearCombination(x1,x2,parameters);return this.sigmoid(linear)}classify(x1,x2,parameters=null){return this.predict(x1,x2,parameters)>.5?1:0}getCurrentParameters(){const boundaryType=this.boundaryType.value,params={type:boundaryType,w1:parseFloat(this.w1Slider.value),w2:parseFloat(this.w2Slider.value),bias:parseFloat(this.biasSlider.value)};switch(boundaryType){case"quadratic":params.w11=this.w11Slider?parseFloat(this.w11Slider.value):0,params.w22=this.w22Slider?parseFloat(this.w22Slider.value):0,params.w12=this.w12Slider?parseFloat(this.w12Slider.value):0;break;case"circular":params.radius=this.radiusSlider?parseFloat(this.radiusSlider.value):2,params.centerX1=this.centerX1Slider?parseFloat(this.centerX1Slider.value):0,params.centerX2=this.centerX2Slider?parseFloat(this.centerX2Slider.value):0}return params}computeLinearCombination(x1,x2,params){let result=params.w1*x1+params.w2*x2+params.bias;switch(params.type){case"quadratic":result+=params.w11*x1*x1+params.w22*x2*x2+params.w12*x1*x2;break;case"circular":const dx=x1-params.centerX1,dy=x2-params.centerX2,distanceFromCenter=Math.sqrt(dx*dx+dy*dy);result=params.radius-distanceFromCenter}return result}dataToCanvas(x1,x2){return{x:this.plotX+(x1-this.x1Min)/(this.x1Max-this.x1Min)*this.plotWidth,y:this.plotY+this.plotHeight-(x2-this.x2Min)/(this.x2Max-this.x2Min)*this.plotHeight}}drawAxes(){this.ctx.strokeStyle="#333",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY+this.plotHeight),this.ctx.lineTo(this.plotX+this.plotWidth,this.plotY+this.plotHeight),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY),this.ctx.lineTo(this.plotX,this.plotY+this.plotHeight),this.ctx.stroke(),this.drawGrid(),this.drawLabels()}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1;for(let x1=this.x1Min;x1<=this.x1Max;x1+=1){const canvasPos=this.dataToCanvas(x1,0);this.ctx.beginPath(),this.ctx.moveTo(canvasPos.x,this.plotY),this.ctx.lineTo(canvasPos.x,this.plotY+this.plotHeight),this.ctx.stroke()}for(let x2=this.x2Min;x2<=this.x2Max;x2+=1){const canvasPos=this.dataToCanvas(0,x2);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,canvasPos.y),this.ctx.lineTo(this.plotX+this.plotWidth,canvasPos.y),this.ctx.stroke()}}drawLabels(){this.ctx.fillStyle="#666",this.ctx.font="12px Arial",this.ctx.textAlign="center";for(let x1=this.x1Min;x1<=this.x1Max;x1+=1){const canvasPos=this.dataToCanvas(x1,0);this.ctx.fillText(x1.toString(),canvasPos.x,this.plotY+this.plotHeight+20)}this.ctx.textAlign="right";for(let x2=this.x2Min;x2<=this.x2Max;x2+=1){const canvasPos=this.dataToCanvas(0,x2);this.ctx.fillText(x2.toString(),this.plotX-10,canvasPos.y+4)}this.ctx.fillStyle="#333",this.ctx.font="14px Arial",this.ctx.textAlign="center",this.ctx.fillText("X₁",this.plotX+this.plotWidth/2,this.displayHeight-10),this.ctx.save(),this.ctx.translate(15,this.plotY+this.plotHeight/2),this.ctx.rotate(-Math.PI/2),this.ctx.fillText("X₂",0,0),this.ctx.restore()}drawDataPoints(){this.dataPoints.forEach(point=>{const canvasPos=this.dataToCanvas(point.x1,point.x2);0===point.y?(this.ctx.fillStyle="#ff6b6b",this.ctx.strokeStyle="#d63447"):(this.ctx.fillStyle="#4ecdc4",this.ctx.strokeStyle="#26a69a"),this.ctx.lineWidth=2,this.ctx.beginPath(),0===point.y?this.ctx.arc(canvasPos.x,canvasPos.y,5,0,2*Math.PI):this.ctx.rect(canvasPos.x-5,canvasPos.y-5,10,10),this.ctx.fill(),this.ctx.stroke()})}drawDecisionBoundary(){const params=this.getCurrentParameters();this.drawNonlinearBoundary(params)}drawNonlinearBoundary(params){this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3;const contourLines=this.findContourLines(.5,100,params);this.drawContourLines(contourLines,"#4ecdc4",3,[]);const contour25=this.findContourLines(.25,100,params),contour75=this.findContourLines(.75,100,params);this.drawContourLines(contour25,"rgba(78, 205, 196, 0.6)",2,[5,5]),this.drawContourLines(contour75,"rgba(78, 205, 196, 0.6)",2,[5,5]),this.ctx.setLineDash([])}findContourLines(targetProb,resolution,params){const lines=[],step=(this.x1Max-this.x1Min)/resolution;for(let i=0;i<resolution-1;i++)for(let j=0;j<resolution-1;j++){const x1a=this.x1Min+i*step,x1b=this.x1Min+(i+1)*step,x2a=this.x2Min+j*step,x2b=this.x2Min+(j+1)*step,v00=this.predict(x1a,x2a,params),v10=this.predict(x1b,x2a,params),v01=this.predict(x1a,x2b,params),v11=this.predict(x1b,x2b,params),min=Math.min(v00,v10,v01,v11),max=Math.max(v00,v10,v01,v11);if(min<=targetProb&&max>=targetProb){const intersections=[];if((v00-targetProb)*(v10-targetProb)<=0){const t=(targetProb-v00)/(v10-v00);intersections.push({x1:x1a+t*step,x2:x2a})}if((v10-targetProb)*(v11-targetProb)<=0){const t=(targetProb-v10)/(v11-v10);intersections.push({x1:x1b,x2:x2a+t*step})}if((v11-targetProb)*(v01-targetProb)<=0){const t=(targetProb-v01)/(v11-v01);intersections.push({x1:x1a+t*step,x2:x2b})}if((v01-targetProb)*(v00-targetProb)<=0){const t=(targetProb-v00)/(v01-v00);intersections.push({x1:x1a,x2:x2a+t*step})}intersections.length>=2&&lines.push({start:intersections[0],end:intersections[1]})}}return lines}drawContourLines(lines,color,width,dashPattern){this.ctx.strokeStyle=color,this.ctx.lineWidth=width,this.ctx.setLineDash(dashPattern),lines.forEach(line=>{const start=this.dataToCanvas(line.start.x1,line.start.x2),end=this.dataToCanvas(line.end.x1,line.end.x2);this.ctx.beginPath(),this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke()})}drawLinearBoundary(w1,w2,bias){if(Math.abs(w2)<.001){if(Math.abs(w1)>.001){const x1=-bias/w1;if(x1>=this.x1Min&&x1<=this.x1Max){const start=this.dataToCanvas(x1,this.x2Min),end=this.dataToCanvas(x1,this.x2Max);this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath(),this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke()}}}else{const x1Start=this.x1Min,x2Start=-(w1*x1Start+bias)/w2,x1End=this.x1Max,x2End=-(w1*x1End+bias)/w2;if(x2Start>=this.x2Min&&x2Start<=this.x2Max||x2End>=this.x2Min&&x2End<=this.x2Max||x2Start<this.x2Min&&x2End>this.x2Max||x2Start>this.x2Max&&x2End<this.x2Min){const start=this.dataToCanvas(x1Start,x2Start),end=this.dataToCanvas(x1End,x2End);this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath(),this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke()}}}drawSigmoidContours(w1,w2,bias){this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.drawLinearBoundary(w1,w2,bias),this.ctx.strokeStyle="rgba(78, 205, 196, 0.6)",this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]);[.25,.75].forEach(prob=>{const logitProb=Math.log(prob/(1-prob)),contourBias=bias-logitProb;if(Math.abs(w2)>.001){const x1Start=this.x1Min,x2Start=-(w1*x1Start+contourBias)/w2,x1End=this.x1Max,x2End=-(w1*x1End+contourBias)/w2;if(x2Start>=this.x2Min&&x2Start<=this.x2Max||x2End>=this.x2Min&&x2End<=this.x2Max||x2Start<this.x2Min&&x2End>this.x2Max||x2Start>this.x2Max&&x2End<this.x2Min){const start=this.dataToCanvas(x1Start,x2Start),end=this.dataToCanvas(x1End,x2End);this.ctx.beginPath(),this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke()}}}),this.ctx.setLineDash([])}calculateAccuracy(){if(0===this.dataPoints.length)return 0;let correct=0;return this.dataPoints.forEach(point=>{this.classify(point.x1,point.x2)===point.y&&correct++}),correct/this.dataPoints.length}calculateLoss(){if(0===this.dataPoints.length)return 0;let totalLoss=0;return this.dataPoints.forEach(point=>{const prediction=this.predict(point.x1,point.x2),clippedPred=Math.max(1e-15,Math.min(1-1e-15,prediction));totalLoss+=-(point.y*Math.log(clippedPred)+(1-point.y)*Math.log(1-clippedPred))}),totalLoss/this.dataPoints.length}resetParametersToDefault(){this.w1Slider.value="0.1",this.w2Slider.value="0.1",this.biasSlider.value="0.0",this.w11Slider&&(this.w11Slider.value="0.0"),this.w22Slider&&(this.w22Slider.value="0.0"),this.w12Slider&&(this.w12Slider.value="0.0"),this.radiusSlider&&(this.radiusSlider.value="2.0"),this.centerX1Slider&&(this.centerX1Slider.value="0.0"),this.centerX2Slider&&(this.centerX2Slider.value="0.0")}setParametersFromObject(params){this.w1Slider.value=params.w1.toFixed(1),this.w2Slider.value=params.w2.toFixed(1),this.biasSlider.value=params.bias.toFixed(1),void 0!==params.w11&&this.w11Slider&&(this.w11Slider.value=params.w11.toFixed(1)),void 0!==params.w22&&this.w22Slider&&(this.w22Slider.value=params.w22.toFixed(1)),void 0!==params.w12&&this.w12Slider&&(this.w12Slider.value=params.w12.toFixed(1)),void 0!==params.radius&&this.radiusSlider&&(this.radiusSlider.value=params.radius.toFixed(1)),void 0!==params.centerX1&&this.centerX1Slider&&(this.centerX1Slider.value=params.centerX1.toFixed(1)),void 0!==params.centerX2&&this.centerX2Slider&&(this.centerX2Slider.value=params.centerX2.toFixed(1))}calculateAccuracyWithParams(params){if(0===this.dataPoints.length)return 0;let correct=0;return this.dataPoints.forEach(point=>{(this.predict(point.x1,point.x2,params)>.5?1:0)===point.y&&correct++}),correct/this.dataPoints.length}setOptimalValues(){if(0===this.dataPoints.length)return;const boundaryType=this.boundaryType.value;this.optimizeForBoundaryType(boundaryType).then(params=>{this.setParametersFromObject(params),this.updateDisplay(),this.draw()})}async optimizeForBoundaryType(boundaryType){switch(boundaryType){case"linear":default:return this.optimizeLinear();case"quadratic":return this.optimizeQuadratic();case"circular":return this.optimizeCircular()}}optimizeLinear(){return new Promise(resolve=>{let w1=parseFloat(this.w1Slider.value),w2=parseFloat(this.w2Slider.value),bias=parseFloat(this.biasSlider.value);for(let iter=0;iter<1e3;iter++){let w1Grad=0,w2Grad=0,biasGrad=0;if(this.dataPoints.forEach(point=>{const z=w1*point.x1+w2*point.x2+bias,error=this.sigmoid(z)-point.y;w1Grad+=error*point.x1,w2Grad+=error*point.x2,biasGrad+=error}),w1Grad/=this.dataPoints.length,w2Grad/=this.dataPoints.length,biasGrad/=this.dataPoints.length,w1-=.1*w1Grad,w2-=.1*w2Grad,bias-=.1*biasGrad,Math.abs(w1Grad)<.001&&Math.abs(w2Grad)<.001&&Math.abs(biasGrad)<.001)break}resolve({type:"linear",w1:Math.max(-5,Math.min(5,w1)),w2:Math.max(-5,Math.min(5,w2)),bias:Math.max(-10,Math.min(10,bias))})})}optimizeQuadratic(){return new Promise(resolve=>{let w1=parseFloat(this.w1Slider.value),w2=parseFloat(this.w2Slider.value),bias=parseFloat(this.biasSlider.value),w11=0,w22=0,w12=0;for(let iter=0;iter<1e3;iter++){let w1Grad=0,w2Grad=0,biasGrad=0,w11Grad=0,w22Grad=0,w12Grad=0;this.dataPoints.forEach(point=>{const z=w1*point.x1+w2*point.x2+w11*point.x1*point.x1+w22*point.x2*point.x2+w12*point.x1*point.x2+bias,error=this.sigmoid(z)-point.y;w1Grad+=error*point.x1,w2Grad+=error*point.x2,w11Grad+=error*point.x1*point.x1,w22Grad+=error*point.x2*point.x2,w12Grad+=error*point.x1*point.x2,biasGrad+=error});const n=this.dataPoints.length;if(w1Grad/=n,w2Grad/=n,biasGrad/=n,w11Grad/=n,w22Grad/=n,w12Grad/=n,w1-=.05*w1Grad,w2-=.05*w2Grad,w11-=.05*w11Grad,w22-=.05*w22Grad,w12-=.05*w12Grad,bias-=.05*biasGrad,Math.abs(w1Grad)<.001&&Math.abs(w2Grad)<.001&&Math.abs(w11Grad)<.001&&Math.abs(w22Grad)<.001&&Math.abs(w12Grad)<.001&&Math.abs(biasGrad)<.001)break}resolve({type:"quadratic",w1:Math.max(-5,Math.min(5,w1)),w2:Math.max(-5,Math.min(5,w2)),w11:Math.max(-2,Math.min(2,w11)),w22:Math.max(-2,Math.min(2,w22)),w12:Math.max(-2,Math.min(2,w12)),bias:Math.max(-10,Math.min(10,bias))})})}optimizeCircular(){return new Promise(resolve=>{let bestAccuracy=0,bestParams={type:"circular",w1:0,w2:0,bias:0,radius:2,centerX1:0,centerX2:0};for(let cx=-3;cx<=3;cx+=.5)for(let cy=-3;cy<=3;cy+=.5)for(let r=.5;r<=4;r+=.3){const params={type:"circular",w1:0,w2:0,bias:0,radius:r,centerX1:cx,centerX2:cy},accuracy=this.calculateAccuracyWithParams(params);accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestParams=params)}resolve(bestParams)})}generateNewData(){this.clearAllData(),this.generateDataPoints(),this.updateDisplay(),this.draw()}clearAllData(){this.dataPoints=[],this.updateDisplay(),this.draw()}handleCanvasClick(event){const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,dataCoords=this.canvasToData(canvasX,canvasY);if(this.isWithinPlotArea(canvasX,canvasY)){const selectedClass=parseInt(this.classToggle.value);this.dataPoints.push({x1:dataCoords.x1,x2:dataCoords.x2,y:selectedClass}),this.updateDisplay(),this.draw()}}canvasToData(canvasX,canvasY){return{x1:this.x1Min+(canvasX-this.plotX)/this.plotWidth*(this.x1Max-this.x1Min),x2:this.x2Max-(canvasY-this.plotY)/this.plotHeight*(this.x2Max-this.x2Min)}}isWithinPlotArea(canvasX,canvasY){return canvasX>=this.plotX&&canvasX<=this.plotX+this.plotWidth&&canvasY>=this.plotY&&canvasY<=this.plotY+this.plotHeight}draw(){this.ctx.clearRect(0,0,this.displayWidth,this.displayHeight),this.ctx.lineCap="round",this.ctx.lineJoin="round",this.drawAxes(),this.drawDecisionBoundary(),this.drawDataPoints()}}document.addEventListener("DOMContentLoaded",()=>{new TwoDClassificationDemo});