class KMeansDemo{constructor(){this.canvas=document.getElementById("plot"),this.overlayCanvas=document.getElementById("overlay-canvas"),this.overlayCtx=this.overlayCanvas.getContext("2d"),this.chart=null,this.kSlider=document.getElementById("k-clusters"),this.kValue=document.getElementById("k-value"),this.stepBtn=document.getElementById("step-btn"),this.finalBtn=document.getElementById("final-btn"),this.resetBtn=document.getElementById("reset-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.addDataModeCheckbox=document.getElementById("add-data-mode"),this.iterationDisplay=document.getElementById("iteration-display"),this.statusDisplay=document.getElementById("status-display"),this.pointsCount=document.getElementById("points-count"),this.xMin=-5,this.xMax=5,this.yMin=-5,this.yMax=5,this.xLabel="X",this.yLabel="Y",this.structuresBtn=document.getElementById("structures-btn"),this.geotechBtn=document.getElementById("geotech-btn"),this.transportBtn=document.getElementById("transport-btn"),this.environmentBtn=document.getElementById("environment-btn"),this.datasets={structures:{name:"Structures - Concrete Mix Design",file:"example-data/structures_concrete.csv",xLabel:"Cement (kg/m³)",yLabel:"Fly Ash (kg/m³)",xColumn:"X",yColumn:"Y",title:"Structures: Concrete Mix Design",description:"This dataset shows clustering patterns in concrete mix designs based on binder composition. Different cement and fly ash combinations reveal distinct mix types: plain Portland cement mixes (high cement, zero fly ash), blended mixes with moderate replacement, and high-volume fly ash concrete.",variables:"Variables: Cement content (kg/m³) vs Fly Ash content (kg/m³)"},geotech:{name:"Geotechnics - Soil Classification",file:"example-data/geotechnics_soil.csv",xLabel:"Silt Content (%)",yLabel:"Clay Content (%)",xColumn:"X",yColumn:"Y",title:"Geotechnics: Soil Classification",description:"This dataset reveals natural soil type clusters based on fine fraction composition. The silt-clay relationship helps identify distinct soil classes (sandy, silty, clayey soils) critical for foundation design.",variables:"Variables: Silt percentage (%) vs Clay percentage (%)"},transport:{name:"Transport - TfL Journey Patterns",file:"example-data/transport_tfl-journeys.csv",xLabel:"Bus Journeys (millions)",yLabel:"Underground Journeys (millions)",xColumn:"X",yColumn:"Y",title:"Transport: TfL Journey Patterns",description:"This dataset clusters Transport for London (TfL) journey patterns over time. Different clusters reveal seasonal patterns, weekday vs weekend usage, and the impact of major events on public transport demand.",variables:"Variables: Bus journeys (millions) vs Underground journeys (millions)"},environment:{name:"Environment - Air Quality",file:"example-data/environment_air-quality.csv",xLabel:"PM10 (µg/m³)",yLabel:"Air Quality Index",xColumn:"X",yColumn:"Y",title:"Environment: London Air Quality",description:"This dataset clusters London air quality measurements. Different clusters reveal pollution episodes, typical urban background conditions, and clean air periods based on particulate matter (PM10) and overall air quality index.",variables:"Variables: PM10 concentration (µg/m³) vs Air Quality Index"}},this.k=3,this.dataPoints=[],this.centroids=[],this.assignments=[],this.iteration=0,this.converged=!1,this.isRunning=!1,this.centroidHistory=[],this.addedCentroids=[],this.hoveredCentroid=null,this.draggedCentroid=null,this.isDragging=!1,this.dragOffset={x:0,y:0},this.dragStarted=!1,this.lastMouseX=0,this.lastMouseY=0,this.clusterColors=["#e74c3c","#3498db","#2ecc71","#f39c12","#9b59b6","#1abc9c","#34495e","#e67e22","#8e44ad","#16a085"],this.initializeChart(),requestAnimationFrame(()=>{this.setupOverlayCanvas(),this.updateChart()}),this.setupEventListeners(),this.generateInitialData(),this.initializeCentroids(),this.updateChart()}initializeChart(){this.canvas.style.width="100%",this.canvas.style.height="100%";const overlayUpdatePlugin={id:"overlayUpdate",afterDatasetsDraw:(chart,args,options)=>{this.drawOverlayElements()}};this.chart=new Chart(this.canvas.getContext("2d"),{type:"scatter",plugins:[overlayUpdatePlugin],data:{datasets:[]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{type:"linear",position:"bottom",min:this.xMin,max:this.xMax,title:{display:!0,text:this.xLabel},grid:{color:"#e0e0e0"}},y:{type:"linear",position:"left",min:this.yMin,max:this.yMax,title:{display:!0,text:this.yLabel},grid:{color:"#e0e0e0"}}},plugins:{legend:{display:!0,position:"top"},tooltip:{callbacks:{label:context=>{const point=context.raw;return`X: ${point.x.toFixed(2)}, Y: ${point.y.toFixed(2)}`}}}},onClick:(event,activeElements)=>{this.handleChartClick(event)},animation:{duration:0}}})}setupOverlayCanvas(){const dpr=window.devicePixelRatio||1,chartCanvas=this.chart.canvas,displayWidth=chartCanvas.clientWidth,displayHeight=chartCanvas.clientHeight;this.overlayCanvas.width=displayWidth*dpr,this.overlayCanvas.height=displayHeight*dpr,this.overlayCanvas.style.width=displayWidth+"px",this.overlayCanvas.style.height=displayHeight+"px",this.overlayCtx.scale(dpr,dpr),this.overlayCtx.imageSmoothingEnabled=!0,this.overlayCtx.imageSmoothingQuality="high",this.overlayWidth=displayWidth,this.overlayHeight=displayHeight,this.dpr=dpr}updateChart(){this.chart&&(this.updateDatasets(),this.chart.update("none"),this.drawOverlayElements())}updateDatasets(){const datasets=[];for(let i=0;i<this.k;i++){const clusterPoints=this.dataPoints.filter((point,index)=>this.assignments[index]===i).map(point=>({x:point.x,y:point.y}));datasets.push({label:`Cluster ${i+1}`,data:clusterPoints,backgroundColor:this.clusterColors[i%this.clusterColors.length],borderColor:this.clusterColors[i%this.clusterColors.length],borderWidth:2,pointRadius:6,pointHoverRadius:8,pointStyle:"circle"})}if(0===this.assignments.length){const allPoints=this.dataPoints.map(point=>({x:point.x,y:point.y}));datasets.push({label:"Data Points",data:allPoints,backgroundColor:"#95a5a6",borderColor:"#7f8c8d",borderWidth:2,pointRadius:6,pointHoverRadius:8,pointStyle:"circle"})}this.chart.data.datasets=datasets}drawOverlayElements(){this.overlayCtx&&(this.overlayCtx.clearRect(0,0,this.overlayWidth,this.overlayHeight),this.drawConnectionLines(),this.drawCentroidsOnOverlay())}drawConnectionLines(){if(this.overlayCtx){this.overlayCtx.lineWidth=1,this.overlayCtx.setLineDash([7,3]);for(let i=0;i<this.dataPoints.length;i++){const point=this.dataPoints[i],centroidIndex=this.assignments[i];if(null==centroidIndex)continue;const centroid=this.centroids[centroidIndex];if(!centroid)continue;const color=this.clusterColors[centroidIndex%this.clusterColors.length],pointCoords=this.dataToOverlayCoords(point.x,point.y),centroidCoords=this.dataToOverlayCoords(centroid.x,centroid.y);this.overlayCtx.strokeStyle=color,this.overlayCtx.globalAlpha=.7,this.overlayCtx.beginPath(),this.overlayCtx.moveTo(pointCoords.x,pointCoords.y),this.overlayCtx.lineTo(centroidCoords.x,centroidCoords.y),this.overlayCtx.stroke()}this.overlayCtx.setLineDash([]),this.overlayCtx.globalAlpha=1}}drawCentroidsOnOverlay(){this.overlayCtx&&this.centroids.forEach((centroid,index)=>{const coords=this.dataToOverlayCoords(centroid.x,centroid.y),color=this.clusterColors[index%this.clusterColors.length];this.overlayCtx.fillStyle=color,this.overlayCtx.strokeStyle="#333",this.overlayCtx.lineWidth=2;const radius=index===this.hoveredCentroid?10:8;this.overlayCtx.beginPath(),this.overlayCtx.arc(coords.x,coords.y,radius,0,2*Math.PI),this.overlayCtx.fill(),this.overlayCtx.stroke(),this.overlayCtx.fillStyle="white",this.overlayCtx.beginPath(),this.overlayCtx.arc(coords.x,coords.y,radius-3,0,2*Math.PI),this.overlayCtx.fill(),this.overlayCtx.fillStyle=color,this.overlayCtx.beginPath(),this.overlayCtx.arc(coords.x,coords.y,radius-4,0,2*Math.PI),this.overlayCtx.fill()})}handleChartClick(event){if(!this.isRunning&&this.addDataModeCheckbox.checked){const rect=this.canvas.getBoundingClientRect(),canvasX=event.native.clientX-rect.left,canvasY=event.native.clientY-rect.top,coords=this.overlayToDataCoords(canvasX,canvasY);this.dataPoints.push({x:coords.x,y:coords.y}),this.pointsCount.textContent=this.dataPoints.length,this.resetClustering(),this.updateChart()}}overlayToDataCoords(canvasX,canvasY){const xScale=this.chart.scales.x,yScale=this.chart.scales.y;return{x:xScale.getValueForPixel(canvasX),y:yScale.getValueForPixel(canvasY)}}dataToOverlayCoords(x,y){const xScale=this.chart.scales.x,yScale=this.chart.scales.y;return{x:xScale.getPixelForValue(x),y:yScale.getPixelForValue(y)}}getCentroidAtPosition(canvasX,canvasY){for(let i=0;i<this.centroids.length;i++){const centroid=this.centroids[i],coords=this.dataToOverlayCoords(centroid.x,centroid.y);if(Math.sqrt(Math.pow(canvasX-coords.x,2)+Math.pow(canvasY-coords.y,2))<=12)return i}return null}resetClustering(){this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready",this.assignments=new Array(this.dataPoints.length).fill(0)}handleOverlayMouseDown(event){if(this.isRunning)return;const rect=this.overlayCanvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,centroidIndex=this.getCentroidAtPosition(canvasX,canvasY);if(null!==centroidIndex){this.draggedCentroid=centroidIndex,this.isDragging=!0;const coords=this.overlayToDataCoords(canvasX,canvasY),centroid=this.centroids[centroidIndex];this.dragOffset={x:coords.x-centroid.x,y:coords.y-centroid.y},this.overlayCanvas.style.cursor="grabbing",event.preventDefault()}}handleOverlayMouseMove(event){const rect=this.overlayCanvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top;if(this.lastMouseX=canvasX,this.lastMouseY=canvasY,this.isDragging&&null!==this.draggedCentroid){this.dragStarted=!0;const coords=this.overlayToDataCoords(canvasX,canvasY);this.centroids[this.draggedCentroid]={x:coords.x-this.dragOffset.x,y:coords.y-this.dragOffset.y},this.assignPoints(),this.updateChart()}else if(!this.isRunning){const centroidIndex=this.getCentroidAtPosition(canvasX,canvasY),oldHovered=this.hoveredCentroid;this.hoveredCentroid=centroidIndex,this.overlayCanvas.style.cursor=null!==centroidIndex?"grab":this.addDataModeCheckbox.checked?"crosshair":"default",oldHovered!==this.hoveredCentroid&&this.drawOverlayElements()}}handleOverlayMouseUp(event){if(this.isDragging){this.isDragging=!1,this.draggedCentroid=null,this.dragOffset={x:0,y:0};const rect=this.overlayCanvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,centroidIndex=this.getCentroidAtPosition(canvasX,canvasY);this.overlayCanvas.style.cursor=null!==centroidIndex?"grab":"default",this.assignPoints(),this.updateChart()}}handleOverlayClick(event){if(!this.isRunning&&!this.dragStarted&&this.addDataModeCheckbox.checked){const rect=this.overlayCanvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,coords=this.overlayToDataCoords(canvasX,canvasY);this.dataPoints.push({x:coords.x,y:coords.y}),this.pointsCount.textContent=this.dataPoints.length,this.resetClustering(),this.updateChart()}this.dragStarted=!1}setupEventListeners(){this.kSlider.addEventListener("input",e=>{const newK=parseInt(e.target.value);this.updateK(newK),this.kValue.textContent=this.k}),this.stepBtn.addEventListener("click",()=>this.stepForward()),this.finalBtn.addEventListener("click",()=>this.runToCompletion()),this.resetBtn.addEventListener("click",()=>this.resetTraining()),this.generateDataBtn.addEventListener("click",()=>this.generateNewData()),this.structuresBtn.addEventListener("click",()=>this.loadDataset("structures")),this.geotechBtn.addEventListener("click",()=>this.loadDataset("geotech")),this.transportBtn.addEventListener("click",()=>this.loadDataset("transport")),this.environmentBtn.addEventListener("click",()=>this.loadDataset("environment")),this.addDataModeCheckbox.addEventListener("change",()=>{if(!this.isRunning&&!this.isDragging){const centroidIndex=this.getCentroidAtPosition(this.lastMouseX||0,this.lastMouseY||0);this.canvas.style.cursor=null!==centroidIndex?"grab":this.addDataModeCheckbox.checked?"crosshair":"default"}}),this.overlayCanvas.addEventListener("mousedown",e=>this.handleOverlayMouseDown(e)),this.overlayCanvas.addEventListener("mousemove",e=>this.handleOverlayMouseMove(e)),this.overlayCanvas.addEventListener("mouseup",e=>this.handleOverlayMouseUp(e)),this.overlayCanvas.addEventListener("click",e=>this.handleOverlayClick(e)),this.overlayCanvas.addEventListener("mouseleave",()=>{null!==this.hoveredCentroid&&(this.hoveredCentroid=null,this.drawOverlayElements())})}generateInitialData(){this.dataPoints=[];for(let i=0;i<20;i++)this.dataPoints.push({x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin});this.updatePointsCount()}initializeCentroids(){this.centroids=[],this.centroidHistory=[],this.addedCentroids=[];for(let i=0;i<this.k;i++)this.centroids.push({x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin});this.assignments=new Array(this.dataPoints.length).fill(0)}updateK(newK){const oldK=this.k;if(this.k=newK,newK>oldK)for(let i=oldK;i<newK;i++)if(this.centroidHistory.length>0){const restoredCentroid=this.centroidHistory.pop();this.centroids.push(restoredCentroid)}else{const newCentroid={x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin};this.centroids.push(newCentroid),this.addedCentroids.push(newCentroid)}else if(newK<oldK)for(let i=oldK;i>newK;i--){let removedCentroid;if(this.addedCentroids.length>0){const lastAdded=this.addedCentroids.pop(),addedIndex=this.centroids.findIndex(c=>c===lastAdded);-1!==addedIndex&&(removedCentroid=this.centroids.splice(addedIndex,1)[0])}removedCentroid||(removedCentroid=this.centroids.pop()),this.centroidHistory.push(removedCentroid)}this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready";for(let i=0;i<this.assignments.length;i++)if(this.assignments[i]>=newK){const point=this.dataPoints[i];let minDistance=1/0,nearestCentroid=0;for(let j=0;j<newK;j++){const distance=this.euclideanDistance(point,this.centroids[j]);distance<minDistance&&(minDistance=distance,nearestCentroid=j)}this.assignments[i]=nearestCentroid}this.updateChart()}stepForward(){if(this.converged)return;const oldCentroids=this.centroids.map(c=>({...c}));this.assignPoints(),this.updateCentroids(),this.iteration++,this.iterationDisplay.textContent=this.iteration,this.checkConvergence(oldCentroids),this.updateChart()}assignPoints(){for(let i=0;i<this.dataPoints.length;i++)this.assignPoint(i)}assignPoint(pointIndex){const point=this.dataPoints[pointIndex];let minDistance=1/0,nearestCentroid=0;for(let j=0;j<this.centroids.length;j++){const distance=this.euclideanDistance(point,this.centroids[j]);distance<minDistance&&(minDistance=distance,nearestCentroid=j)}this.assignments[pointIndex]=nearestCentroid}updateCentroids(){for(let i=0;i<this.k;i++){const clusterPoints=this.dataPoints.filter((_,idx)=>this.assignments[idx]===i);if(clusterPoints.length>0){const sumX=clusterPoints.reduce((sum,p)=>sum+p.x,0),sumY=clusterPoints.reduce((sum,p)=>sum+p.y,0);this.centroids[i]={x:sumX/clusterPoints.length,y:sumY/clusterPoints.length}}}}checkConvergence(oldCentroids){let maxMovement=0;for(let i=0;i<this.k;i++){const movement=this.euclideanDistance(this.centroids[i],oldCentroids[i]);maxMovement=Math.max(maxMovement,movement)}this.converged=maxMovement<.01,this.statusDisplay.textContent=this.converged?"Converged":"Running"}runToCompletion(){if(this.converged)return;this.isRunning=!0,this.statusDisplay.textContent="Running to completion...";const runStep=()=>{this.converged?this.isRunning=!1:(this.stepForward(),this.converged?this.isRunning=!1:setTimeout(runStep,200))};runStep()}resetTraining(){this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready",this.initializeCentroids(),this.updateChart()}generateNewData(){this.generateInitialData(),this.centroidHistory=[],this.addedCentroids=[],this.initializeCentroids(),this.resetTraining(),this.resetToDefaultBounds()}resetToDefaultBounds(){this.xMin=-5,this.xMax=5,this.yMin=-5,this.yMax=5,this.xLabel="X",this.yLabel="Y",this.chart.options.scales.x.min=this.xMin,this.chart.options.scales.x.max=this.xMax,this.chart.options.scales.y.min=this.yMin,this.chart.options.scales.y.max=this.yMax,this.chart.options.scales.x.title.text=this.xLabel,this.chart.options.scales.y.title.text=this.yLabel,document.getElementById("dataset-info-box").style.display="none",this.chart.update("none")}async loadDataset(datasetKey){const dataset=this.datasets[datasetKey];try{const response=await fetch(dataset.file),lines=(await response.text()).trim().split("\n"),headers=lines[0].split(",").map(h=>h.trim());console.log("Dataset:",datasetKey),console.log("Headers:",headers),console.log("Looking for xColumn:",dataset.xColumn),console.log("Looking for yColumn:",dataset.yColumn);const xColIndex=headers.indexOf(dataset.xColumn),yColIndex=headers.indexOf(dataset.yColumn);if(console.log("xColIndex:",xColIndex),console.log("yColIndex:",yColIndex),-1===xColIndex||-1===yColIndex)return console.error("Required columns not found in dataset"),console.error('xColumn "'+dataset.xColumn+'" found at index:',xColIndex),void console.error('yColumn "'+dataset.yColumn+'" found at index:',yColIndex);this.dataPoints=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(",").map(v=>v.trim()),x=parseFloat(values[xColIndex]),y=parseFloat(values[yColIndex]);isNaN(x)||isNaN(y)||this.dataPoints.push({x:x,y:y})}this.xLabel=dataset.xLabel,this.yLabel=dataset.yLabel,this.chart.options.scales.x.title.text=this.xLabel,this.chart.options.scales.y.title.text=this.yLabel;const xValues=this.dataPoints.map(p=>p.x),yValues=this.dataPoints.map(p=>p.y),xMin=Math.min(...xValues),xMax=Math.max(...xValues),yMin=Math.min(...yValues),yMax=Math.max(...yValues),xPadding=.1*(xMax-xMin),yPadding=.1*(yMax-yMin);this.xMin=xMin-xPadding,this.xMax=xMax+xPadding,this.yMin=yMin-yPadding,this.yMax=yMax+yPadding,this.chart.options.scales.x.min=this.xMin,this.chart.options.scales.x.max=this.xMax,this.chart.options.scales.y.min=this.yMin,this.chart.options.scales.y.max=this.yMax,document.getElementById("dataset-info-title").textContent=dataset.title,document.getElementById("dataset-info-description").textContent=dataset.description,document.getElementById("dataset-info-variables").textContent=dataset.variables,document.getElementById("dataset-info-box").style.display="block",this.updatePointsCount(),this.resetTraining(),this.updateChart()}catch(error){console.error("Error loading dataset:",error),alert("Error loading dataset. Please check the console for details.")}}reset(){this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready",this.generateInitialData(),this.initializeCentroids(),this.updateChart()}euclideanDistance(p1,p2){const dx=p1.x-p2.x,dy=p1.y-p2.y;return Math.sqrt(dx*dx+dy*dy)}updatePointsCount(){this.pointsCount.textContent=this.dataPoints.length}}document.addEventListener("DOMContentLoaded",()=>{new DemoTabController,new KMeansDemo});