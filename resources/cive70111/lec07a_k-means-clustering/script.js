class KMeansDemo{constructor(){this.canvas=document.getElementById("plot"),this.ctx=this.canvas.getContext("2d"),this.kSlider=document.getElementById("k-clusters"),this.kValue=document.getElementById("k-value"),this.stepBtn=document.getElementById("step-btn"),this.finalBtn=document.getElementById("final-btn"),this.resetBtn=document.getElementById("reset-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.showDistancesCheckbox=document.getElementById("show-distances"),this.addDataModeCheckbox=document.getElementById("add-data-mode"),this.iterationDisplay=document.getElementById("iteration-display"),this.statusDisplay=document.getElementById("status-display"),this.pointsCount=document.getElementById("points-count"),this.setupHighDPICanvas(),this.plotWidth=this.displayWidth-80,this.plotHeight=this.displayHeight-80,this.plotX=40,this.plotY=40,this.xMin=-5,this.xMax=5,this.yMin=-5,this.yMax=5,this.k=3,this.dataPoints=[],this.centroids=[],this.assignments=[],this.iteration=0,this.converged=!1,this.isRunning=!1,this.centroidHistory=[],this.addedCentroids=[],this.hoveredCentroid=null,this.draggedCentroid=null,this.isDragging=!1,this.dragOffset={x:0,y:0},this.dragStarted=!1,this.lastMouseX=0,this.lastMouseY=0,this.clusterColors=["#e74c3c","#3498db","#2ecc71","#f39c12","#9b59b6","#1abc9c","#34495e","#e67e22","#8e44ad","#16a085"],this.setupEventListeners(),this.generateInitialData(),this.initializeCentroids(),this.render()}setupHighDPICanvas(){const rect=this.canvas.getBoundingClientRect(),devicePixelRatio=window.devicePixelRatio||1;this.displayWidth=rect.width,this.displayHeight=rect.height,this.canvas.width=this.displayWidth*devicePixelRatio,this.canvas.height=this.displayHeight*devicePixelRatio,this.ctx.scale(devicePixelRatio,devicePixelRatio),this.canvas.style.width=this.displayWidth+"px",this.canvas.style.height=this.displayHeight+"px"}setupEventListeners(){this.kSlider.addEventListener("input",e=>{const newK=parseInt(e.target.value);this.updateK(newK),this.kValue.textContent=this.k}),this.stepBtn.addEventListener("click",()=>this.stepForward()),this.finalBtn.addEventListener("click",()=>this.runToCompletion()),this.resetBtn.addEventListener("click",()=>this.resetTraining()),this.generateDataBtn.addEventListener("click",()=>this.generateNewData()),this.showDistancesCheckbox.addEventListener("change",()=>{this.render()}),this.addDataModeCheckbox.addEventListener("change",()=>{if(!this.isRunning&&!this.isDragging){const centroidIndex=this.getCentroidAtPosition(this.lastMouseX||0,this.lastMouseY||0);this.canvas.style.cursor=null!==centroidIndex?"grab":this.addDataModeCheckbox.checked?"crosshair":"default"}}),this.canvas.addEventListener("mousedown",e=>this.handleMouseDown(e)),this.canvas.addEventListener("mousemove",e=>this.handleMouseMove(e)),this.canvas.addEventListener("mouseup",e=>this.handleMouseUp(e)),this.canvas.addEventListener("click",e=>{this.isRunning||this.dragStarted||!this.addDataModeCheckbox.checked||this.addDataPoint(e),this.dragStarted=!1}),this.canvas.addEventListener("mouseleave",()=>{null!==this.hoveredCentroid&&(this.hoveredCentroid=null,this.render())})}generateInitialData(){this.dataPoints=[];for(let i=0;i<20;i++)this.dataPoints.push({x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin});this.updatePointsCount()}initializeCentroids(){this.centroids=[],this.centroidHistory=[],this.addedCentroids=[];for(let i=0;i<this.k;i++)this.centroids.push({x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin});this.assignments=new Array(this.dataPoints.length).fill(0)}updateK(newK){const oldK=this.k;if(this.k=newK,newK>oldK)for(let i=oldK;i<newK;i++)if(this.centroidHistory.length>0){const restoredCentroid=this.centroidHistory.pop();this.centroids.push(restoredCentroid)}else{const newCentroid={x:Math.random()*(this.xMax-this.xMin)+this.xMin,y:Math.random()*(this.yMax-this.yMin)+this.yMin};this.centroids.push(newCentroid),this.addedCentroids.push(newCentroid)}else if(newK<oldK)for(let i=oldK;i>newK;i--){let removedCentroid;if(this.addedCentroids.length>0){const lastAdded=this.addedCentroids.pop(),addedIndex=this.centroids.findIndex(c=>c===lastAdded);-1!==addedIndex&&(removedCentroid=this.centroids.splice(addedIndex,1)[0])}removedCentroid||(removedCentroid=this.centroids.pop()),this.centroidHistory.push(removedCentroid)}this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready";for(let i=0;i<this.assignments.length;i++)if(this.assignments[i]>=newK){const point=this.dataPoints[i];let minDistance=1/0,nearestCentroid=0;for(let j=0;j<newK;j++){const distance=this.euclideanDistance(point,this.centroids[j]);distance<minDistance&&(minDistance=distance,nearestCentroid=j)}this.assignments[i]=nearestCentroid}this.render()}handleMouseDown(event){if(this.isRunning)return;const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,centroidIndex=this.getCentroidAtPosition(canvasX,canvasY);if(null!==centroidIndex){this.isDragging=!0,this.draggedCentroid=centroidIndex,this.dragStarted=!1;const centroid=this.centroids[centroidIndex],centroidCanvasX=this.dataToCanvasX(centroid.x),centroidCanvasY=this.dataToCanvasY(centroid.y);this.dragOffset.x=canvasX-centroidCanvasX,this.dragOffset.y=canvasY-centroidCanvasY,this.canvas.style.cursor="grabbing",event.preventDefault()}}handleMouseMove(event){if(this.isRunning)return void(this.canvas.style.cursor="default");const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top;if(this.lastMouseX=canvasX,this.lastMouseY=canvasY,this.isDragging&&null!==this.draggedCentroid){this.dragStarted=!0;const dataX=this.canvasToDataX(canvasX-this.dragOffset.x),dataY=this.canvasToDataY(canvasY-this.dragOffset.y),constrainedX=Math.max(this.xMin,Math.min(this.xMax,dataX)),constrainedY=Math.max(this.yMin,Math.min(this.yMax,dataY));this.centroids[this.draggedCentroid].x=constrainedX,this.centroids[this.draggedCentroid].y=constrainedY,this.iteration>0&&(this.converged=!1,this.statusDisplay.textContent="Ready",this.assignPoints()),this.render()}else{const centroidIndex=this.getCentroidAtPosition(canvasX,canvasY);null!==centroidIndex?(this.canvas.style.cursor="grab",this.hoveredCentroid!==centroidIndex&&(this.hoveredCentroid=centroidIndex,this.render())):(this.canvas.style.cursor=this.addDataModeCheckbox.checked?"crosshair":"default",null!==this.hoveredCentroid&&(this.hoveredCentroid=null,this.render()))}}handleMouseUp(event){if(this.isDragging){this.isDragging=!1,this.draggedCentroid=null,this.canvas.style.cursor=this.addDataModeCheckbox.checked?"crosshair":"default";const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,centroidIndex=this.getCentroidAtPosition(canvasX,canvasY);null!==centroidIndex?(this.canvas.style.cursor="grab",this.hoveredCentroid=centroidIndex):this.hoveredCentroid=null,this.render()}}getCentroidAtPosition(canvasX,canvasY){for(let i=0;i<this.centroids.length;i++){const centroid=this.centroids[i],centroidCanvasX=this.dataToCanvasX(centroid.x),centroidCanvasY=this.dataToCanvasY(centroid.y);if(Math.sqrt(Math.pow(canvasX-centroidCanvasX,2)+Math.pow(canvasY-centroidCanvasY,2))<=12)return i}return null}addDataPoint(event){const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,dataX=this.canvasToDataX(canvasX),dataY=this.canvasToDataY(canvasY);dataX>=this.xMin&&dataX<=this.xMax&&dataY>=this.yMin&&dataY<=this.yMax&&(this.dataPoints.push({x:dataX,y:dataY}),this.assignments.push(0),this.updatePointsCount(),this.iteration>0&&this.assignPoint(this.dataPoints.length-1),this.converged&&(this.converged=!1,this.statusDisplay.textContent="Ready"),this.render())}stepForward(){if(this.converged)return;const oldCentroids=this.centroids.map(c=>({...c}));this.assignPoints(),this.updateCentroids(),this.iteration++,this.iterationDisplay.textContent=this.iteration,this.checkConvergence(oldCentroids),this.render()}assignPoints(){for(let i=0;i<this.dataPoints.length;i++)this.assignPoint(i)}assignPoint(pointIndex){const point=this.dataPoints[pointIndex];let minDistance=1/0,nearestCentroid=0;for(let j=0;j<this.centroids.length;j++){const distance=this.euclideanDistance(point,this.centroids[j]);distance<minDistance&&(minDistance=distance,nearestCentroid=j)}this.assignments[pointIndex]=nearestCentroid}updateCentroids(){for(let i=0;i<this.k;i++){const clusterPoints=this.dataPoints.filter((_,idx)=>this.assignments[idx]===i);if(clusterPoints.length>0){const sumX=clusterPoints.reduce((sum,p)=>sum+p.x,0),sumY=clusterPoints.reduce((sum,p)=>sum+p.y,0);this.centroids[i]={x:sumX/clusterPoints.length,y:sumY/clusterPoints.length}}}}checkConvergence(oldCentroids){let maxMovement=0;for(let i=0;i<this.k;i++){const movement=this.euclideanDistance(this.centroids[i],oldCentroids[i]);maxMovement=Math.max(maxMovement,movement)}this.converged=maxMovement<.01,this.statusDisplay.textContent=this.converged?"Converged":"Running"}runToCompletion(){if(this.converged)return;this.isRunning=!0,this.statusDisplay.textContent="Running to completion...";const runStep=()=>{this.converged?this.isRunning=!1:(this.stepForward(),this.converged?this.isRunning=!1:setTimeout(runStep,200))};runStep()}resetTraining(){this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready",this.initializeCentroids(),this.render()}generateNewData(){this.generateInitialData(),this.centroidHistory=[],this.addedCentroids=[],this.initializeCentroids(),this.resetTraining()}reset(){this.iteration=0,this.converged=!1,this.isRunning=!1,this.iterationDisplay.textContent="0",this.statusDisplay.textContent="Ready",this.generateInitialData(),this.initializeCentroids(),this.render()}euclideanDistance(p1,p2){const dx=p1.x-p2.x,dy=p1.y-p2.y;return Math.sqrt(dx*dx+dy*dy)}updatePointsCount(){this.pointsCount.textContent=this.dataPoints.length}dataToCanvasX(dataX){return this.plotX+(dataX-this.xMin)*(this.plotWidth/(this.xMax-this.xMin))}dataToCanvasY(dataY){return this.plotY+(this.yMax-dataY)*(this.plotHeight/(this.yMax-this.yMin))}canvasToDataX(canvasX){return this.xMin+(canvasX-this.plotX)*(this.xMax-this.xMin)/this.plotWidth}canvasToDataY(canvasY){return this.yMax-(canvasY-this.plotY)*(this.yMax-this.yMin)/this.plotHeight}render(){this.ctx.clearRect(0,0,this.displayWidth,this.displayHeight),this.drawGrid(),this.drawAxes(),this.drawDataPoints(),this.drawClusterLines(),this.drawCentroids()}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=.5;for(let x=Math.ceil(this.xMin);x<=Math.floor(this.xMax);x++){const canvasX=this.dataToCanvasX(x);this.ctx.beginPath(),this.ctx.moveTo(canvasX,this.plotY),this.ctx.lineTo(canvasX,this.plotY+this.plotHeight),this.ctx.stroke()}for(let y=Math.ceil(this.yMin);y<=Math.floor(this.yMax);y++){const canvasY=this.dataToCanvasY(y);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,canvasY),this.ctx.lineTo(this.plotX+this.plotWidth,canvasY),this.ctx.stroke()}}drawAxes(){this.ctx.strokeStyle="#333",this.ctx.lineWidth=1;const y0=this.dataToCanvasY(0);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,y0),this.ctx.lineTo(this.plotX+this.plotWidth,y0),this.ctx.stroke();const x0=this.dataToCanvasX(0);this.ctx.beginPath(),this.ctx.moveTo(x0,this.plotY),this.ctx.lineTo(x0,this.plotY+this.plotHeight),this.ctx.stroke(),this.ctx.fillStyle="#666",this.ctx.font="12px sans-serif",this.ctx.textAlign="center",this.ctx.fillText("X",this.plotX+this.plotWidth-10,y0-5),this.ctx.textAlign="left",this.ctx.fillText("Y",x0+5,this.plotY+15)}drawDataPoints(){this.dataPoints.forEach((point,index)=>{const canvasX=this.dataToCanvasX(point.x),canvasY=this.dataToCanvasY(point.y),clusterIndex=this.assignments[index]||0,color=this.clusterColors[clusterIndex%this.clusterColors.length];this.ctx.strokeStyle=color,this.ctx.fillStyle="white",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.arc(canvasX,canvasY,6,0,2*Math.PI),this.ctx.fill(),this.ctx.stroke()})}drawClusterLines(){const showAllLines=this.showDistancesCheckbox.checked,showHoverLines=!showAllLines&&null!==this.hoveredCentroid;if(showAllLines||showHoverLines){if(this.ctx.lineWidth=1,this.ctx.setLineDash([5,5]),showAllLines)for(let centroidIndex=0;centroidIndex<this.centroids.length;centroidIndex++){const centroid=this.centroids[centroidIndex],color=this.clusterColors[centroidIndex%this.clusterColors.length];this.ctx.strokeStyle=color;const centroidCanvasX=this.dataToCanvasX(centroid.x),centroidCanvasY=this.dataToCanvasY(centroid.y);this.dataPoints.forEach((point,index)=>{if(this.assignments[index]===centroidIndex){const pointCanvasX=this.dataToCanvasX(point.x),pointCanvasY=this.dataToCanvasY(point.y);this.ctx.beginPath(),this.ctx.moveTo(centroidCanvasX,centroidCanvasY),this.ctx.lineTo(pointCanvasX,pointCanvasY),this.ctx.stroke()}})}else if(showHoverLines){const hoveredCentroidIndex=this.hoveredCentroid,centroid=this.centroids[hoveredCentroidIndex],color=this.clusterColors[hoveredCentroidIndex%this.clusterColors.length];this.ctx.strokeStyle=color;const centroidCanvasX=this.dataToCanvasX(centroid.x),centroidCanvasY=this.dataToCanvasY(centroid.y);this.dataPoints.forEach((point,index)=>{if(this.assignments[index]===hoveredCentroidIndex){const pointCanvasX=this.dataToCanvasX(point.x),pointCanvasY=this.dataToCanvasY(point.y);this.ctx.beginPath(),this.ctx.moveTo(centroidCanvasX,centroidCanvasY),this.ctx.lineTo(pointCanvasX,pointCanvasY),this.ctx.stroke()}})}this.ctx.setLineDash([])}}drawCentroids(){this.centroids.forEach((centroid,index)=>{const canvasX=this.dataToCanvasX(centroid.x),canvasY=this.dataToCanvasY(centroid.y),color=this.clusterColors[index%this.clusterColors.length];this.ctx.fillStyle=color,this.ctx.strokeStyle="#333",this.ctx.lineWidth=1,this.ctx.beginPath(),this.ctx.arc(canvasX,canvasY,8,0,2*Math.PI),this.ctx.fill(),this.ctx.stroke()})}}document.addEventListener("DOMContentLoaded",()=>{new DemoTabController,new KMeansDemo});