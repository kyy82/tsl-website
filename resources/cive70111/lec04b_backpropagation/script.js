class BackpropagationDemo{constructor(){this.networkContainer=document.getElementById("network-container"),this.lossValueDisplay=document.getElementById("loss-value"),this.stepCountDisplay=document.getElementById("step-count"),this.lossCanvas=document.getElementById("loss-canvas"),this.lossChart=null,this.input1Slider=document.getElementById("input1"),this.input2Slider=document.getElementById("input2"),this.input1Num=document.getElementById("input1-num"),this.input2Num=document.getElementById("input2-num"),this.targetInput=document.getElementById("target"),this.learningRateSlider=document.getElementById("learning-rate"),this.learningRateNum=document.getElementById("learning-rate-num"),this.stepBtn=document.getElementById("step-btn"),this.resetBtn=document.getElementById("reset-btn"),this.architecture=[2,3,1],this.weights=[],this.activations=[],this.preActivations=[],this.gradients={weights:[]},this.stepCount=0,this.lossHistory=[],this.currentLoss=0,this.highlightedConnection=null,this.nodePositions=[],this.initializeNetwork(),this.setupEventListeners(),this.tabController=new DemoTabController,this.renderNetwork(),this.forwardPass(),this.updateVisualization(),this.initializeLossChart()}initializeNetwork(){this.weights=[];for(let i=0;i<this.architecture.length-1;i++){const currentSize=this.architecture[i],nextSize=this.architecture[i+1],layerWeights=[];for(let j=0;j<nextSize;j++){const neuronWeights=[];for(let k=0;k<currentSize;k++){const limit=Math.sqrt(6/(currentSize+nextSize));neuronWeights.push((2*Math.random()-1)*limit)}layerWeights.push(neuronWeights)}this.weights.push(layerWeights)}this.gradients.weights=this.weights.map(layer=>layer.map(neuron=>neuron.map(()=>0)))}setupEventListeners(){[this.input1Slider,this.input2Slider].forEach((slider,index)=>{slider.addEventListener("input",e=>{[this.input1Num,this.input2Num][index].value=e.target.value,this.forwardPass(),this.backwardPass(),this.updateVisualization()})}),[this.input1Num,this.input2Num].forEach((input,index)=>{input.addEventListener("input",e=>{const slider=[this.input1Slider,this.input2Slider][index],inputValue=e.target.value;if(""===inputValue||"-"===inputValue||inputValue.endsWith(".")||"-."===inputValue)return;const numValue=parseFloat(inputValue);if(isNaN(numValue))return;const clampedValue=Math.max(-5,Math.min(5,numValue));slider.value=clampedValue,clampedValue!==numValue&&(e.target.value=clampedValue),this.forwardPass(),this.backwardPass(),this.updateVisualization()})}),this.targetInput.addEventListener("input",e=>{const inputValue=e.target.value;if(""===inputValue||"-"===inputValue||inputValue.endsWith(".")||"-."===inputValue)return;const numValue=parseFloat(inputValue);isNaN(numValue)||(this.forwardPass(),this.backwardPass(),this.updateVisualization())}),this.learningRateSlider.addEventListener("input",e=>{this.learningRateNum.value=e.target.value}),this.learningRateNum.addEventListener("input",e=>{const inputValue=e.target.value;if(""===inputValue)return void(this.learningRateSlider.value=.01);if(""===inputValue||"-"===inputValue||inputValue.endsWith(".")||"-."===inputValue)return;const numValue=parseFloat(inputValue);if(isNaN(numValue))return;const clampedValue=Math.max(0,Math.min(1,numValue));this.learningRateSlider.value=clampedValue,clampedValue!==numValue&&(e.target.value=clampedValue)}),this.stepBtn.addEventListener("click",()=>this.stepOptimization()),this.resetBtn.addEventListener("click",()=>this.resetNetwork())}forwardPass(){const inputs=[parseFloat(this.input1Slider.value),parseFloat(this.input2Slider.value)];this.activations=[inputs],this.preActivations=[inputs];for(let i=0;i<this.weights.length;i++){const currentActivations=this.activations[i],layerWeights=this.weights[i],nextPreActivations=[],nextActivations=[];for(let j=0;j<layerWeights.length;j++){let activation,sum=0;for(let k=0;k<currentActivations.length;k++)sum+=currentActivations[k]*layerWeights[j][k];nextPreActivations.push(sum),activation=i===this.weights.length-1?sum:Math.max(0,sum),nextActivations.push(activation)}this.preActivations.push(nextPreActivations),this.activations.push(nextActivations)}const prediction=this.activations[this.activations.length-1][0],targetValue=parseFloat(this.targetInput.value),target=isNaN(targetValue)?0:targetValue;this.currentLoss=.5*Math.pow(prediction-target,2)}backwardPass(){const targetValue=parseFloat(this.targetInput.value),target=isNaN(targetValue)?0:targetValue,deltaActivations=[],outputDelta=[this.activations[this.activations.length-1][0]-target];deltaActivations.push(outputDelta);for(let i=this.weights.length-1;i>=0;i--){const currentDeltas=deltaActivations[deltaActivations.length-1],layerWeights=this.weights[i];for(let j=0;j<layerWeights.length;j++)for(let k=0;k<layerWeights[j].length;k++)this.gradients.weights[i][j][k]=currentDeltas[j]*this.activations[i][k];if(i>0){const prevDeltas=[];for(let k=0;k<this.activations[i].length;k++){let delta=0;for(let j=0;j<layerWeights.length;j++)delta+=currentDeltas[j]*layerWeights[j][k];i>0&&(delta*=this.preActivations[i][k]>0?1:0),prevDeltas.push(delta)}deltaActivations.push(prevDeltas)}}}stepOptimization(){const learningRate=parseFloat(this.learningRateSlider.value);for(let i=0;i<this.weights.length;i++)for(let j=0;j<this.weights[i].length;j++)for(let k=0;k<this.weights[i][j].length;k++)this.weights[i][j][k]-=learningRate*this.gradients.weights[i][j][k];this.stepCount++,this.lossHistory.push(this.currentLoss),this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.updateLossChart(),this.lossHistory.length>100&&this.lossHistory.shift()}resetNetwork(){this.initializeNetwork(),this.stepCount=0,this.lossHistory=[],this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.updateLossChart()}renderNetwork(){this.networkContainer.innerHTML="";const containerWidth=this.networkContainer.clientWidth-100,layerSpacing=(this.networkContainer.clientHeight-100)/(this.architecture.length+.5);this.nodePositions=[],this.architecture.forEach((layerSize,layerIndex)=>{const layerPositions=[],nodeSpacing=Math.min(containerWidth/(layerSize+.5),120),startX=(containerWidth-(layerSize-1)*nodeSpacing)/2+50,layerLabel=document.createElement("div");layerLabel.className="network-layer-label",layerLabel.style.left="10px",layerLabel.style.top=(layerIndex+1)*layerSpacing+30-10+"px",0===layerIndex?layerLabel.textContent="Input":layerIndex===this.architecture.length-1?layerLabel.textContent="Output":layerLabel.textContent="Hidden",this.networkContainer.appendChild(layerLabel);for(let nodeIndex=0;nodeIndex<layerSize;nodeIndex++){const node=document.createElement("div");node.className="network-node "+(0===layerIndex?"input":layerIndex===this.architecture.length-1?"output":"hidden");const x=startX+nodeIndex*nodeSpacing-22.5,y=(layerIndex+1)*layerSpacing+30-22.5;node.style.left=`${x}px`,node.style.top=`${y}px`,node.textContent="0.00",layerPositions.push({x:x+22.5,y:y+22.5}),this.networkContainer.appendChild(node)}this.nodePositions.push(layerPositions)}),this.drawConnections()}drawConnections(){document.querySelectorAll(".network-edge").forEach(el=>el.remove());for(let layerIndex=0;layerIndex<this.architecture.length-1;layerIndex++){const currentPositions=this.nodePositions[layerIndex],nextPositions=this.nodePositions[layerIndex+1];currentPositions.forEach((fromPos,fromIndex)=>{nextPositions.forEach((toPos,toIndex)=>{const edge=document.createElement("div");edge.className="network-edge";const dx=toPos.x-fromPos.x,dy=toPos.y-fromPos.y,length=Math.sqrt(dx*dx+dy*dy),angle=Math.atan2(dy,dx);edge.style.left=`${fromPos.x}px`,edge.style.top=`${fromPos.y}px`,edge.style.width=`${length}px`,edge.style.transform=`rotate(${angle}rad)`,this.styleConnection(edge,layerIndex,toIndex,fromIndex),this.networkContainer.appendChild(edge)})})}}styleConnection(edge,layerIndex,toIndex,fromIndex){const weight=this.weights[layerIndex][toIndex][fromIndex];let thickness=3;const connectionId=`${layerIndex}-${toIndex}-${fromIndex}`;this.highlightedConnection===connectionId&&(thickness=6);const weightMagnitude=Math.abs(weight),saturation=100*Math.min(weightMagnitude/2,1);let color;color=weight>0?`hsl(120, ${saturation}%, 40%)`:`hsl(0, ${saturation}%, 40%)`,edge.style.height=`${thickness}px`,edge.style.background=color,edge.style.opacity=this.highlightedConnection===connectionId?1:.8}updateVisualization(){const nodes=document.querySelectorAll(".network-node");let nodeIndex=0;this.activations.forEach((layerActivations,layerIdx)=>{layerActivations.forEach((activation,nodeIdx)=>{const node=nodes[nodeIndex];if(node){node.textContent=activation.toFixed(2);const isPositive=activation>=0,intensity=Math.min(Math.abs(activation),3)/3,alpha=.3+.5*intensity;let baseColor;baseColor=0===layerIdx?[25,118,210]:layerIdx===this.activations.length-1?[56,142,60]:[123,31,162],node.style.backgroundColor=`rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`,node.style.color=intensity>.6?"white":isPositive?`rgb(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]})`:"#d32f2f"}nodeIndex++})}),this.drawConnections(),this.updateTables(),this.lossValueDisplay.textContent=this.currentLoss.toFixed(4),this.stepCountDisplay.textContent=this.stepCount}updateTables(){this.updateWeightsTable(),this.updateGradientsTable()}updateWeightsTable(){const container=document.getElementById("weights-table");if(!container)return;let html="";html+='<div class="layer-section">\n            <div class="layer-title">Input → Hidden Weights</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">Hidden → Output</div>\n                \n                <div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const weight=this.weights[0][toIndex][0];html+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const weight=this.weights[0][toIndex][1];html+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let fromIndex=0;fromIndex<3;fromIndex++){const weight=this.weights[1][0][fromIndex];html+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(1, 0, ${fromIndex})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${fromIndex+1} →:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+="</div></div></div>",container.innerHTML=html}updateGradientsTable(){const container=document.getElementById("gradients-table");if(!container)return;let html="";html+='<div class="layer-section">\n            <div class="layer-title">Input → Hidden Gradients</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">Hidden → Output</div>\n                \n                <div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const gradient=this.gradients.weights[0][toIndex][0],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const gradient=this.gradients.weights[0][toIndex][1],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let fromIndex=0;fromIndex<3;fromIndex++){const gradient=this.gradients.weights[1][0][fromIndex],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(1, 0, ${fromIndex})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${fromIndex+1} →:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+="</div></div></div>",container.innerHTML=html}highlightConnection(layerIndex,toIndex,fromIndex){this.highlightedConnection=`${layerIndex}-${toIndex}-${fromIndex}`,this.drawConnections()}clearHighlight(){this.highlightedConnection=null,this.drawConnections()}initializeLossChart(){this.lossChart=new Chart(this.lossCanvas.getContext("2d"),{type:"line",data:{labels:[],datasets:[{label:"MSE Loss",data:[],borderColor:"#dc3545",backgroundColor:"rgba(220, 53, 69, 0.1)",borderWidth:2,fill:!1,tension:.1,pointRadius:3,pointBackgroundColor:"#dc3545",pointBorderColor:"#dc3545"}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{title:{display:!0,text:"Training Steps"},grid:{color:"#ddd"}},y:{title:{display:!0,text:"MSE Loss"},grid:{color:"#ddd"},beginAtZero:!1}},plugins:{legend:{display:!1},title:{display:!0,text:"MSE Loss Over Time",font:{size:14}}},interaction:{intersect:!1,mode:"index"},animation:{duration:0}}})}updateLossChart(){if(!this.lossChart)return;const labels=this.lossHistory.map((_,index)=>index);this.lossChart.data.labels=labels,this.lossChart.data.datasets[0].data=this.lossHistory,this.lossChart.update("none")}}document.addEventListener("DOMContentLoaded",()=>{window.demo=new BackpropagationDemo});