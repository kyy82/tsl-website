class BackpropagationDemo{constructor(){this.networkContainer=document.getElementById("network-container"),this.lossValueDisplay=document.getElementById("loss-value"),this.stepCountDisplay=document.getElementById("step-count"),this.lossCanvas=document.getElementById("loss-canvas"),this.lossCtx=this.lossCanvas.getContext("2d"),this.input1Slider=document.getElementById("input1"),this.input2Slider=document.getElementById("input2"),this.input1Num=document.getElementById("input1-num"),this.input2Num=document.getElementById("input2-num"),this.targetInput=document.getElementById("target"),this.learningRateSlider=document.getElementById("learning-rate"),this.learningRateNum=document.getElementById("learning-rate-num"),this.stepBtn=document.getElementById("step-btn"),this.resetBtn=document.getElementById("reset-btn"),this.architecture=[2,3,1],this.weights=[],this.activations=[],this.preActivations=[],this.gradients={weights:[]},this.stepCount=0,this.lossHistory=[],this.currentLoss=0,this.highlightedConnection=null,this.nodePositions=[],this.initializeNetwork(),this.setupEventListeners(),this.renderNetwork(),this.forwardPass(),this.updateVisualization(),this.drawLossGraph()}initializeNetwork(){this.weights=[];for(let t=0;t<this.architecture.length-1;t++){const e=this.architecture[t],i=this.architecture[t+1],s=[];for(let t=0;t<i;t++){const t=[];for(let s=0;s<e;s++){const s=Math.sqrt(6/(e+i));t.push((2*Math.random()-1)*s)}s.push(t)}this.weights.push(s)}this.gradients.weights=this.weights.map((t=>t.map((t=>t.map((()=>0))))))}setupEventListeners(){[this.input1Slider,this.input2Slider].forEach(((t,e)=>{t.addEventListener("input",(t=>{[this.input1Num,this.input2Num][e].value=t.target.value,this.forwardPass(),this.backwardPass(),this.updateVisualization()}))})),[this.input1Num,this.input2Num].forEach(((t,e)=>{t.addEventListener("input",(t=>{const i=[this.input1Slider,this.input2Slider][e],s=t.target.value;if(""===s||"-"===s||s.endsWith(".")||"-."===s)return;const n=parseFloat(s);if(isNaN(n))return;const a=Math.max(-5,Math.min(5,n));i.value=a,a!==n&&(t.target.value=a),this.forwardPass(),this.backwardPass(),this.updateVisualization()}))})),this.targetInput.addEventListener("input",(t=>{const e=t.target.value;if(""===e||"-"===e||e.endsWith(".")||"-."===e)return;const i=parseFloat(e);isNaN(i)||(this.forwardPass(),this.backwardPass(),this.updateVisualization())})),this.learningRateSlider.addEventListener("input",(t=>{this.learningRateNum.value=t.target.value})),this.learningRateNum.addEventListener("input",(t=>{const e=t.target.value;if(""===e)return void(this.learningRateSlider.value=.01);if(""===e||"-"===e||e.endsWith(".")||"-."===e)return;const i=parseFloat(e);if(isNaN(i))return;const s=Math.max(0,Math.min(1,i));this.learningRateSlider.value=s,s!==i&&(t.target.value=s)})),this.stepBtn.addEventListener("click",(()=>this.stepOptimization())),this.resetBtn.addEventListener("click",(()=>this.resetNetwork()))}forwardPass(){const t=[parseFloat(this.input1Slider.value),parseFloat(this.input2Slider.value)];this.activations=[t],this.preActivations=[t];for(let t=0;t<this.weights.length;t++){const e=this.activations[t],i=this.weights[t],s=[],n=[];for(let a=0;a<i.length;a++){let o,h=0;for(let t=0;t<e.length;t++)h+=e[t]*i[a][t];s.push(h),o=t===this.weights.length-1?h:Math.max(0,h),n.push(o)}this.preActivations.push(s),this.activations.push(n)}const e=this.activations[this.activations.length-1][0],i=parseFloat(this.targetInput.value),s=isNaN(i)?0:i;this.currentLoss=.5*Math.pow(e-s,2)}backwardPass(){const t=parseFloat(this.targetInput.value),e=isNaN(t)?0:t,i=[],s=[this.activations[this.activations.length-1][0]-e];i.push(s);for(let t=this.weights.length-1;t>=0;t--){const e=i[i.length-1],s=this.weights[t];for(let i=0;i<s.length;i++)for(let n=0;n<s[i].length;n++)this.gradients.weights[t][i][n]=e[i]*this.activations[t][n];if(t>0){const n=[];for(let i=0;i<this.activations[t].length;i++){let a=0;for(let t=0;t<s.length;t++)a+=e[t]*s[t][i];t>0&&(a*=this.preActivations[t][i]>0?1:0),n.push(a)}i.push(n)}}}stepOptimization(){const t=parseFloat(this.learningRateSlider.value);for(let e=0;e<this.weights.length;e++)for(let i=0;i<this.weights[e].length;i++)for(let s=0;s<this.weights[e][i].length;s++)this.weights[e][i][s]-=t*this.gradients.weights[e][i][s];this.stepCount++,this.lossHistory.push(this.currentLoss),this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.drawLossGraph(),this.lossHistory.length>100&&this.lossHistory.shift()}resetNetwork(){this.initializeNetwork(),this.stepCount=0,this.lossHistory=[],this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.drawLossGraph()}renderNetwork(){this.networkContainer.innerHTML="";const t=this.networkContainer.clientWidth-100,e=(this.networkContainer.clientHeight-100)/(this.architecture.length+.5);this.nodePositions=[],this.architecture.forEach(((i,s)=>{const n=[],a=Math.min(t/(i+.5),120),o=(t-(i-1)*a)/2+50,h=document.createElement("div");h.className="network-layer-label",h.style.left="10px",h.style.top=(s+1)*e+30-10+"px",0===s?h.textContent="Input":s===this.architecture.length-1?h.textContent="Output":h.textContent="Hidden",this.networkContainer.appendChild(h);for(let t=0;t<i;t++){const i=document.createElement("div");i.className="network-node "+(0===s?"input":s===this.architecture.length-1?"output":"hidden");const h=o+t*a-22.5,l=(s+1)*e+30-22.5;i.style.left=`${h}px`,i.style.top=`${l}px`,i.textContent="0.00",n.push({x:h+22.5,y:l+22.5}),this.networkContainer.appendChild(i)}this.nodePositions.push(n)})),this.drawConnections()}drawConnections(){document.querySelectorAll(".network-edge").forEach((t=>t.remove()));for(let t=0;t<this.architecture.length-1;t++){const e=this.nodePositions[t],i=this.nodePositions[t+1];e.forEach(((e,s)=>{i.forEach(((i,n)=>{const a=document.createElement("div");a.className="network-edge";const o=i.x-e.x,h=i.y-e.y,l=Math.sqrt(o*o+h*h),r=Math.atan2(h,o);a.style.left=`${e.x}px`,a.style.top=`${e.y}px`,a.style.width=`${l}px`,a.style.transform=`rotate(${r}rad)`,this.styleConnection(a,t,n,s),this.networkContainer.appendChild(a)}))}))}}styleConnection(t,e,i,s){const n=this.weights[e][i][s];let a=3;const o=`${e}-${i}-${s}`;this.highlightedConnection===o&&(a=6);const h=Math.abs(n),l=100*Math.min(h/2,1);let r;r=n>0?`hsl(120, ${l}%, 40%)`:`hsl(0, ${l}%, 40%)`,t.style.height=`${a}px`,t.style.background=r,t.style.opacity=this.highlightedConnection===o?1:.8}updateVisualization(){const t=document.querySelectorAll(".network-node");let e=0;this.activations.forEach(((i,s)=>{i.forEach(((i,n)=>{const a=t[e];if(a){a.textContent=i.toFixed(2);const t=i>=0,e=Math.min(Math.abs(i),3)/3,n=.3+.5*e;let o;o=0===s?[25,118,210]:s===this.activations.length-1?[56,142,60]:[123,31,162],a.style.backgroundColor=`rgba(${o[0]}, ${o[1]}, ${o[2]}, ${n})`,a.style.color=e>.6?"white":t?`rgb(${o[0]}, ${o[1]}, ${o[2]})`:"#d32f2f"}e++}))})),this.drawConnections(),this.updateTables(),this.lossValueDisplay.textContent=this.currentLoss.toFixed(4),this.stepCountDisplay.textContent=this.stepCount}updateTables(){this.updateWeightsTable(),this.updateGradientsTable()}updateWeightsTable(){const t=document.getElementById("weights-table");if(!t)return;let e="";e+='<div class="layer-section">\n            <div class="layer-title">Input → Hidden Weights</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">Hidden → Output</div>\n                \n                <div class="column-data">';for(let t=0;t<3;t++){const i=this.weights[0][t][0];e+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(0, ${t}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${t+1}:</span>\n                <span class="connection-value ${i>=0?"positive-value":"negative-value"}">${i.toFixed(3)}</span>\n            </div>`}e+='</div><div class="column-data">';for(let t=0;t<3;t++){const i=this.weights[0][t][1];e+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(0, ${t}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${t+1}:</span>\n                <span class="connection-value ${i>=0?"positive-value":"negative-value"}">${i.toFixed(3)}</span>\n            </div>`}e+='</div><div class="column-data">';for(let t=0;t<3;t++){const i=this.weights[1][0][t];e+=`<div class="weight-row" \n                onmouseover="demo.highlightConnection(1, 0, ${t})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${t+1} →:</span>\n                <span class="connection-value ${i>=0?"positive-value":"negative-value"}">${i.toFixed(3)}</span>\n            </div>`}e+="</div></div></div>",t.innerHTML=e}updateGradientsTable(){const t=document.getElementById("gradients-table");if(!t)return;let e="";e+='<div class="layer-section">\n            <div class="layer-title">Input → Hidden Gradients</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">Hidden → Output</div>\n                \n                <div class="column-data">';for(let t=0;t<3;t++){const i=this.gradients.weights[0][t][0],s=i>=0?"positive-value":"negative-value";Math.abs(i);e+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${t}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${t+1}:</span>\n                <span class="connection-value ${s}">${i.toFixed(3)}</span>\n            </div>`}e+='</div><div class="column-data">';for(let t=0;t<3;t++){const i=this.gradients.weights[0][t][1],s=i>=0?"positive-value":"negative-value";Math.abs(i);e+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${t}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${t+1}:</span>\n                <span class="connection-value ${s}">${i.toFixed(3)}</span>\n            </div>`}e+='</div><div class="column-data">';for(let t=0;t<3;t++){const i=this.gradients.weights[1][0][t],s=i>=0?"positive-value":"negative-value";Math.abs(i);e+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(1, 0, ${t})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${t+1} →:</span>\n                <span class="connection-value ${s}">${i.toFixed(3)}</span>\n            </div>`}e+="</div></div></div>",t.innerHTML=e}highlightConnection(t,e,i){this.highlightedConnection=`${t}-${e}-${i}`,this.drawConnections()}clearHighlight(){this.highlightedConnection=null,this.drawConnections()}drawLossGraph(){const t=this.lossCtx,e=this.lossCanvas;if(t.clearRect(0,0,e.width,e.height),this.lossHistory.length<2)return;const i=Math.max(...this.lossHistory),s=Math.min(...this.lossHistory),n=i-s||1;t.strokeStyle="#ddd",t.lineWidth=1,t.beginPath(),t.moveTo(40,20),t.lineTo(40,180),t.lineTo(380,180),t.stroke(),t.strokeStyle="#dc3545",t.lineWidth=2,t.beginPath();const a=340/(this.lossHistory.length-1);this.lossHistory.forEach(((e,i)=>{const o=40+i*a,h=180-(e-s)/n*160;0===i?t.moveTo(o,h):t.lineTo(o,h)})),t.stroke(),t.fillStyle="#666",t.font="12px monospace",t.textAlign="right",t.fillText(i.toFixed(3),35,25),t.fillText(s.toFixed(3),35,185),t.textAlign="center",t.fillText("Steps",210,200)}}document.addEventListener("DOMContentLoaded",(()=>{window.demo=new BackpropagationDemo}));