class ClassificationDemo{constructor(){this.canvas=document.getElementById("plot"),this.ctx=this.canvas.getContext("2d"),this.alphaSlider=document.getElementById("alpha"),this.betaSlider=document.getElementById("beta"),this.alphaValue=document.getElementById("alpha-value"),this.betaValue=document.getElementById("beta-value"),this.equation=document.getElementById("equation"),this.accuracyDisplay=document.getElementById("accuracy"),this.lossDisplay=document.getElementById("loss"),this.sigmoidToggle=document.getElementById("sigmoid-toggle"),this.solutionBtn=document.getElementById("solution-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.setupHighDPICanvas(),this.plotWidth=this.displayWidth-80,this.plotHeight=this.displayHeight-80,this.plotX=40,this.plotY=40,this.xMin=-10,this.xMax=10,this.yMin=-.5,this.yMax=1.5,this.generateDataPoints(),this.setupEventListeners(),this.initializeDisplay(),this.tabController=new DemoTabController}generateDataPoints(){this.dataPoints=[];const separationPoint=8*(Math.random()-.5);for(let i=0;i<8;i++){const x=separationPoint+4*(Math.random()-.8)+1.5*(Math.random()-.5);this.dataPoints.push({x:x,y:0})}for(let i=0;i<8;i++){const x=separationPoint+4*(Math.random()+.2)+1.5*(Math.random()-.5);this.dataPoints.push({x:x,y:1})}}setupHighDPICanvas(){const dpr=window.devicePixelRatio||1,displayWidth=this.canvas.clientWidth||600,displayHeight=this.canvas.clientHeight||400;this.canvas.width=displayWidth*dpr,this.canvas.height=displayHeight*dpr,this.canvas.style.width=displayWidth+"px",this.canvas.style.height=displayHeight+"px",this.ctx.scale(dpr,dpr),this.ctx.imageSmoothingEnabled=!0,this.ctx.imageSmoothingQuality="high",this.dpr=dpr,this.displayWidth=displayWidth,this.displayHeight=displayHeight}initializeDisplay(){this.draw(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}updateDisplayPlainText(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),useSigmoid=this.sigmoidToggle.checked;this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-",functionName=useSigmoid?"σ(x)":"f(x)";this.equation.textContent=`${functionName} = ${useSigmoid?"σ(":""}${alpha.toFixed(1)}x ${betaSign} ${Math.abs(beta).toFixed(1)}${useSigmoid?")":""}`;const accuracy=this.calculateAccuracy(alpha,beta,useSigmoid),loss=this.calculateLoss(alpha,beta,useSigmoid);this.accuracyDisplay.textContent=`Accuracy = ${(100*accuracy).toFixed(1)}%`,this.lossDisplay.textContent=`Loss = ${loss.toFixed(3)}`}setupEventListeners(){this.alphaSlider.addEventListener("input",()=>{this.updateDisplay(),this.draw()}),this.betaSlider.addEventListener("input",()=>{this.updateDisplay(),this.draw()}),this.sigmoidToggle.addEventListener("change",()=>{this.updateDisplay(),this.draw()}),this.solutionBtn.addEventListener("click",()=>{this.setOptimalValues()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()}),this.canvas.addEventListener("click",event=>{this.handleCanvasClick(event)})}updateDisplay(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),useSigmoid=this.sigmoidToggle.checked;this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-",betaValue=Math.abs(beta).toFixed(1),linearPart=`${alpha.toFixed(1)}x ${betaSign} ${betaValue}`;this.equation.innerHTML=useSigmoid?`$$f(x) = \\sigma(${linearPart})$$`:`$$f(x) = ${linearPart}$$`,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const accuracy=this.calculateAccuracy(alpha,beta,useSigmoid),loss=this.calculateLoss(alpha,beta,useSigmoid);this.accuracyDisplay.innerHTML=`$$\\text{Accuracy} = ${(100*accuracy).toFixed(1)}\\%$$`,this.lossDisplay.innerHTML=`$$\\text{Loss} = ${loss.toFixed(3)}$$`,window.MathJax&&MathJax.typesetPromise([this.accuracyDisplay,this.lossDisplay]).catch(err=>console.log(err))}sigmoid(x){return 1/(1+Math.exp(-x))}predict(x,alpha,beta,useSigmoid){const linear=alpha*x+beta;return useSigmoid?this.sigmoid(linear):linear}classify(x,alpha,beta,useSigmoid){const prediction=this.predict(x,alpha,beta,useSigmoid);return useSigmoid?prediction>.5?1:0:prediction>0?1:0}dataToCanvas(x,y){return{x:this.plotX+(x-this.xMin)/(this.xMax-this.xMin)*this.plotWidth,y:this.plotY+this.plotHeight-(y-this.yMin)/(this.yMax-this.yMin)*this.plotHeight}}drawAxes(){this.ctx.strokeStyle="#333",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY+this.plotHeight),this.ctx.lineTo(this.plotX+this.plotWidth,this.plotY+this.plotHeight),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY),this.ctx.lineTo(this.plotX,this.plotY+this.plotHeight),this.ctx.stroke(),this.drawGrid(),this.drawLabels()}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1;for(let x=this.xMin;x<=this.xMax;x+=2){const canvasPos=this.dataToCanvas(x,0);this.ctx.beginPath(),this.ctx.moveTo(canvasPos.x,this.plotY),this.ctx.lineTo(canvasPos.x,this.plotY+this.plotHeight),this.ctx.stroke()}for(let y=0;y<=1;y+=.5){const canvasPos=this.dataToCanvas(0,y);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,canvasPos.y),this.ctx.lineTo(this.plotX+this.plotWidth,canvasPos.y),this.ctx.stroke()}}drawLabels(){this.ctx.fillStyle="#666",this.ctx.font="12px Arial",this.ctx.textAlign="center";for(let x=this.xMin;x<=this.xMax;x+=2){const canvasPos=this.dataToCanvas(x,0);this.ctx.fillText(x.toString(),canvasPos.x,this.plotY+this.plotHeight+20)}this.ctx.textAlign="right";for(let y=0;y<=1;y+=.5){const canvasPos=this.dataToCanvas(0,y);this.ctx.fillText(y.toString(),this.plotX-10,canvasPos.y+4)}this.ctx.fillStyle="#333",this.ctx.font="14px Arial",this.ctx.textAlign="center",this.ctx.fillText("X",this.plotX+this.plotWidth/2,this.displayHeight-10),this.ctx.save(),this.ctx.translate(15,this.plotY+this.plotHeight/2),this.ctx.rotate(-Math.PI/2),this.ctx.fillText("Class",0,0),this.ctx.restore()}drawDataPoints(){this.dataPoints.forEach(point=>{const canvasPos=this.dataToCanvas(point.x,point.y);0===point.y?(this.ctx.fillStyle="#ff6b6b",this.ctx.strokeStyle="#d63447"):(this.ctx.fillStyle="#4ecdc4",this.ctx.strokeStyle="#26a69a"),this.ctx.lineWidth=2,this.ctx.beginPath(),0===point.y?this.ctx.arc(canvasPos.x,canvasPos.y,5,0,2*Math.PI):this.ctx.rect(canvasPos.x-5,canvasPos.y-5,10,10),this.ctx.fill(),this.ctx.stroke()})}drawDecisionBoundary(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);if(this.sigmoidToggle.checked){this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath();let first=!0;for(let x=this.xMin;x<=this.xMax;x+=.1){const y=this.predict(x,alpha,beta,!0),canvasPos=this.dataToCanvas(x,y);first?(this.ctx.moveTo(canvasPos.x,canvasPos.y),first=!1):this.ctx.lineTo(canvasPos.x,canvasPos.y)}this.ctx.stroke(),this.ctx.strokeStyle="#ff9800",this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]);const thresholdStart=this.dataToCanvas(this.xMin,.5),thresholdEnd=this.dataToCanvas(this.xMax,.5);this.ctx.beginPath(),this.ctx.moveTo(thresholdStart.x,thresholdStart.y),this.ctx.lineTo(thresholdEnd.x,thresholdEnd.y),this.ctx.stroke(),this.ctx.setLineDash([])}else{this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath();const x1=this.xMin,y1=alpha*x1+beta,x2=this.xMax,y2=alpha*x2+beta,start=this.dataToCanvas(x1,y1),end=this.dataToCanvas(x2,y2);this.ctx.moveTo(start.x,start.y),this.ctx.lineTo(end.x,end.y),this.ctx.stroke(),this.ctx.strokeStyle="#ff9800",this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]);const thresholdStart=this.dataToCanvas(this.xMin,0),thresholdEnd=this.dataToCanvas(this.xMax,0);this.ctx.beginPath(),this.ctx.moveTo(thresholdStart.x,thresholdStart.y),this.ctx.lineTo(thresholdEnd.x,thresholdEnd.y),this.ctx.stroke(),this.ctx.setLineDash([])}}calculateAccuracy(alpha,beta,useSigmoid){if(0===this.dataPoints.length)return 0;let correct=0;return this.dataPoints.forEach(point=>{this.classify(point.x,alpha,beta,useSigmoid)===point.y&&correct++}),correct/this.dataPoints.length}calculateLoss(alpha,beta,useSigmoid){if(0===this.dataPoints.length)return 0;let totalLoss=0;return this.dataPoints.forEach(point=>{const prediction=this.predict(point.x,alpha,beta,useSigmoid);if(useSigmoid){const epsilon=1e-15,clippedPred=Math.max(epsilon,Math.min(1-epsilon,prediction));totalLoss+=-(point.y*Math.log(clippedPred)+(1-point.y)*Math.log(1-clippedPred))}else totalLoss+=Math.pow(point.y-prediction,2)}),totalLoss/this.dataPoints.length}setOptimalValues(){if(0===this.dataPoints.length)return;this.sigmoidToggle.checked?this.optimizeForClassification():this.optimizeForRegression(),this.updateDisplay(),this.draw()}optimizeForRegression(){const n=this.dataPoints.length;let sumX=0,sumY=0,sumXY=0,sumXX=0;this.dataPoints.forEach(point=>{sumX+=point.x,sumY+=point.y,sumXY+=point.x*point.y,sumXX+=point.x*point.x});const optimalAlpha=(n*sumXY-sumX*sumY)/(n*sumXX-sumX*sumX),optimalBeta=(sumY-optimalAlpha*sumX)/n,clampedAlpha=Math.max(-5,Math.min(5,optimalAlpha)),clampedBeta=Math.max(-10,Math.min(10,optimalBeta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}optimizeForClassification(){let alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);for(let iter=0;iter<1e3;iter++){let alphaGrad=0,betaGrad=0;if(this.dataPoints.forEach(point=>{const z=alpha*point.x+beta,error=this.sigmoid(z)-point.y;alphaGrad+=error*point.x,betaGrad+=error}),alphaGrad/=this.dataPoints.length,betaGrad/=this.dataPoints.length,alpha-=.1*alphaGrad,beta-=.1*betaGrad,Math.abs(alphaGrad)<.001&&Math.abs(betaGrad)<.001)break}const clampedAlpha=Math.max(-5,Math.min(5,alpha)),clampedBeta=Math.max(-10,Math.min(10,beta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}generateNewData(){this.clearAllData(),this.generateDataPoints(),this.updateDisplay(),this.draw()}clearAllData(){this.dataPoints=[],this.updateDisplay(),this.draw()}handleCanvasClick(event){const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,dataCoords=this.canvasToData(canvasX,canvasY);if(this.isWithinPlotArea(canvasX,canvasY)){const classLabel=dataCoords.y>.5?1:0;this.dataPoints.push({x:dataCoords.x,y:classLabel}),this.updateDisplay(),this.draw()}}canvasToData(canvasX,canvasY){return{x:this.xMin+(canvasX-this.plotX)/this.plotWidth*(this.xMax-this.xMin),y:this.yMax-(canvasY-this.plotY)/this.plotHeight*(this.yMax-this.yMin)}}isWithinPlotArea(canvasX,canvasY){return canvasX>=this.plotX&&canvasX<=this.plotX+this.plotWidth&&canvasY>=this.plotY&&canvasY<=this.plotY+this.plotHeight}draw(){this.ctx.clearRect(0,0,this.displayWidth,this.displayHeight),this.ctx.lineCap="round",this.ctx.lineJoin="round",this.drawAxes(),this.drawDecisionBoundary(),this.drawDataPoints()}}document.addEventListener("DOMContentLoaded",()=>{new ClassificationDemo});