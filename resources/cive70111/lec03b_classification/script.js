class ClassificationDemo{constructor(){this.canvas=document.getElementById("plot"),this.chart=null,this.alphaSlider=document.getElementById("alpha"),this.betaSlider=document.getElementById("beta"),this.alphaValue=document.getElementById("alpha-value"),this.betaValue=document.getElementById("beta-value"),this.equation=document.getElementById("equation"),this.accuracyDisplay=document.getElementById("accuracy"),this.lossDisplay=document.getElementById("loss"),this.sigmoidToggle=document.getElementById("sigmoid-toggle"),this.solutionBtn=document.getElementById("solution-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.xMin=-10,this.xMax=10,this.yMin=-.5,this.yMax=1.5,this.generateDataPoints(),this.initializeChart(),this.setupEventListeners(),this.initializeDisplay(),this.tabController=new DemoTabController}generateDataPoints(){this.dataPoints=[];const separationPoint=8*(Math.random()-.5);for(let i=0;i<8;i++){const x=separationPoint+4*(Math.random()-.8)+1.5*(Math.random()-.5);this.dataPoints.push({x:x,y:0})}for(let i=0;i<8;i++){const x=separationPoint+4*(Math.random()+.2)+1.5*(Math.random()-.5);this.dataPoints.push({x:x,y:1})}}initializeChart(){this.chart=new Chart(this.canvas.getContext("2d"),{type:"scatter",data:{datasets:[{label:"Class 0",data:[],backgroundColor:"#ff6b6b",borderColor:"#d63447",borderWidth:2,pointRadius:6,pointHoverRadius:8,showLine:!1},{label:"Class 1",data:[],backgroundColor:"#4ecdc4",borderColor:"#26a69a",borderWidth:2,pointRadius:6,pointHoverRadius:8,showLine:!1},{label:"Decision Boundary",data:[],backgroundColor:"transparent",borderColor:"#9b59b6",borderWidth:3,pointRadius:0,pointHoverRadius:0,showLine:!0,fill:!1,tension:0}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{type:"linear",position:"bottom",min:this.xMin,max:this.xMax,title:{display:!0,text:"X"},grid:{color:"#e0e0e0"}},y:{type:"linear",position:"left",min:this.yMin,max:this.yMax,title:{display:!0,text:"Y"},grid:{color:"#e0e0e0"}}},plugins:{legend:{display:!0,position:"top"},tooltip:{filter:tooltipItem=>tooltipItem.datasetIndex<2}},onClick:(event,activeElements)=>{this.handleChartClick(event)},animation:{duration:0}}})}initializeDisplay(){this.updateChart(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}updateDisplayPlainText(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),useSigmoid=this.sigmoidToggle.checked;this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-",functionName=useSigmoid?"σ(x)":"f(x)";this.equation.textContent=`${functionName} = ${useSigmoid?"σ(":""}${alpha.toFixed(1)}x ${betaSign} ${Math.abs(beta).toFixed(1)}${useSigmoid?")":""}`;const accuracy=this.calculateAccuracy(alpha,beta,useSigmoid),loss=this.calculateLoss(alpha,beta,useSigmoid);this.accuracyDisplay.textContent=`Accuracy = ${(100*accuracy).toFixed(1)}%`,this.lossDisplay.textContent=`Loss = ${loss.toFixed(3)}`}setupEventListeners(){this.alphaSlider.addEventListener("input",()=>{this.updateDisplay(),this.updateChart()}),this.betaSlider.addEventListener("input",()=>{this.updateDisplay(),this.updateChart()}),this.sigmoidToggle.addEventListener("change",()=>{this.updateDisplay(),this.updateChart()}),this.solutionBtn.addEventListener("click",()=>{this.setOptimalValues()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()})}updateDisplay(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),useSigmoid=this.sigmoidToggle.checked;this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-",betaValue=Math.abs(beta).toFixed(1),linearPart=`${alpha.toFixed(1)}x ${betaSign} ${betaValue}`;this.equation.innerHTML=useSigmoid?`$$f(x) = \\sigma(${linearPart})$$`:`$$f(x) = ${linearPart}$$`,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const accuracy=this.calculateAccuracy(alpha,beta,useSigmoid),loss=this.calculateLoss(alpha,beta,useSigmoid);this.accuracyDisplay.innerHTML=`$$\\text{Accuracy} = ${(100*accuracy).toFixed(1)}\\%$$`,this.lossDisplay.innerHTML=`$$\\text{Loss} = ${loss.toFixed(3)}$$`,window.MathJax&&MathJax.typesetPromise([this.accuracyDisplay,this.lossDisplay]).catch(err=>console.log(err))}sigmoid(x){return 1/(1+Math.exp(-x))}predict(x,alpha,beta,useSigmoid){const linear=alpha*x+beta;return useSigmoid?this.sigmoid(linear):linear}classify(x,alpha,beta,useSigmoid){const prediction=this.predict(x,alpha,beta,useSigmoid);return useSigmoid?prediction>.5?1:0:prediction>0?1:0}calculateAccuracy(alpha,beta,useSigmoid){if(0===this.dataPoints.length)return 0;let correct=0;return this.dataPoints.forEach(point=>{this.classify(point.x,alpha,beta,useSigmoid)===point.y&&correct++}),correct/this.dataPoints.length}calculateLoss(alpha,beta,useSigmoid){if(0===this.dataPoints.length)return 0;let totalLoss=0;return this.dataPoints.forEach(point=>{const prediction=this.predict(point.x,alpha,beta,useSigmoid);if(useSigmoid){const epsilon=1e-15,clippedPred=Math.max(epsilon,Math.min(1-epsilon,prediction));totalLoss+=-(point.y*Math.log(clippedPred)+(1-point.y)*Math.log(1-clippedPred))}else totalLoss+=Math.pow(point.y-prediction,2)}),totalLoss/this.dataPoints.length}setOptimalValues(){if(0===this.dataPoints.length)return;this.sigmoidToggle.checked?this.optimizeForClassification():this.optimizeForRegression(),this.updateDisplay(),this.updateChart()}optimizeForRegression(){const n=this.dataPoints.length;let sumX=0,sumY=0,sumXY=0,sumXX=0;this.dataPoints.forEach(point=>{sumX+=point.x,sumY+=point.y,sumXY+=point.x*point.y,sumXX+=point.x*point.x});const optimalAlpha=(n*sumXY-sumX*sumY)/(n*sumXX-sumX*sumX),optimalBeta=(sumY-optimalAlpha*sumX)/n,clampedAlpha=Math.max(-5,Math.min(5,optimalAlpha)),clampedBeta=Math.max(-10,Math.min(10,optimalBeta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}optimizeForClassification(){let alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);for(let iter=0;iter<1e3;iter++){let alphaGrad=0,betaGrad=0;if(this.dataPoints.forEach(point=>{const z=alpha*point.x+beta,error=this.sigmoid(z)-point.y;alphaGrad+=error*point.x,betaGrad+=error}),alphaGrad/=this.dataPoints.length,betaGrad/=this.dataPoints.length,alpha-=.1*alphaGrad,beta-=.1*betaGrad,Math.abs(alphaGrad)<.001&&Math.abs(betaGrad)<.001)break}const clampedAlpha=Math.max(-5,Math.min(5,alpha)),clampedBeta=Math.max(-10,Math.min(10,beta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}generateNewData(){this.clearAllData(),this.generateDataPoints(),this.updateDisplay(),this.updateChart()}clearAllData(){this.dataPoints=[],this.updateDisplay(),this.updateChart()}handleChartClick(event){const canvasPosition=Chart.helpers.getRelativePosition(event,this.chart),x=this.chart.scales.x.getValueForPixel(canvasPosition.x),y=this.chart.scales.y.getValueForPixel(canvasPosition.y);if(x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax){const classLabel=y>.5?1:0;this.dataPoints.push({x:x,y:classLabel}),this.updateDisplay(),this.updateChart()}}updateChart(){if(!this.chart)return;const class0Points=this.dataPoints.filter(p=>0===p.y).map(p=>({x:p.x,y:p.y})),class1Points=this.dataPoints.filter(p=>1===p.y).map(p=>({x:p.x,y:p.y}));this.chart.data.datasets[0].data=class0Points,this.chart.data.datasets[1].data=class1Points,this.chart.data.datasets[2].data=this.generateDecisionBoundaryData(),this.chart.update("none")}generateDecisionBoundaryData(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),useSigmoid=this.sigmoidToggle.checked,boundaryPoints=[],stepSize=(this.xMax-this.xMin)/200;for(let i=0;i<=200;i++){const x=this.xMin+i*stepSize;let y;y=useSigmoid?1/(1+Math.exp(-(alpha*x+beta))):alpha*x+beta,y>=this.yMin&&y<=this.yMax&&boundaryPoints.push({x:x,y:y})}return boundaryPoints}}document.addEventListener("DOMContentLoaded",()=>{new ClassificationDemo});