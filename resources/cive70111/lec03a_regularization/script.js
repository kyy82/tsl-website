class PolynomialRegularizationDemo{constructor(){this.canvas=document.getElementById("plot"),this.ctx=this.canvas.getContext("2d"),this.equation=document.getElementById("equation"),this.mseDisplay=document.getElementById("mse"),this.maeDisplay=document.getElementById("mae"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.degreeSlider=document.getElementById("degree"),this.degreeValue=document.getElementById("degree-value"),this.l1RegSlider=document.getElementById("l1-reg"),this.l1Value=document.getElementById("l1-value"),this.l2RegSlider=document.getElementById("l2-reg"),this.l2Value=document.getElementById("l2-value"),this.setupHighDPICanvas(),this.plotWidth=this.displayWidth-80,this.plotHeight=this.displayHeight-80,this.plotX=40,this.plotY=40,this.xMin=-10,this.xMax=10,this.yMin=-100,this.yMax=100,this.generateTruePolynomial(),this.generateDataPoints(),this.coefficients=[],this.setupEventListeners(),this.initializeDisplay(),this.tabController=new DemoTabController}generateTruePolynomial(){this.trueCoefficients=[60*(Math.random()-.5),8*(Math.random()-.5),2*(Math.random()-.5),.4*(Math.random()-.5)]}generateDataPoints(){this.dataPoints=[];for(let i=0;i<5;i++){let x,y,attempts=0;do{x=18*(Math.random()-.5);y=this.trueCoefficients[0]+this.trueCoefficients[1]*x+this.trueCoefficients[2]*x*x+this.trueCoefficients[3]*x*x*x+8*(Math.random()-.5)*2,attempts++}while((y<this.yMin||y>this.yMax)&&attempts<50);attempts>=50&&(y=Math.max(this.yMin+10,Math.min(this.yMax-10,y))),this.dataPoints.push({x:x,y:y})}}setupHighDPICanvas(){const dpr=window.devicePixelRatio||1,displayWidth=this.canvas.clientWidth||600,displayHeight=this.canvas.clientHeight||400;this.canvas.width=displayWidth*dpr,this.canvas.height=displayHeight*dpr,this.canvas.style.width=displayWidth+"px",this.canvas.style.height=displayHeight+"px",this.ctx.scale(dpr,dpr),this.ctx.imageSmoothingEnabled=!0,this.ctx.imageSmoothingQuality="high",this.dpr=dpr,this.displayWidth=displayWidth,this.displayHeight=displayHeight}initializeDisplay(){this.updateDegreeDisplay(),this.updateRegularizationDisplay(),this.fitPolynomial(),this.draw(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}getSelectedPowers(){const degree=parseInt(this.degreeSlider.value),selectedPowers=[];for(let i=0;i<=degree;i++)selectedPowers.push(i);return selectedPowers}updateDegreeDisplay(){const degree=parseInt(this.degreeSlider.value);this.degreeValue.textContent=degree.toString()}updateRegularizationDisplay(){const l1=parseFloat(this.l1RegSlider.value),l2=parseFloat(this.l2RegSlider.value);this.l1Value.textContent=l1.toFixed(1),this.l2Value.textContent=l2.toFixed(1)}createDesignMatrix(dataPoints,powers){const n=dataPoints.length,p=powers.length,X=[];for(let i=0;i<n;i++){const row=[],x=dataPoints[i].x;for(let j=0;j<p;j++){const power=powers[j];row.push(Math.pow(x,power))}X.push(row)}return X}fitPolynomial(){if(0===this.dataPoints.length)return void(this.coefficients=[]);const selectedPowers=this.getSelectedPowers();if(0===selectedPowers.length)return void(this.coefficients=[]);const X=this.createDesignMatrix(this.dataPoints,selectedPowers),y=this.dataPoints.map(point=>point.y),l1Lambda=parseFloat(this.l1RegSlider.value),l2Lambda=parseFloat(this.l2RegSlider.value);try{this.coefficients=this.solveRegularizedNormalEquations(X,y,l1Lambda,l2Lambda),this.selectedPowers=selectedPowers}catch(error){console.warn("Matrix inversion failed, using zero coefficients"),this.coefficients=new Array(selectedPowers.length).fill(0),this.selectedPowers=selectedPowers}}solveNormalEquations(X,y){const n=X.length,p=X[0].length,XT=[];for(let i=0;i<p;i++){const row=[];for(let j=0;j<n;j++)row.push(X[j][i]);XT.push(row)}const XTX=[];for(let i=0;i<p;i++){const row=[];for(let j=0;j<p;j++){let sum=0;for(let k=0;k<n;k++)sum+=XT[i][k]*X[k][j];row.push(sum)}XTX.push(row)}const XTy=[];for(let i=0;i<p;i++){let sum=0;for(let j=0;j<n;j++)sum+=XT[i][j]*y[j];XTy.push(sum)}return this.gaussianElimination(XTX,XTy)}gaussianElimination(A,b){const n=A.length,augmented=[];for(let i=0;i<n;i++)augmented.push([...A[i],b[i]]);for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];for(let k=i+1;k<n;k++){if(Math.abs(augmented[i][i])<1e-10)continue;const c=augmented[k][i]/augmented[i][i];for(let j=i;j<=n;j++)augmented[k][j]-=c*augmented[i][j]}}const x=new Array(n).fill(0);for(let i=n-1;i>=0;i--){x[i]=augmented[i][n];for(let j=i+1;j<n;j++)x[i]-=augmented[i][j]*x[j];Math.abs(augmented[i][i])>1e-10&&(x[i]/=augmented[i][i])}return x}solveRegularizedNormalEquations(X,y,l1Lambda,l2Lambda){return 0===l1Lambda?this.solveRidgeRegression(X,y,l2Lambda):this.solveElasticNet(X,y,l1Lambda,l2Lambda)}solveRidgeRegression(X,y,l2Lambda){const n=X.length,p=X[0].length,XT=[];for(let i=0;i<p;i++){const row=[];for(let j=0;j<n;j++)row.push(X[j][i]);XT.push(row)}const XTX=[];for(let i=0;i<p;i++){const row=[];for(let j=0;j<p;j++){let sum=0;for(let k=0;k<n;k++)sum+=XT[i][k]*X[k][j];i===j&&(sum+=l2Lambda),row.push(sum)}XTX.push(row)}const XTy=[];for(let i=0;i<p;i++){let sum=0;for(let j=0;j<n;j++)sum+=XT[i][j]*y[j];XTy.push(sum)}return this.gaussianElimination(XTX,XTy)}solveElasticNet(X,y,l1Lambda,l2Lambda){const n=X.length,p=X[0].length;let coefficients=new Array(p).fill(0);for(let iter=0;iter<100;iter++){let maxChange=0;for(let j=0;j<p;j++){const oldCoeff=coefficients[j];let partialResidual=0;for(let i=0;i<n;i++){let prediction=0;for(let k=0;k<p;k++)k!==j&&(prediction+=coefficients[k]*X[i][k]);partialResidual+=X[i][j]*(y[i]-prediction)}let sumSquares=0;for(let i=0;i<n;i++)sumSquares+=X[i][j]*X[i][j];coefficients[j]=partialResidual>l1Lambda?(partialResidual-l1Lambda)/(sumSquares+l2Lambda):partialResidual<-l1Lambda?(partialResidual+l1Lambda)/(sumSquares+l2Lambda):0,maxChange=Math.max(maxChange,Math.abs(coefficients[j]-oldCoeff))}if(maxChange<1e-6)break}return coefficients}evaluatePolynomial(x){if(!this.coefficients||0===this.coefficients.length)return 0;let result=0;for(let i=0;i<this.coefficients.length;i++){const power=this.selectedPowers[i];result+=this.coefficients[i]*Math.pow(x,power)}return result}setupEventListeners(){this.degreeSlider.addEventListener("input",()=>{this.updateDegreeDisplay(),this.fitPolynomial(),this.updateDisplay(),this.draw()}),this.l1RegSlider.addEventListener("input",()=>{this.updateRegularizationDisplay(),this.fitPolynomial(),this.updateDisplay(),this.draw()}),this.l2RegSlider.addEventListener("input",()=>{this.updateRegularizationDisplay(),this.fitPolynomial(),this.updateDisplay(),this.draw()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()}),this.canvas.addEventListener("click",event=>{this.handleCanvasClick(event)})}updateDisplay(){let equationText="y = ";if(this.coefficients&&0!==this.coefficients.length){const terms=[];let hasNonZeroTerms=!1;for(let i=0;i<this.coefficients.length;i++){const coeff=this.coefficients[i],power=this.selectedPowers[i],isZero=Math.abs(coeff)<1e-6;isZero||(hasNonZeroTerms=!0);let term="";const absCoeff=Math.abs(coeff),sign=coeff>=0?"+":"-";term=0===i?0===power?isZero?"0.00":coeff.toFixed(2):1===power?isZero?"0.00x":`${coeff.toFixed(2)}x`:isZero?`0.00x^{${power}}`:`${coeff.toFixed(2)}x^{${power}}`:0===power?isZero?"+ 0.00":`${sign} ${absCoeff.toFixed(2)}`:1===power?isZero?"+ 0.00x":`${sign} ${absCoeff.toFixed(2)}x`:isZero?`+ 0.00x^{${power}}`:`${sign} ${absCoeff.toFixed(2)}x^{${power}}`,terms.push(term)}hasNonZeroTerms?equationText+=terms.join(" "):equationText="y = 0"}else equationText="y = 0";this.equation.innerHTML=`$$${equationText}$$`,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const mse=this.calculateMSE(),mae=this.calculateMAE();this.mseDisplay.innerHTML=`$$\\text{MSE} = ${mse.toFixed(2)}$$`,this.maeDisplay.innerHTML=`$$\\text{MAE} = ${mae.toFixed(2)}$$`,window.MathJax&&MathJax.typesetPromise([this.mseDisplay,this.maeDisplay]).catch(err=>console.log(err))}updateDisplayPlainText(){let equationText="y = ";if(this.coefficients&&0!==this.coefficients.length){const terms=[];let hasNonZeroTerms=!1;for(let i=0;i<this.coefficients.length;i++){const coeff=this.coefficients[i],power=this.selectedPowers[i],isZero=Math.abs(coeff)<1e-6;isZero||(hasNonZeroTerms=!0);let term="";const absCoeff=Math.abs(coeff),sign=coeff>=0?"+":"-";term=0===i?0===power?isZero?"0.00":coeff.toFixed(2):1===power?isZero?"0.00x":`${coeff.toFixed(2)}x`:isZero?`0.00x^${power}`:`${coeff.toFixed(2)}x^${power}`:0===power?isZero?"+ 0.00":`${sign} ${absCoeff.toFixed(2)}`:1===power?isZero?"+ 0.00x":`${sign} ${absCoeff.toFixed(2)}x`:isZero?`+ 0.00x^${power}`:`${sign} ${absCoeff.toFixed(2)}x^${power}`,terms.push(term)}hasNonZeroTerms?equationText+=terms.join(" "):equationText="y = 0"}else equationText="y = 0";this.equation.textContent=equationText;const mse=this.calculateMSE(),mae=this.calculateMAE();this.mseDisplay.textContent=`MSE = ${mse.toFixed(2)}`,this.maeDisplay.textContent=`MAE = ${mae.toFixed(2)}`}dataToCanvas(x,y){return{x:this.plotX+(x-this.xMin)/(this.xMax-this.xMin)*this.plotWidth,y:this.plotY+this.plotHeight-(y-this.yMin)/(this.yMax-this.yMin)*this.plotHeight}}drawAxes(){this.ctx.strokeStyle="#333",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY+this.plotHeight),this.ctx.lineTo(this.plotX+this.plotWidth,this.plotY+this.plotHeight),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(this.plotX,this.plotY),this.ctx.lineTo(this.plotX,this.plotY+this.plotHeight),this.ctx.stroke(),this.drawGrid(),this.drawLabels()}drawGrid(){this.ctx.strokeStyle="#e0e0e0",this.ctx.lineWidth=1;for(let x=this.xMin;x<=this.xMax;x+=2){const canvasPos=this.dataToCanvas(x,0);this.ctx.beginPath(),this.ctx.moveTo(canvasPos.x,this.plotY),this.ctx.lineTo(canvasPos.x,this.plotY+this.plotHeight),this.ctx.stroke()}for(let y=this.yMin;y<=this.yMax;y+=20){const canvasPos=this.dataToCanvas(0,y);this.ctx.beginPath(),this.ctx.moveTo(this.plotX,canvasPos.y),this.ctx.lineTo(this.plotX+this.plotWidth,canvasPos.y),this.ctx.stroke()}}drawLabels(){this.ctx.fillStyle="#666",this.ctx.font="12px Arial",this.ctx.textAlign="center";for(let x=this.xMin;x<=this.xMax;x+=2){const canvasPos=this.dataToCanvas(x,0);this.ctx.fillText(x.toString(),canvasPos.x,this.plotY+this.plotHeight+20)}this.ctx.textAlign="right";for(let y=this.yMin;y<=this.yMax;y+=20){const canvasPos=this.dataToCanvas(0,y);this.ctx.fillText(y.toString(),this.plotX-10,canvasPos.y+4)}this.ctx.fillStyle="#333",this.ctx.font="14px Arial",this.ctx.textAlign="center",this.ctx.fillText("X",this.plotX+this.plotWidth/2,this.displayHeight-10),this.ctx.save(),this.ctx.translate(15,this.plotY+this.plotHeight/2),this.ctx.rotate(-Math.PI/2),this.ctx.fillText("Y",0,0),this.ctx.restore()}drawDataPoints(){this.ctx.fillStyle="#ff6b6b",this.ctx.strokeStyle="#d63447",this.ctx.lineWidth=2,this.dataPoints.forEach(point=>{const canvasPos=this.dataToCanvas(point.x,point.y);this.ctx.beginPath(),this.ctx.arc(canvasPos.x,canvasPos.y,5,0,2*Math.PI),this.ctx.fill(),this.ctx.stroke()})}drawPolynomialCurve(){if(!this.coefficients||0===this.coefficients.length)return;this.ctx.save(),this.ctx.beginPath(),this.ctx.rect(this.plotX,this.plotY,this.plotWidth,this.plotHeight),this.ctx.clip(),this.ctx.strokeStyle="#4ecdc4",this.ctx.lineWidth=3,this.ctx.beginPath();let firstPoint=!0;const step=(this.xMax-this.xMin)/200;for(let x=this.xMin;x<=this.xMax;x+=step){const y=this.evaluatePolynomial(x),canvasPos=this.dataToCanvas(x,y);firstPoint?(this.ctx.moveTo(canvasPos.x,canvasPos.y),firstPoint=!1):this.ctx.lineTo(canvasPos.x,canvasPos.y)}this.ctx.stroke(),this.ctx.restore()}calculateMSE(){if(0===this.dataPoints.length)return 0;let sumSquaredErrors=0;return this.dataPoints.forEach(point=>{const predicted=this.evaluatePolynomial(point.x),error=point.y-predicted;sumSquaredErrors+=error*error}),sumSquaredErrors/this.dataPoints.length}calculateMAE(){if(0===this.dataPoints.length)return 0;let sumAbsoluteErrors=0;return this.dataPoints.forEach(point=>{const predicted=this.evaluatePolynomial(point.x),error=Math.abs(point.y-predicted);sumAbsoluteErrors+=error}),sumAbsoluteErrors/this.dataPoints.length}generateNewData(){this.generateTruePolynomial(),this.clearAllData(),this.generateDataPoints(),this.fitPolynomial(),this.updateDisplay(),this.draw()}clearAllData(){this.dataPoints=[],this.fitPolynomial(),this.updateDisplay(),this.draw()}handleCanvasClick(event){const rect=this.canvas.getBoundingClientRect(),canvasX=event.clientX-rect.left,canvasY=event.clientY-rect.top,dataCoords=this.canvasToData(canvasX,canvasY);this.isWithinPlotArea(canvasX,canvasY)&&(this.dataPoints.push({x:dataCoords.x,y:dataCoords.y}),this.fitPolynomial(),this.updateDisplay(),this.draw())}canvasToData(canvasX,canvasY){return{x:this.xMin+(canvasX-this.plotX)/this.plotWidth*(this.xMax-this.xMin),y:this.yMax-(canvasY-this.plotY)/this.plotHeight*(this.yMax-this.yMin)}}isWithinPlotArea(canvasX,canvasY){return canvasX>=this.plotX&&canvasX<=this.plotX+this.plotWidth&&canvasY>=this.plotY&&canvasY<=this.plotY+this.plotHeight}drawErrorLines(){this.ctx.strokeStyle="#777777",this.ctx.lineWidth=1,this.ctx.setLineDash([2,2]),this.dataPoints.forEach(point=>{const predicted=this.evaluatePolynomial(point.x),pointCanvas=this.dataToCanvas(point.x,point.y),predictedCanvas=this.dataToCanvas(point.x,predicted);this.ctx.beginPath(),this.ctx.moveTo(pointCanvas.x,pointCanvas.y),this.ctx.lineTo(predictedCanvas.x,predictedCanvas.y),this.ctx.stroke()}),this.ctx.setLineDash([])}draw(){this.ctx.clearRect(0,0,this.displayWidth,this.displayHeight),this.ctx.lineCap="round",this.ctx.lineJoin="round",this.drawAxes(),this.drawErrorLines(),this.drawDataPoints(),this.drawPolynomialCurve()}}document.addEventListener("DOMContentLoaded",()=>{new PolynomialRegularizationDemo});